diff -Naur a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
--- a/arch/arm/boot/dts/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/boot/dts/Makefile	2015-02-12 05:40:38.000000000 -0800
@@ -516,6 +516,9 @@
 	dove-d3plug.dtb \
 	dove-dove-db.dtb
 dtb-$(CONFIG_ARCH_MEDIATEK) += mt6589-aquaris5.dtb
+dtb-$(CONFIG_ARCH_OXNAS) += \
+	ox820-pogoplug-pro.dtb \
+	ox820-pogoplug-classic.dtb
 
 targets += dtbs dtbs_install
 targets += $(dtb-y)
diff -Naur a/arch/arm/boot/dts/ox820.dtsi b/arch/arm/boot/dts/ox820.dtsi
--- a/arch/arm/boot/dts/ox820.dtsi	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/boot/dts/ox820.dtsi	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2013 Ma Haijun <mahaijuns@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "plxtech,nas7820", "plxtech,nas782x";
+	interrupt-parent = <&gic>;
+
+	aliases {
+		serial0 = &uart0;
+		/* alias to determine bank index */
+		gpio0 = &GPIOA;
+		gpio1 = &GPIOB;
+
+		ethernet0 = &gmac;
+	};
+
+	cpus {
+		cpu@0 {
+			compatible = "arm,arm11mpcore";
+		};
+		cpu@1 {
+			compatible = "arm,arm11mpcore";
+		};
+	};
+
+	gic: gic@47001000 {
+		compatible = "arm,arm11mp-gic";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = <0x47001000 0x1000>,
+		      <0x47000100 0x0100>;
+	};
+
+	rst: reset-controller@44E00034 {
+		compatible = "plxtech,nas782x-reset";
+		#reset-cells = <1>;
+		reg = <0x44E00034 0x8>; /* currently not used */
+	};
+
+	rps: rps@44400000 {
+		compatible = "plxtech,nas782x-rps";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		reg = <0x44400000 0x14>;
+		interrupts = <0 5 0x304>;
+	};
+
+	/* external oscillator */
+	osc: oscillator {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <25000000>;
+	};
+
+	sysclk: sysclk {
+		compatible = "fixed-factor-clock";
+		#clock-cells = <0>;
+		clock-div = <4>;
+		clock-mult = <1>;
+		clocks = <&osc>;
+	};
+
+	plla: plla@44e001f0 {
+		compatible = "plxtech,nas782x-plla";
+		#clock-cells = <0>;
+		clocks = <&osc>;
+		reg = <0x44e001f0 0x10>;
+	};
+
+	pllb: pllb@44f001f0 {
+		compatible = "plxtech,nas782x-pllb";
+		#clock-cells = <0>;
+		clocks = <&osc>;
+		reg = <0x44f001f0 0x10>;
+		resets = <&rst 31>;
+	};
+
+	stdclk: stdclk {
+		compatible = "plxtech,nas782x-stdclk";
+		#clock-cells = <1>;
+		clocks = <&osc>;
+	};
+
+	twdclk: twdclk {
+		compatible = "fixed-factor-clock";
+		#clock-cells = <0>;
+		clock-div = <2>;
+		clock-mult = <1>;
+		clocks = <&plla>;
+	};
+
+	gmacclk: gmacclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <125000000>;
+	};
+
+	pinctrl {
+		/* act as a simple bus, so children will be probed automatically */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "plxtech,nas782x-pinctrl", "simple-bus";
+		ranges;
+
+		plxtech,mux-mask = <
+			 0xFFFFFFFF 0xCC0FFDF9 0xFC000E60 0x0F03F7E0 0xF00C0FE0
+			 0x0003FFFF 0x00037FFF 0x0003FFF8 0x00000F00 0x0003F7F3
+			>;
+
+		GPIOA: gpio@44000000 {
+			compatible = "plxtech,nas782x-gpio";
+			reg = <0x44000000 0x100>, <0x44E00000 0x200>;
+			interrupts = <0 21 0x304>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			#gpio-lines = <32>; /* real gpio pin count */
+		};
+
+		GPIOB: gpio@44100000 {
+			compatible = "plxtech,nas782x-gpio";
+			reg = <0x44100000 0x100>, <0x44F00000 0x200>;
+			interrupts = <0 22 0x304>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			#gpio-lines = <18>; /* real gpio pin count */
+		};
+
+		uart0 {
+			pinctrl_uart0: uart0-0 {
+				plxtech,pins =
+					<0 30 5 0	/* MF_A30 PINMUX_ALT PINMUX_UARTA_SIN */
+					 0 31 5 0>;	/* MF_A31 PINMUX_ALT PINMUX_UARTA_SOUT */
+			};
+		};
+
+		gmac0 {
+			pinctrl_gmac0: gmac0-0 {
+				plxtech,pins =
+					<0 3 1 0	/* MF_A3 PINMUX_2 PINMUX_MACA_MDC */
+					 0 4 1 0>;	/* MF_A4 PINMUX_2 PINMUX_MACA_MDIO */
+			};
+		};
+
+		nand0 {
+			pinctrl_nand0: nand0-0 {
+				plxtech,pins =
+					<0 12 1 0	/* MF_A12 PINMUX_2 PINMUX_STATIC_DATA0 */
+					 0 13 1 0	/* MF_A13 PINMUX_2 PINMUX_STATIC_DATA1 */
+					 0 14 1 0	/* MF_A14 PINMUX_2 PINMUX_STATIC_DATA2 */
+					 0 15 1 0	/* MF_A15 PINMUX_2 PINMUX_STATIC_DATA3 */
+					 0 16 1 0	/* MF_A16 PINMUX_2 PINMUX_STATIC_DATA4 */
+					 0 17 1 0	/* MF_A17 PINMUX_2 PINMUX_STATIC_DATA5 */
+					 0 18 1 0	/* MF_A18 PINMUX_2 PINMUX_STATIC_DATA6 */
+					 0 19 1 0	/* MF_A19 PINMUX_2 PINMUX_STATIC_DATA7 */
+
+					 0 20 1 0	/* MF_A20 PINMUX_2 PINMUX_STATIC_NWE */
+					 0 21 1 0	/* MF_A21 PINMUX_2 PINMUX_STATIC_NOE */
+					 0 22 1 0	/* MF_A22 PINMUX_2 PINMUX_STATIC_NCS */
+					 0 23 1 0	/* MF_A23 PINMUX_2 PINMUX_STATIC_ADDR18 */
+					 0 24 1 0>;	/* MF_A24 PINMUX_2 PINMUX_STATIC_ADDR19 */
+			};
+		};
+	};
+
+	pcie-controller@47C00000 {
+		compatible = "plxtech,nas782x-pcie";
+		device_type = "pci";
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		/*		flag & space	bus address	host address	size */
+		ranges = <	0x82000000	0 0x48000000	0x48000000	0 0x2000000
+				0xC2000000	0 0x4A000000	0x4A000000	0 0x1E00000
+				0x81000000	0 0x4BE00000	0x4BE00000	0 0x0100000
+				0x80000000	0 0x4BF00000	0x4BF00000	0 0x0100000>;
+
+		bus-range = <0x00 0x7f>;
+
+		/*	cfg			inbound translator	phy*/
+		reg =	<0x47C00000 0x1000>,	<0x47D00000 0x100>,	 <0x44A00000 0x10>;
+
+		#interrupt-cells = <1>;
+		/* wild card mask, match all bus address & interrupt specifier */
+		/* format: bus address mask, interrupt specifier mask */
+		/* each bit 1 means need match, 0 means ignored when match */
+		interrupt-map-mask = <0 0 0 0>;
+		/* format: a list of: bus address, interrupt specifier, 
+		 * parent interrupt controller & specifier */
+		interrupt-map = <0 0 0 0 &gic 0 19 0x304>;
+
+		gpios = <&GPIOB 12 0>;
+		clocks = <&stdclk 8>, <&pllb>;
+		clock-names = "pcie", "busclk";
+		resets = <&rst 7>, <&rst 14>;
+		reset-names = "pcie", "phy";
+
+		plxtech,pcie-hcsl-bit = <2>;
+		plxtech,pcie-ctrl-offset = <0x120>;
+		plxtech,pcie-outbound-offset = <0x138>;
+		status = "disabled";
+	};
+
+	pcie-controller@47E00000 {
+		compatible = "plxtech,nas782x-pcie";
+		device_type = "pci";
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		/*		flag & space	bus address	host address	size */
+		ranges = <	0x82000000	0 0x4C000000	0x4C000000	0 0x2000000
+				0xC2000000	0 0x4E000000	0x4E000000	0 0x1E00000
+				0x81000000	0 0x4FE00000	0x4FE00000	0 0x0100000
+				0x80000000	0 0x4FF00000	0x4FF00000	0 0x0100000>;
+
+		bus-range = <0x80 0xff>;
+
+		/*	cfg			inbound translator	phy*/
+		reg =	<0x47E00000 0x1000>,	<0x47F00000 0x100>,	<0x44A00000 0x10>;
+
+		#interrupt-cells = <1>;
+		/* wild card mask, match all bus address & interrupt specifier */
+		/* format: bus address mask, interrupt specifier mask */
+		/* each bit 1 means need match, 0 means ignored when match */
+		interrupt-map-mask = <0 0 0 0>;
+		/* format: a list of: bus address, interrupt specifier, 
+		 * parent interrupt controller & specifier */
+		interrupt-map = <0 0 0 0 &gic 0 20 0x304>;
+
+		/* gpios = <&GPIOB 12 0>; */
+		clocks = <&stdclk 11>, <&pllb>;
+		clock-names = "pcie", "busclk";
+		resets = <&rst 23>, <&rst 14>;
+		reset-names = "pcie", "phy";
+
+		plxtech,pcie-hcsl-bit = <3>;
+		plxtech,pcie-ctrl-offset = <0x124>;
+		plxtech,pcie-outbound-offset = <0x174>;
+		status = "disabled";
+	};
+
+	local-timer@47000600 {
+		compatible = "arm,arm11mp-twd-timer";
+		reg = <0x47000600 0x20>;
+		interrupts = <1 13 0x304>;	/* percpu, irq 29, cpu mask 3, level high */
+		clocks = <&twdclk>;
+	};
+
+	watchdog@47000620 {
+		compatible = "mpcore_wdt";
+		reg = <0x47000620 0x20>;
+		interrupts = <1 14 0x304>;	/* percpu, irq 30, cpu mask 3, level high */
+		clocks = <&twdclk>;
+	};
+
+	timer@44400200 {
+		compatible = "plxtech,nas782x-rps-timer";
+		reg = <0x44400200 0x40>;
+		clocks = <&sysclk>;
+	};
+
+	uart0: uart@44200000 {
+		compatible = "ns16550a";
+		reg = <0x44200000 0x100>;
+		clock-frequency = <6250000>;
+		interrupts = <0 23 0x304>;
+		reg-shift = <0>;
+		fifo-size = <16>;
+		reg-io-width = <1>;
+		current-speed = <115200>;
+		no-loopback-test;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_uart0>;
+		status = "disabled";
+	};
+
+	sata@45900000 {
+		compatible = "plxtech,nas782x-sata";
+			/*	port		sgdma		core	*/
+		reg = <0x45900000 0x100>, <0x459B0000 0x10>, <0x459E0000 0x2000>,
+			/*	phy		descriptors (optional)	*/
+			<0x44900000 0x0C>, <0x50000000 0x1000>;
+		interrupts = <0 18 0x304>;
+		clocks = <&stdclk 4>;
+		resets = <&rst 11>, <&rst 12>, <&rst 13>;
+		reset-names = "sata", "link", "phy";
+		status = "disabled";
+	};
+
+	nand@41000000 {
+		compatible = "plxtech,nand-nas782x", "gen_nand";
+		reg = <0x41000000 0x100000>, <0x41C00000 0x20>;
+		nand-ecc-mode = "soft";
+		clocks = <&stdclk 9>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_nand0>;
+		resets = <&rst 15>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		status = "disabled";
+	};
+
+	gmac: ethernet@40400000 {
+		compatible = "plxtech,nas782x-gmac", "snps,dwmac";
+		reg = <0x40400000 0x2000>;
+		interrupts = <0 8 0x304>, <0 17 0x304>;
+		interrupt-names = "macirq", "eth_wake_irq";
+		mac-address = [000000000000]; /* Filled in by U-Boot */
+		phy-mode = "rgmii";
+		clocks = <&stdclk 7>, <&gmacclk>;
+		clock-names = "gmac", "stmmaceth";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gmac0>;
+		resets = <&rst 6>;
+		status = "disabled";
+	};
+
+	ehci@40200100 {
+		compatible = "plxtch,nas782x-ehci";
+		reg = <0x40200100 0xf00>;
+		interrupts = <0 7 0x304>;
+		clocks = <&stdclk 6>, <&pllb>, <&stdclk 12>;
+		clock-names = "usb", "refsrc", "phyref";
+		resets = <&rst 4>, <&rst 5>, <&rst 26>;
+		reset-names = "host", "phya", "phyb";
+		/* Otherwise ref300 is used, which is derived from sata phy
+		 * in that case, usb depends on sata initialization */
+		/* FIXME: how to make this dependency explicit ? */
+		plxtch,ehci_use_pllb;
+		status = "disabled";
+	};
+};
diff -Naur a/arch/arm/boot/dts/ox820-pogoplug-classic.dts b/arch/arm/boot/dts/ox820-pogoplug-classic.dts
--- a/arch/arm/boot/dts/ox820-pogoplug-classic.dts	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/boot/dts/ox820-pogoplug-classic.dts	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2013 Ma Haijun <mahaijuns@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+#include "ox820.dtsi"
+
+/ {
+	model = "Pogoplug Pro";
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 root=/dev/sda2 rootfstype=ext4 ubi.mtd=data,512";
+	};
+
+	uart@44200000 {
+		status = "okay";
+	};
+
+	sata@45900000 {
+		status = "okay";
+	};
+
+	nand@41000000 {
+		status = "okay";
+
+		partition@0 {
+			label = "boot";
+			reg = <0x00000000 0x00e00000>;
+			/*read-only;*/
+		};
+
+		partition@e00000 {
+			label = "data";
+			reg = <0x00e00000 0x07200000>;
+		};
+	};
+
+	ethernet@40400000 {
+		status = "okay";
+	};
+
+	ehci@40200100 {
+		status = "okay";
+	};
+
+	pinctrl {
+		leds {
+			pinctrl_leds: leds-0 {
+				plxtech,pins =
+					<0 2 0 0	/* MF_A2 */
+					 1 16 0 0	/* MF_B16 */
+					 1 17 0 0>;	/* MF_B17 */
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds>;
+
+		blue {
+			label = "pogoplug:blue:usr";
+			gpios = <&GPIOA 2 0>;
+
+		};
+
+		orange {
+			label = "pogoplug:orange:usr";
+			gpios = <&GPIOB 16 1>;
+		};
+
+		green {
+			label = "pogoplug:green:usr";
+			gpios = <&GPIOB 17 1>;
+			linux,default-trigger = "default-on";
+		};
+	};
+};
diff -Naur a/arch/arm/boot/dts/ox820-pogoplug-pro.dts b/arch/arm/boot/dts/ox820-pogoplug-pro.dts
--- a/arch/arm/boot/dts/ox820-pogoplug-pro.dts	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/boot/dts/ox820-pogoplug-pro.dts	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2013 Ma Haijun <mahaijuns@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+#include "ox820.dtsi"
+
+/ {
+	model = "Pogoplug Pro";
+
+	chosen {
+		bootargs = "console=ttyS0,115200n8 root=/dev/sda2 rootfstype=ext4 ubi.mtd=data,512";
+	};
+
+	pcie-controller@47C00000 {
+		status = "okay";
+	};
+
+	uart@44200000 {
+		status = "okay";
+	};
+
+	sata@45900000 {
+		status = "okay";
+	};
+
+	nand@41000000 {
+		status = "okay";
+
+		partition@0 {
+			label = "boot";
+			reg = <0x00000000 0x00e00000>;
+			/*read-only;*/
+		};
+
+		partition@e00000 {
+			label = "data";
+			reg = <0x00e00000 0x07200000>;
+		};
+	};
+
+	ethernet@40400000 {
+		status = "okay";
+	};
+
+	ehci@40200100 {
+		status = "okay";
+	};
+
+	pinctrl {
+		leds {
+			pinctrl_leds: leds-0 {
+				plxtech,pins =
+					<0 2 0 0	/* MF_A2 */
+					 1 16 0 0	/* MF_B16 */
+					 1 17 0 0>;	/* MF_B17 */
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds>;
+
+		blue {
+			label = "pogoplug:blue:usr";
+			gpios = <&GPIOA 2 0>;
+
+		};
+
+		orange {
+			label = "pogoplug:orange:usr";
+			gpios = <&GPIOB 16 1>;
+		};
+
+		green {
+			label = "pogoplug:green:usr";
+			gpios = <&GPIOB 17 1>;
+			linux,default-trigger = "default-on";
+		};
+	};
+};
diff -Naur a/arch/arm/configs/ox820_defconfig b/arch/arm/configs/ox820_defconfig
--- a/arch/arm/configs/ox820_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/configs/ox820_defconfig	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,104 @@
+CONFIG_CROSS_COMPILE="arm-linux-gnueabi-"
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_CGROUPS=y
+CONFIG_NAMESPACES=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_ARCH_OXNAS=y
+# CONFIG_DMA_CACHE_RWFO is not set
+CONFIG_DMA_CACHE_FIQ_BROADCAST=y
+CONFIG_PCI=y
+CONFIG_PCI_OXNAS=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_USE_OF=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IPV6=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_RC_PID=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_OXNAS=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_ATA=y
+CONFIG_SATA_OXNAS=y
+CONFIG_NETDEVICES=y
+CONFIG_STMMAC_ETH=y
+CONFIG_STMMAC_DEBUG_FS=y
+CONFIG_STMMAC_DA=y
+CONFIG_ATH_CARDS=y
+CONFIG_ATH9K=y
+CONFIG_ATH9K_LEGACY_RATE_CONTROL=y
+# CONFIG_RTL_CARDS is not set
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_OXNAS=y
+CONFIG_USB_STORAGE=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_COMMON_CLK_DEBUG=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=m
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_ROOT_NFS=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_LL_UART_8250=y
+CONFIG_DEBUG_UART_PHYS=0x44200000
+CONFIG_DEBUG_UART_VIRT=0xF0000000
+CONFIG_DEBUG_UART_8250_SHIFT=0
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
diff -Naur a/arch/arm/include/asm/glue-cache.h b/arch/arm/include/asm/glue-cache.h
--- a/arch/arm/include/asm/glue-cache.h	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/include/asm/glue-cache.h	2015-02-11 08:26:27.000000000 -0800
@@ -156,11 +156,19 @@
 #define __cpuc_flush_user_range		__glue(_CACHE,_flush_user_cache_range)
 #define __cpuc_coherent_kern_range	__glue(_CACHE,_coherent_kern_range)
 #define __cpuc_coherent_user_range	__glue(_CACHE,_coherent_user_range)
+#ifndef CONFIG_DMA_CACHE_FIQ_BROADCAST
 #define __cpuc_flush_dcache_area	__glue(_CACHE,_flush_kern_dcache_area)
 
 #define dmac_map_area			__glue(_CACHE,_dma_map_area)
 #define dmac_unmap_area			__glue(_CACHE,_dma_unmap_area)
 #define dmac_flush_range		__glue(_CACHE,_dma_flush_range)
+#else
+#define __cpuc_flush_dcache_area	__glue(fiq,_flush_kern_dcache_area)
+
+#define dmac_map_area			__glue(fiq,_dma_map_area)
+#define dmac_unmap_area			__glue(fiq,_dma_unmap_area)
+#define dmac_flush_range		__glue(fiq,_dma_flush_range)
+#endif /* CONFIG_DMA_CACHE_FIQ_BROADCAST */
 #endif
 
 #endif
diff -Naur a/arch/arm/Kconfig b/arch/arm/Kconfig
--- a/arch/arm/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/Kconfig	2015-02-11 08:26:27.000000000 -0800
@@ -369,6 +369,17 @@
 	help
 	  This enables support for ARM Ltd Versatile board.
 
+config ARCH_OXNAS
+	bool "Oxford Semiconductor 815/820/825 NAS SoC"
+	select ARCH_REQUIRE_GPIOLIB
+	select CLKDEV_LOOKUP
+	select GENERIC_CLOCKEVENTS
+	select COMMON_CLK
+	select MIGHT_HAVE_PCI
+	select ARCH_HAS_RESET_CONTROLLER
+	help
+		This enables support for Oxsemi 815/820/825 NAS SoC
+
 config ARCH_AT91
 	bool "Atmel AT91"
 	select ARCH_REQUIRE_GPIOLIB
@@ -922,6 +933,8 @@
 
 source "arch/arm/mach-orion5x/Kconfig"
 
+source "arch/arm/mach-oxnas/Kconfig"
+
 source "arch/arm/mach-picoxcell/Kconfig"
 
 source "arch/arm/mach-pxa/Kconfig"
diff -Naur a/arch/arm/mach-oxnas/fiq.S b/arch/arm/mach-oxnas/fiq.S
--- a/arch/arm/mach-oxnas/fiq.S	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/fiq.S	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,87 @@
+/*
+ *  Copyright (C) 2012 Gateworks Corporation
+ *      Chris Lang <clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/asm-offsets.h>
+
+#define D_CACHE_LINE_SIZE 32
+
+	.text
+
+/*
+ * R8  - DMA Start Address
+ * R9  - DMA Length
+ * R10 - DMA Direction
+ * R11 - DMA type
+ * R12 - fiq_buffer Address
+*/
+
+	.global	ox820_fiq_end
+ENTRY(ox820_fiq_start)
+	str	r8, [r13]
+
+	ldmia	r12, {r8, r9, r10}
+	and	r11, r10, #0x3000000
+	and	r10, r10, #0xff
+
+	teq	r11, #0x1000000
+	beq	ox820_dma_map_area
+	teq	r11, #0x2000000
+	beq	ox820_dma_unmap_area
+	/* fall through */
+ox820_dma_flush_range:
+	bic	r8, r8, #D_CACHE_LINE_SIZE - 1
+1:
+	mcr	p15, 0, r8, c7, c14, 1		@ clean & invalidate D line
+	add	r8, r8, #D_CACHE_LINE_SIZE
+	cmp	r8, r9
+	blo	1b
+	/* fall through */
+ox820_fiq_exit:
+	mov	r8, #0
+	str	r8, [r12, #8]
+	mcr	p15, 0, r8, c7, c10, 4		@ drain write buffer
+	subs	pc, lr, #4
+
+ox820_dma_map_area:
+	add	r9, r9, r8
+	teq	r10, #DMA_FROM_DEVICE
+	beq	ox820_dma_inv_range
+	teq	r10, #DMA_TO_DEVICE
+	bne	ox820_dma_flush_range
+	/* fall through */
+ox820_dma_clean_range:
+	bic	r8, r8, #D_CACHE_LINE_SIZE - 1
+1:
+	mcr	p15, 0, r8, c7, c10, 1		@ clean D line
+	add	r8, r8, #D_CACHE_LINE_SIZE
+	cmp	r8, r9
+	blo	1b
+	b	ox820_fiq_exit
+
+ox820_dma_unmap_area:
+	add	r9, r9, r8
+	teq	r10, #DMA_TO_DEVICE
+	beq	ox820_fiq_exit
+	/* fall through */
+ox820_dma_inv_range:
+	tst	r8, #D_CACHE_LINE_SIZE - 1
+	bic	r8, r8, #D_CACHE_LINE_SIZE - 1
+	mcrne	p15, 0, r8, c7, c10, 1		@ clean D line
+	tst	r9, #D_CACHE_LINE_SIZE - 1
+	bic	r9, r9, #D_CACHE_LINE_SIZE - 1
+	mcrne	p15, 0, r9, c7, c14, 1		@ clean & invalidate D line
+1:
+	mcr	p15, 0, r8, c7, c6, 1		@ invalidate D line
+	add	r8, r8, #D_CACHE_LINE_SIZE
+	cmp	r8, r9
+	blo	1b
+	b	ox820_fiq_exit
+
+ox820_fiq_end:
diff -Naur a/arch/arm/mach-oxnas/headsmp.S b/arch/arm/mach-oxnas/headsmp.S
--- a/arch/arm/mach-oxnas/headsmp.S	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/headsmp.S	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,26 @@
+/*
+ *  linux/arch/arm/mach-ox820/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+/*
+ * OX820 specific entry point for secondary CPUs.
+ */
+ENTRY(ox820_secondary_startup)
+	mov r4, #0
+	mcr p15, 0, r4, c7, c7, 0 @ invalidate both caches and branch target cache
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
diff -Naur a/arch/arm/mach-oxnas/hotplug.c b/arch/arm/mach-oxnas/hotplug.c
--- a/arch/arm/mach-oxnas/hotplug.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/hotplug.c	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,112 @@
+/*
+ *  linux/arch/arm/mach-realview/hotplug.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+
+#include <asm/cp15.h>
+#include <asm/smp_plat.h>
+#include <mach/smp.h>
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0), "Ir" (CR_C)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(	"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, %1\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  : "Ir" (CR_C)
+	  : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu, int *spurious)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		/*
+		 * here's the WFI
+		 */
+		asm(".word	0xe320f003\n"
+		    :
+		    :
+		    : "memory", "cc");
+
+		if (read_pen_release() == cpu_logical_map(cpu)) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * Getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * Just note it happening - when we're woken, we can report
+		 * its occurrence.
+		 */
+		(*spurious)++;
+	}
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void __ref ox820_cpu_die(unsigned int cpu)
+{
+	int spurious = 0;
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu, &spurious);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+
+	if (spurious)
+		pr_warn("CPU%u: %u spurious wakeup calls\n", cpu, spurious);
+}
diff -Naur a/arch/arm/mach-oxnas/include/mach/hardware.h b/arch/arm/mach-oxnas/include/mach/hardware.h
--- a/arch/arm/mach-oxnas/include/mach/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/hardware.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,233 @@
+/*
+ * arch/arm/mach-0x820/include/mach/hardware.h
+ *
+ * Copyright (C) 2009 Oxford Semiconductor Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/io.h>
+#include <mach/iomap.h>
+
+/*
+ * Location of flags and vectors in SRAM for controlling the booting of the
+ * secondary ARM11 processors.
+ */
+
+#define OXNAS_SCU_BASE_VA		OXNAS_PERCPU_BASE_VA
+#define OXNAS_GICN_BASE_VA(n)		(OXNAS_PERCPU_BASE_VA + 0x200 + n * 0x100)
+
+#define HOLDINGPEN_CPU			IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xc8)
+#define HOLDINGPEN_LOCATION		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xc4)
+
+/**
+ * System block reset and clock control
+ */
+#define SYS_CTRL_PCI_STAT		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x20)
+#define SYSCTRL_CLK_STAT		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x24)
+#define SYS_CTRL_CLK_SET_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x2C)
+#define SYS_CTRL_CLK_CLR_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x30)
+#define SYS_CTRL_RST_SET_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x34)
+#define SYS_CTRL_RST_CLR_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x38)
+
+#define SYS_CTRL_PLLSYS_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x48)
+#define SYS_CTRL_CLK_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x64)
+#define SYS_CTRL_PLLSYS_KEY_CTRL	IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x6C)
+#define SYS_CTRL_GMAC_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x78)
+#define SYS_CTRL_GMAC_DELAY_CTRL	IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x100)
+
+/* Scratch registers */
+#define SYS_CTRL_SCRATCHWORD0		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xc4)
+#define SYS_CTRL_SCRATCHWORD1		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xc8)
+#define SYS_CTRL_SCRATCHWORD2		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xcc)
+#define SYS_CTRL_SCRATCHWORD3		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xd0)
+
+#define SYS_CTRL_PLLA_CTRL0		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x1F0)
+#define SYS_CTRL_PLLA_CTRL1		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x1F4)
+#define SYS_CTRL_PLLA_CTRL2		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x1F8)
+#define SYS_CTRL_PLLA_CTRL3		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x1FC)
+
+#define SYS_CTRL_USBHSMPH_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x40)
+#define SYS_CTRL_USBHSMPH_STAT		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x44)
+#define SYS_CTRL_REF300_DIV		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xF8)
+#define SYS_CTRL_USBHSPHY_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x84)
+#define SYS_CTRL_USB_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x90)
+
+/* pcie */
+#define SYS_CTRL_HCSL_CTRL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x114)
+
+/* System control multi-function pin function selection */
+#define SYS_CTRL_SECONDARY_SEL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x14)
+#define SYS_CTRL_TERTIARY_SEL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x8c)
+#define SYS_CTRL_QUATERNARY_SEL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x94)
+#define SYS_CTRL_DEBUG_SEL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0x9c)
+#define SYS_CTRL_ALTERNATIVE_SEL	IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xa4)
+#define SYS_CTRL_PULLUP_SEL		IOMEM(OXNAS_SYSCRTL_BASE_VA + 0xac)
+
+/* Secure control multi-function pin function selection */
+#define SEC_CTRL_SECONDARY_SEL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x14)
+#define SEC_CTRL_TERTIARY_SEL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x8c)
+#define SEC_CTRL_QUATERNARY_SEL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x94)
+#define SEC_CTRL_DEBUG_SEL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x9c)
+#define SEC_CTRL_ALTERNATIVE_SEL	IOMEM(OXNAS_SECCRTL_BASE_VA + 0xa4)
+#define SEC_CTRL_PULLUP_SEL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0xac)
+
+#define SEC_CTRL_COPRO_CTRL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x68)
+#define SEC_CTRL_SECURE_CTRL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x98)
+#define SEC_CTRL_LEON_DEBUG		IOMEM(OXNAS_SECCRTL_BASE_VA + 0xF0)
+#define SEC_CTRL_PLLB_DIV_CTRL		IOMEM(OXNAS_SECCRTL_BASE_VA + 0xF8)
+#define SEC_CTRL_PLLB_CTRL0		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x1F0)
+#define SEC_CTRL_PLLB_CTRL1		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x1F4)
+#define SEC_CTRL_PLLB_CTRL8		IOMEM(OXNAS_SECCRTL_BASE_VA + 0x1F4)
+
+#define RPSA_IRQ_SOFT			IOMEM(OXNAS_RPSA_BASE_VA + 0x10)
+#define RPSA_FIQ_ENABLE			IOMEM(OXNAS_RPSA_BASE_VA + 0x108)
+#define RPSA_FIQ_DISABLE		IOMEM(OXNAS_RPSA_BASE_VA + 0x10C)
+#define RPSA_FIQ_IRQ_TO_FIQ		IOMEM(OXNAS_RPSA_BASE_VA + 0x1FC)
+
+#define RPSC_IRQ_SOFT			IOMEM(OXNAS_RPSC_BASE_VA + 0x10)
+#define RPSC_FIQ_ENABLE			IOMEM(OXNAS_RPSC_BASE_VA + 0x108)
+#define RPSC_FIQ_DISABLE		IOMEM(OXNAS_RPSC_BASE_VA + 0x10C)
+#define RPSC_FIQ_IRQ_TO_FIQ		IOMEM(OXNAS_RPSC_BASE_VA + 0x1FC)
+
+#define RPSA_TIMER2_VAL			IOMEM(OXNAS_RPSA_BASE_VA + 0x224)
+
+#define REF300_DIV_INT_SHIFT		8
+#define REF300_DIV_FRAC_SHIFT		0
+#define REF300_DIV_INT(val)		((val) << REF300_DIV_INT_SHIFT)
+#define REF300_DIV_FRAC(val)		((val) << REF300_DIV_FRAC_SHIFT)
+
+#define USBHSPHY_SUSPENDM_MANUAL_ENABLE		16
+#define USBHSPHY_SUSPENDM_MANUAL_STATE		15
+#define USBHSPHY_ATE_ESET			14
+#define USBHSPHY_TEST_DIN			6
+#define USBHSPHY_TEST_ADD			2
+#define USBHSPHY_TEST_DOUT_SEL			1
+#define USBHSPHY_TEST_CLK			0
+
+#define USB_CTRL_USBAPHY_CKSEL_SHIFT	5
+#define USB_CLK_XTAL0_XTAL1		(0 << USB_CTRL_USBAPHY_CKSEL_SHIFT)
+#define USB_CLK_XTAL0			(1 << USB_CTRL_USBAPHY_CKSEL_SHIFT)
+#define USB_CLK_INTERNAL		(2 << USB_CTRL_USBAPHY_CKSEL_SHIFT)
+
+#define USBAMUX_DEVICE			BIT(4)
+
+#define USBPHY_REFCLKDIV_SHIFT		2
+#define USB_PHY_REF_12MHZ		(0 << USBPHY_REFCLKDIV_SHIFT)
+#define USB_PHY_REF_24MHZ		(1 << USBPHY_REFCLKDIV_SHIFT)
+#define USB_PHY_REF_48MHZ		(2 << USBPHY_REFCLKDIV_SHIFT)
+
+#define USB_CTRL_USB_CKO_SEL_BIT	0
+
+#define USB_INT_CLK_XTAL 		0
+#define USB_INT_CLK_REF300		2
+#define USB_INT_CLK_PLLB		3
+
+#define SYS_CTRL_GMAC_CKEN_RX_IN     	14
+#define SYS_CTRL_GMAC_CKEN_RXN_OUT     	13
+#define SYS_CTRL_GMAC_CKEN_RX_OUT     	12
+#define SYS_CTRL_GMAC_CKEN_TX_IN    	10
+#define SYS_CTRL_GMAC_CKEN_TXN_OUT   	9
+#define SYS_CTRL_GMAC_CKEN_TX_OUT     	8
+#define SYS_CTRL_GMAC_RX_SOURCE     	7
+#define SYS_CTRL_GMAC_TX_SOURCE     	6
+#define SYS_CTRL_GMAC_LOW_TX_SOURCE     4
+#define SYS_CTRL_GMAC_AUTO_TX_SOURCE	3
+#define SYS_CTRL_GMAC_RGMII         	2
+#define SYS_CTRL_GMAC_SIMPLE_MUX    	1
+#define SYS_CTRL_GMAC_CKEN_GTX      	0
+#define SYS_CTRL_GMAC_TX_VARDELAY_SHIFT		0
+#define SYS_CTRL_GMAC_TXN_VARDELAY_SHIFT	8
+#define SYS_CTRL_GMAC_RX_VARDELAY_SHIFT		16
+#define SYS_CTRL_GMAC_RXN_VARDELAY_SHIFT	24
+#define SYS_CTRL_GMAC_TX_VARDELAY(d)	((d) << SYS_CTRL_GMAC_TX_VARDELAY_SHIFT)
+#define SYS_CTRL_GMAC_TXN_VARDELAY(d)	((d) << SYS_CTRL_GMAC_TXN_VARDELAY_SHIFT)
+#define SYS_CTRL_GMAC_RX_VARDELAY(d)	((d) << SYS_CTRL_GMAC_RX_VARDELAY_SHIFT)
+#define SYS_CTRL_GMAC_RXN_VARDELAY(d)	((d) << SYS_CTRL_GMAC_RXN_VARDELAY_SHIFT)
+
+#define PLLB_BYPASS			1
+#define PLLB_ENSAT			3
+#define PLLB_OUTDIV			4
+#define PLLB_REFDIV			8
+#define PLLB_DIV_INT_SHIFT		8
+#define PLLB_DIV_FRAC_SHIFT		0
+#define PLLB_DIV_INT(val)		((val) << PLLB_DIV_INT_SHIFT)
+#define PLLB_DIV_FRAC(val)		((val) << PLLB_DIV_FRAC_SHIFT)
+
+#define SYS_CTRL_CKCTRL_PCI_DIV_BIT	0
+#define SYS_CTRL_CKCTRL_SLOW_BIT	8
+
+#define SYS_CTRL_UART2_DEQ_EN		0
+#define SYS_CTRL_UART3_DEQ_EN		1
+#define SYS_CTRL_UART3_IQ_EN		2
+#define SYS_CTRL_UART4_IQ_EN		3
+#define SYS_CTRL_UART4_NOT_PCI_MODE	4
+
+#define SYS_CTRL_PCI_CTRL1_PCI_STATIC_RQ_BIT	11
+
+#define PLLA_REFDIV_MASK		0x3F
+#define PLLA_REFDIV_SHIFT		8
+#define PLLA_OUTDIV_MASK		0x7
+#define PLLA_OUTDIV_SHIFT		4
+
+/* bit numbers of clock control register */
+#define SYS_CTRL_CLK_COPRO		0
+#define SYS_CTRL_CLK_DMA		1
+#define SYS_CTRL_CLK_CIPHER		2
+#define SYS_CTRL_CLK_SD			3
+#define SYS_CTRL_CLK_SATA		4
+#define SYS_CTRL_CLK_I2S		5
+#define SYS_CTRL_CLK_USBHS		6
+#define SYS_CTRL_CLK_MACA		7
+#define SYS_CTRL_CLK_MAC		SYS_CTRL_CLK_MACA
+#define SYS_CTRL_CLK_PCIEA		8
+#define SYS_CTRL_CLK_STATIC		9
+#define SYS_CTRL_CLK_MACB		10
+#define SYS_CTRL_CLK_PCIEB		11
+#define SYS_CTRL_CLK_REF600		12
+#define SYS_CTRL_CLK_USBDEV		13
+#define SYS_CTRL_CLK_DDR		14
+#define SYS_CTRL_CLK_DDRPHY		15
+#define SYS_CTRL_CLK_DDRCK		16
+
+
+/* bit numbers of reset control register */
+#define SYS_CTRL_RST_SCU		0
+#define SYS_CTRL_RST_COPRO		1
+#define SYS_CTRL_RST_ARM0		2
+#define SYS_CTRL_RST_ARM1		3
+#define SYS_CTRL_RST_USBHS		4
+#define SYS_CTRL_RST_USBHSPHYA		5
+#define SYS_CTRL_RST_MACA		6
+#define SYS_CTRL_RST_MAC		SYS_CTRL_RST_MACA
+#define SYS_CTRL_RST_PCIEA		7
+#define SYS_CTRL_RST_SGDMA		8
+#define SYS_CTRL_RST_CIPHER		9
+#define SYS_CTRL_RST_DDR		10
+#define SYS_CTRL_RST_SATA		11
+#define SYS_CTRL_RST_SATA_LINK		12
+#define SYS_CTRL_RST_SATA_PHY		13
+#define SYS_CTRL_RST_PCIEPHY		14
+#define SYS_CTRL_RST_STATIC		15
+#define SYS_CTRL_RST_GPIO		16
+#define SYS_CTRL_RST_UART1		17
+#define SYS_CTRL_RST_UART2		18
+#define SYS_CTRL_RST_MISC		19
+#define SYS_CTRL_RST_I2S		20
+#define SYS_CTRL_RST_SD			21
+#define SYS_CTRL_RST_MACB		22
+#define SYS_CTRL_RST_PCIEB		23
+#define SYS_CTRL_RST_VIDEO		24
+#define SYS_CTRL_RST_DDR_PHY		25
+#define SYS_CTRL_RST_USBHSPHYB		26
+#define SYS_CTRL_RST_USBDEV		27
+#define SYS_CTRL_RST_ARMDBG		29
+#define SYS_CTRL_RST_PLLA		30
+#define SYS_CTRL_RST_PLLB		31
+
+#endif
diff -Naur a/arch/arm/mach-oxnas/include/mach/iomap.h b/arch/arm/mach-oxnas/include/mach/iomap.h
--- a/arch/arm/mach-oxnas/include/mach/iomap.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/iomap.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,33 @@
+#ifndef __MACH_OXNAS_IOMAP_H
+#define __MACH_OXNAS_IOMAP_H
+
+#include <asm/sizes.h>
+
+#define OXNAS_UART1_BASE	0x44200000
+#define OXNAS_UART1_SIZE	SZ_32
+#define OXNAS_UART1_BASE_VA	0xF0000000
+
+#define OXNAS_UART2_BASE	0x44300000
+#define OXNAS_UART2_SIZE	SZ_32
+
+#define OXNAS_PERCPU_BASE	0x47000000
+#define OXNAS_PERCPU_SIZE	SZ_8K
+#define OXNAS_PERCPU_BASE_VA	0xF0002000
+
+#define OXNAS_SYSCRTL_BASE	0x44E00000
+#define OXNAS_SYSCRTL_SIZE	SZ_4K
+#define OXNAS_SYSCRTL_BASE_VA	0xF0004000
+
+#define OXNAS_SECCRTL_BASE	0x44F00000
+#define OXNAS_SECCRTL_SIZE	SZ_4K
+#define OXNAS_SECCRTL_BASE_VA	0xF0005000
+
+#define OXNAS_RPSA_BASE		0x44400000
+#define OXNAS_RPSA_SIZE		SZ_4K
+#define OXNAS_RPSA_BASE_VA	0xF0006000
+
+#define OXNAS_RPSC_BASE		0x44500000
+#define OXNAS_RPSC_SIZE		SZ_4K
+#define OXNAS_RPSC_BASE_VA	0xF0007000
+
+#endif
diff -Naur a/arch/arm/mach-oxnas/include/mach/irqs.h b/arch/arm/mach-oxnas/include/mach/irqs.h
--- a/arch/arm/mach-oxnas/include/mach/irqs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/irqs.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,7 @@
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#define IRQ_SOFT	1
+#define NR_IRQS		160
+
+#endif
diff -Naur a/arch/arm/mach-oxnas/include/mach/smp.h b/arch/arm/mach-oxnas/include/mach/smp.h
--- a/arch/arm/mach-oxnas/include/mach/smp.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/smp.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,26 @@
+/*
+ * smp.h
+ *
+ *  Created on: Sep 24, 2013
+ *      Author: mahaijun
+ */
+
+#ifndef _NAS782X_SMP_H_
+#define _NAS782X_SMP_H_
+
+#include <mach/hardware.h>
+
+extern void ox820_secondary_startup(void);
+extern void ox820_cpu_die(unsigned int cpu);
+
+static inline void write_pen_release(int val)
+{
+	writel(val, HOLDINGPEN_CPU);
+}
+
+static inline int read_pen_release(void)
+{
+	return readl(HOLDINGPEN_CPU);
+}
+
+#endif /* _NAS782X_SMP_H_ */
diff -Naur a/arch/arm/mach-oxnas/include/mach/timex.h b/arch/arm/mach-oxnas/include/mach/timex.h
--- a/arch/arm/mach-oxnas/include/mach/timex.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/timex.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,6 @@
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#define CLOCK_TICK_RATE		6250000
+
+#endif
diff -Naur a/arch/arm/mach-oxnas/include/mach/uncompress.h b/arch/arm/mach-oxnas/include/mach/uncompress.h
--- a/arch/arm/mach-oxnas/include/mach/uncompress.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/uncompress.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,31 @@
+/* linux/include/asm-arm/arch-oxnas/uncompress.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#define OXNAS_UART1_BASE 0x44200000
+
+static inline void putc(int c)
+{
+    static volatile unsigned char* uart = (volatile unsigned char*)OXNAS_UART1_BASE;
+
+    while (!(uart[5] & 0x20)) { /* LSR reg THR empty bit */
+        barrier();
+    }
+    uart[0] = c;                /* THR register */
+}
+
+static inline void flush(void)
+{
+}
+
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif // __ASM_ARCH_UNCOMPRESS_H
diff -Naur a/arch/arm/mach-oxnas/include/mach/utils.h b/arch/arm/mach-oxnas/include/mach/utils.h
--- a/arch/arm/mach-oxnas/include/mach/utils.h	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/include/mach/utils.h	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,31 @@
+#ifndef _NAS782X_UTILS_H
+#define _NAS782X_UTILS_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+
+static inline void oxnas_register_clear_mask(void __iomem *p, unsigned mask)
+{
+	u32 val = readl_relaxed(p);
+	val &= ~mask;
+	writel_relaxed(val, p);
+}
+
+static inline void oxnas_register_set_mask(void __iomem *p, unsigned mask)
+{
+	u32 val = readl_relaxed(p);
+	val |= mask;
+	writel_relaxed(val, p);
+}
+
+static inline void oxnas_register_value_mask(void __iomem *p,
+                                             unsigned mask, unsigned new_value)
+{
+	/* TODO sanity check mask & new_value = new_value */
+	u32 val = readl_relaxed(p);
+	val &= ~mask;
+	val |= new_value;
+	writel_relaxed(val, p);
+}
+
+#endif /* _NAS782X_UTILS_H */
diff -Naur a/arch/arm/mach-oxnas/Kconfig b/arch/arm/mach-oxnas/Kconfig
--- a/arch/arm/mach-oxnas/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/Kconfig	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,24 @@
+choice
+	prompt "Oxnas platform type"
+	default MACH_OXNAS
+	depends on ARCH_OXNAS
+
+config MACH_OX820
+	bool "Generic NAS7820 Support"
+	select ARM_GIC
+	select GENERIC_CLOCKEVENTS
+	select CPU_V6K
+	select HAVE_ARM_SCU if SMP
+	select HAVE_ARM_TWD if SMP
+	select HAVE_SMP
+	select PLXTECH_RPS
+	select CLKSRC_OF
+	select CLKSRC_RPS_TIMER
+	select USB_ARCH_HAS_EHCI
+	select PINCTRL_OXNAS
+	select PINCTRL
+	select RESET_CONTROLLER_OXNAS
+	help
+	  Include support for the ox820 platform.
+
+endchoice
diff -Naur a/arch/arm/mach-oxnas/mach-ox820.c b/arch/arm/mach-oxnas/mach-ox820.c
--- a/arch/arm/mach-oxnas/mach-ox820.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/mach-ox820.c	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,283 @@
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/bug.h>
+#include <linux/of_platform.h>
+#include <linux/clocksource.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/stmmac.h>
+#include <linux/slab.h>
+#include <linux/gfp.h>
+#include <linux/reset.h>
+#include <asm/mach-types.h>
+#include <asm/mach/map.h>
+#include <asm/mach/arch.h>
+#include <asm/page.h>
+#include <mach/iomap.h>
+#include <mach/hardware.h>
+#include <mach/utils.h>
+
+extern struct smp_operations ox820_smp_ops;
+
+static struct map_desc ox820_io_desc[] __initdata = {
+	{
+		.virtual = (unsigned long)OXNAS_PERCPU_BASE_VA,
+		.pfn = __phys_to_pfn(OXNAS_PERCPU_BASE),
+		.length = OXNAS_PERCPU_SIZE,
+		.type = MT_DEVICE,
+	},
+	{
+		.virtual = (unsigned long)OXNAS_SYSCRTL_BASE_VA,
+		.pfn = __phys_to_pfn(OXNAS_SYSCRTL_BASE),
+		.length = OXNAS_SYSCRTL_SIZE,
+		.type = MT_DEVICE,
+	},
+	{
+		.virtual = (unsigned long)OXNAS_SECCRTL_BASE_VA,
+		.pfn = __phys_to_pfn(OXNAS_SECCRTL_BASE),
+		.length = OXNAS_SECCRTL_SIZE,
+		.type = MT_DEVICE,
+	},
+	{
+		.virtual = (unsigned long)OXNAS_RPSA_BASE_VA,
+		.pfn = __phys_to_pfn(OXNAS_RPSA_BASE),
+		.length = OXNAS_RPSA_SIZE,
+		.type = MT_DEVICE,
+	},
+	{
+		.virtual = (unsigned long)OXNAS_RPSC_BASE_VA,
+		.pfn = __phys_to_pfn(OXNAS_RPSC_BASE),
+		.length = OXNAS_RPSC_SIZE,
+		.type = MT_DEVICE,
+	},
+};
+
+void __init ox820_map_common_io(void)
+{
+	debug_ll_io_init();
+	iotable_init(ox820_io_desc, ARRAY_SIZE(ox820_io_desc));
+}
+
+struct plat_gmac_data {
+	struct plat_stmmacenet_data stmmac;
+	struct clk *clk;
+};
+
+int ox820_gmac_init(struct platform_device *pdev)
+{
+	int ret;
+	unsigned value;
+	struct plat_gmac_data *pdata = pdev->dev.platform_data;
+
+	ret = device_reset(&pdev->dev);
+	if (ret)
+		return ret;
+
+	pdata->clk = clk_get(&pdev->dev, "gmac");
+	if (IS_ERR(pdata->clk))
+		return PTR_ERR(pdata->clk);
+	clk_prepare_enable(pdata->clk);
+
+	value = readl(SYS_CTRL_GMAC_CTRL);
+
+	/* Enable GMII_GTXCLK to follow GMII_REFCLK - required for gigabit PHY */
+	value |= BIT(SYS_CTRL_GMAC_CKEN_GTX);
+	/* Use simple mux for 25/125 Mhz clock switching */
+	value |= BIT(SYS_CTRL_GMAC_SIMPLE_MUX);
+	/* set auto switch tx clock source */
+	value |= BIT(SYS_CTRL_GMAC_AUTO_TX_SOURCE);
+	/* enable tx & rx vardelay */
+	value |= BIT(SYS_CTRL_GMAC_CKEN_TX_OUT);
+	value |= BIT(SYS_CTRL_GMAC_CKEN_TXN_OUT);
+	value |= BIT(SYS_CTRL_GMAC_CKEN_TX_IN);
+	value |= BIT(SYS_CTRL_GMAC_CKEN_RX_OUT);
+	value |= BIT(SYS_CTRL_GMAC_CKEN_RXN_OUT);
+	value |= BIT(SYS_CTRL_GMAC_CKEN_RX_IN);
+	writel(value, SYS_CTRL_GMAC_CTRL);
+
+	/* set tx & rx vardelay */
+	value = 0;
+	value |= SYS_CTRL_GMAC_TX_VARDELAY(4);
+	value |= SYS_CTRL_GMAC_TXN_VARDELAY(2);
+	value |= SYS_CTRL_GMAC_RX_VARDELAY(10);
+	value |= SYS_CTRL_GMAC_RXN_VARDELAY(8);
+	writel(value, SYS_CTRL_GMAC_DELAY_CTRL);
+
+	return 0;
+}
+
+void ox820_gmac_exit(struct platform_device *pdev)
+{
+	struct plat_gmac_data *pdata = pdev->dev.platform_data;
+	struct reset_control *rstc;
+
+	clk_disable_unprepare(pdata->clk);
+	clk_put(pdata->clk);
+
+	rstc = reset_control_get(&pdev->dev, NULL);
+	if (!IS_ERR(rstc)) {
+		reset_control_assert(rstc);
+		reset_control_put(rstc);
+	}
+}
+
+static int __init ox820_ether_init(void)
+{
+	struct device_node *node;
+	struct platform_device *pdev;
+	struct plat_gmac_data *pdata;
+
+	node = of_find_compatible_node(NULL, NULL, "plxtech,nas782x-gmac");
+	if (!node)
+		return -ENOENT;
+
+	pdev = of_find_device_by_node(node);
+	of_node_put(node);
+
+	if (!pdev)
+		return -EINVAL;
+
+	pdata= kzalloc(sizeof(struct plat_gmac_data), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->stmmac.init = ox820_gmac_init;
+	pdata->stmmac.exit = ox820_gmac_exit;
+	pdev->dev.platform_data = pdata;
+
+	return 0;
+}
+
+static void __init ox820_dt_init(void)
+{
+        int ret;
+
+        ret = of_platform_populate(NULL, of_default_bus_match_table, NULL,
+                                   NULL);
+        if (ret) {
+                pr_err("of_platform_populate failed: %d\n", ret);
+                BUG();
+        }
+
+        ret = ox820_ether_init();
+
+        if (ret) {
+                pr_info("ox820_ether_init failed: %d\n", ret);
+        }
+}
+
+static void __init ox820_timer_init(void)
+{
+	of_clk_init(NULL);
+	clocksource_of_init();
+	return;
+}
+
+void ox820_init_early(void)
+{
+
+	pr_info("Start Ox820 platform\n", 0);
+}
+
+void ox820_assert_system_reset(enum reboot_mode mode, const char * cmd)
+{
+	u32 value;
+
+	// Assert reset to cores as per power on defaults
+	// Don't touch the DDR interface as things will come to an impromptu stop
+	// NB Possibly should be asserting reset for PLLB, but there are timing
+	//    concerns here according to the docs
+
+	value =
+		BIT(SYS_CTRL_RST_COPRO     ) |
+		BIT(SYS_CTRL_RST_USBHS     ) |
+		BIT(SYS_CTRL_RST_USBHSPHYA ) |
+		BIT(SYS_CTRL_RST_MACA      ) |
+		BIT(SYS_CTRL_RST_PCIEA     ) |
+		BIT(SYS_CTRL_RST_SGDMA     ) |
+		BIT(SYS_CTRL_RST_CIPHER    ) |
+		BIT(SYS_CTRL_RST_SATA      ) |
+		BIT(SYS_CTRL_RST_SATA_LINK ) |
+		BIT(SYS_CTRL_RST_SATA_PHY  ) |
+		BIT(SYS_CTRL_RST_PCIEPHY   ) |
+		BIT(SYS_CTRL_RST_STATIC    ) |
+		BIT(SYS_CTRL_RST_UART1     ) |
+		BIT(SYS_CTRL_RST_UART2     ) |
+		BIT(SYS_CTRL_RST_MISC      ) |
+		BIT(SYS_CTRL_RST_I2S       ) |
+		BIT(SYS_CTRL_RST_SD        ) |
+		BIT(SYS_CTRL_RST_MACB      ) |
+		BIT(SYS_CTRL_RST_PCIEB     ) |
+		BIT(SYS_CTRL_RST_VIDEO     ) |
+		BIT(SYS_CTRL_RST_USBHSPHYB ) |
+		BIT(SYS_CTRL_RST_USBDEV    );
+
+	writel(value, SYS_CTRL_RST_SET_CTRL);
+
+	// Release reset to cores as per power on defaults
+	writel(BIT(SYS_CTRL_RST_GPIO), SYS_CTRL_RST_CLR_CTRL);
+
+	// Disable clocks to cores as per power-on defaults - must leave DDR
+	// related clocks enabled otherwise we'll stop rather abruptly.
+	value =
+		BIT(SYS_CTRL_CLK_COPRO) 	|
+		BIT(SYS_CTRL_CLK_DMA)   	|
+		BIT(SYS_CTRL_CLK_CIPHER)	|
+		BIT(SYS_CTRL_CLK_SD)  		|
+		BIT(SYS_CTRL_CLK_SATA)  	|
+		BIT(SYS_CTRL_CLK_I2S)   	|
+		BIT(SYS_CTRL_CLK_USBHS) 	|
+		BIT(SYS_CTRL_CLK_MAC)   	|
+		BIT(SYS_CTRL_CLK_PCIEA)   	|
+		BIT(SYS_CTRL_CLK_STATIC)	|
+		BIT(SYS_CTRL_CLK_MACB)		|
+		BIT(SYS_CTRL_CLK_PCIEB)		|
+		BIT(SYS_CTRL_CLK_REF600)	|
+		BIT(SYS_CTRL_CLK_USBDEV);
+
+	writel(value, SYS_CTRL_CLK_CLR_CTRL);
+
+	// Enable clocks to cores as per power-on defaults
+
+	// Set sys-control pin mux'ing as per power-on defaults
+	writel(0, SYS_CTRL_SECONDARY_SEL);
+	writel(0, SYS_CTRL_TERTIARY_SEL);
+	writel(0, SYS_CTRL_QUATERNARY_SEL);
+	writel(0, SYS_CTRL_DEBUG_SEL);
+	writel(0, SYS_CTRL_ALTERNATIVE_SEL);
+	writel(0, SYS_CTRL_PULLUP_SEL);
+
+	writel(0, SYS_CTRL_SECONDARY_SEL);
+	writel(0, SYS_CTRL_TERTIARY_SEL);
+	writel(0, SYS_CTRL_QUATERNARY_SEL);
+	writel(0, SYS_CTRL_DEBUG_SEL);
+	writel(0, SYS_CTRL_ALTERNATIVE_SEL);
+	writel(0, SYS_CTRL_PULLUP_SEL);
+
+	// No need to save any state, as the ROM loader can determine whether reset
+	// is due to power cycling or programatic action, just hit the (self-
+	// clearing) CPU reset bit of the block reset register
+	value =
+		BIT(SYS_CTRL_RST_SCU) |
+		BIT(SYS_CTRL_RST_ARM0) |
+		BIT(SYS_CTRL_RST_ARM1);
+
+	writel(value, SYS_CTRL_RST_SET_CTRL);
+}
+
+static const char * const ox820_dt_board_compat[] = {
+	"plxtech,nas7820",
+	"plxtech,nas7821",
+	"plxtech,nas7825",
+	NULL
+};
+
+DT_MACHINE_START(OX820_DT, "PLXTECH NAS782X SoC (Flattened Device Tree)")
+	.map_io		= ox820_map_common_io,
+	.smp		= smp_ops(ox820_smp_ops),
+	.init_early	= ox820_init_early,
+	.init_time	= ox820_timer_init,
+	.init_machine	= ox820_dt_init,
+	.restart	= ox820_assert_system_reset,
+	.dt_compat	= ox820_dt_board_compat,
+MACHINE_END
diff -Naur a/arch/arm/mach-oxnas/Makefile b/arch/arm/mach-oxnas/Makefile
--- a/arch/arm/mach-oxnas/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/Makefile	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,8 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-$(CONFIG_MACH_OX820)		+= mach-ox820.o
+obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o
+obj-$(CONFIG_DMA_CACHE_FIQ_BROADCAST)	+= fiq.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
diff -Naur a/arch/arm/mach-oxnas/Makefile.boot b/arch/arm/mach-oxnas/Makefile.boot
--- a/arch/arm/mach-oxnas/Makefile.boot	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/Makefile.boot	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,2 @@
+   zreladdr-y	+= 0x60008000
+params_phys-y	:= 0x60000100
diff -Naur a/arch/arm/mach-oxnas/platsmp.c b/arch/arm/mach-oxnas/platsmp.c
--- a/arch/arm/mach-oxnas/platsmp.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-oxnas/platsmp.c	2015-02-11 08:26:27.000000000 -0800
@@ -0,0 +1,325 @@
+/*
+ *  arch/arm/mach-ox820/platsmp.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/cache.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_scu.h>
+#include <asm/tlbflush.h>
+#include <asm/cputype.h>
+#include <asm/delay.h>
+#include <asm/fiq.h>
+
+#include <linux/irqchip/arm-gic.h>
+#include <mach/iomap.h>
+#include <mach/smp.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+#ifdef CONFIG_DMA_CACHE_FIQ_BROADCAST
+
+#define FIQ_GENERATE		0x00000002
+#define OXNAS_MAP_AREA		0x01000000
+#define OXNAS_UNMAP_AREA	0x02000000
+#define OXNAS_FLUSH_RANGE	0x03000000
+
+struct fiq_req {
+	union {
+		struct {
+			const void *addr;
+			size_t size;
+		} map;
+		struct {
+			const void *addr;
+			size_t size;
+		} unmap;
+		struct {
+			const void *start;
+			const void *end;
+		} flush;
+	};
+	volatile uint flags;
+	void __iomem *reg;
+} ____cacheline_aligned;
+
+static struct fiq_handler fh = {
+	.name = "oxnas-fiq"
+};
+
+extern unsigned char ox820_fiq_start, ox820_fiq_end;
+extern void v6_dma_map_area(const void *, size_t, int);
+extern void v6_dma_unmap_area(const void *, size_t, int);
+extern void v6_dma_flush_range(const void *, const void *);
+extern void v6_flush_kern_dcache_area(void *, size_t);
+
+DEFINE_PER_CPU(struct fiq_req, fiq_data);
+
+static inline void __cpuinit ox820_set_fiq_regs(unsigned int cpu)
+{
+	struct pt_regs FIQ_regs;
+	struct fiq_req *fiq_req = &per_cpu(fiq_data, !cpu);
+
+	FIQ_regs.ARM_r8 = 0;
+	FIQ_regs.ARM_ip = (unsigned int)fiq_req;
+	FIQ_regs.ARM_sp = (int)(cpu ? RPSC_IRQ_SOFT : RPSA_IRQ_SOFT);
+	fiq_req->reg = cpu ? RPSC_IRQ_SOFT : RPSA_IRQ_SOFT;
+
+	set_fiq_regs(&FIQ_regs);
+}
+
+static void __init ox820_init_fiq(void)
+{
+	void *fiqhandler_start;
+	unsigned int fiqhandler_length;
+	int ret;
+
+	fiqhandler_start = &ox820_fiq_start;
+	fiqhandler_length = &ox820_fiq_end - &ox820_fiq_start;
+
+	ret = claim_fiq(&fh);
+
+	if (ret) {
+		return;
+	}
+
+	set_fiq_handler(fiqhandler_start, fiqhandler_length);
+
+	writel(IRQ_SOFT, RPSA_FIQ_IRQ_TO_FIQ);
+	writel(1, RPSA_FIQ_ENABLE);
+	writel(IRQ_SOFT, RPSC_FIQ_IRQ_TO_FIQ);
+	writel(1, RPSC_FIQ_ENABLE);
+}
+
+void fiq_dma_map_area(const void *addr, size_t size, int dir)
+{
+	unsigned long flags;
+	struct fiq_req *req;
+
+	raw_local_irq_save(flags);
+	/* currently, not possible to take cpu0 down, so only check cpu1 */
+	if(!cpu_online(1)) {
+		raw_local_irq_restore(flags);
+		v6_dma_map_area(addr, size, dir);
+		return;
+	}
+
+	req = this_cpu_ptr(&fiq_data);
+	req->map.addr = addr;
+	req->map.size = size;
+	req->flags = dir | OXNAS_MAP_AREA;
+	smp_mb();
+
+	writel_relaxed(FIQ_GENERATE, req->reg);
+
+	v6_dma_map_area(addr, size, dir);
+	while (req->flags) {
+		barrier();
+	}
+
+	raw_local_irq_restore(flags);
+}
+
+void fiq_dma_unmap_area(const void *addr, size_t size, int dir)
+{
+	unsigned long flags;
+	struct fiq_req *req;
+
+	raw_local_irq_save(flags);
+	/* currently, not possible to take cpu0 down, so only check cpu1 */
+	if(!cpu_online(1)) {
+		raw_local_irq_restore(flags);
+		v6_dma_unmap_area(addr, size, dir);
+		return;
+	}
+
+	req = this_cpu_ptr(&fiq_data);
+	req->unmap.addr = addr;
+	req->unmap.size = size;
+	req->flags = dir | OXNAS_UNMAP_AREA;
+	smp_mb();
+
+	writel_relaxed(FIQ_GENERATE, req->reg);
+
+	v6_dma_unmap_area(addr, size, dir);
+	while (req->flags) {
+		barrier();
+	}
+
+	raw_local_irq_restore(flags);
+}
+
+void fiq_dma_flush_range(const void *start, const void *end)
+{
+	unsigned long flags;
+	struct fiq_req *req;
+
+	raw_local_irq_save(flags);
+	/* currently, not possible to take cpu0 down, so only check cpu1 */
+	if(!cpu_online(1)) {
+		raw_local_irq_restore(flags);
+		v6_dma_flush_range(start, end);
+		return;
+	}
+
+	req = this_cpu_ptr(&fiq_data);
+
+	req->flush.start = start;
+	req->flush.end = end;
+	req->flags = OXNAS_FLUSH_RANGE;
+	smp_mb();
+
+	writel_relaxed(FIQ_GENERATE, req->reg);
+
+	v6_dma_flush_range(start, end);
+
+	while (req->flags) {
+		barrier();
+	}
+
+	raw_local_irq_restore(flags);
+}
+
+void fiq_flush_kern_dcache_area(void *addr, size_t size)
+{
+	fiq_dma_flush_range(addr, addr + size);
+}
+#else
+
+#define ox820_set_fiq_regs(cpu)	do {} while (0) /* nothing */
+#define ox820_init_fiq()	do {} while (0) /* nothing */
+
+#endif /* DMA_CACHE_FIQ_BROADCAST */
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit ox820_secondary_init(unsigned int cpu)
+{
+	/*
+	 * Setup Secondary Core FIQ regs
+	 */
+	ox820_set_fiq_regs(1);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit ox820_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	write_pen_release(cpu);
+
+	writel(1, IOMEM(OXNAS_GICN_BASE_VA(cpu) + GIC_CPU_CTRL));
+
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (read_pen_release() == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return read_pen_release() != -1 ? -ENOSYS : 0;
+}
+
+void *scu_base_addr(void)
+{
+	return  IOMEM(OXNAS_SCU_BASE_VA);
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+static void __init ox820_smp_init_cpus(void)
+{
+	void __iomem *scu_base = scu_base_addr();
+	unsigned int i, ncores;
+
+	ncores = scu_base ? scu_get_core_count(scu_base) : 1;
+
+	/* sanity check */
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+static void __init ox820_smp_prepare_cpus(unsigned int max_cpus)
+{
+
+	scu_enable(scu_base_addr());
+
+	/*
+	 * Write the address of secondary startup into the
+	 * system-wide flags register. The BootMonitor waits
+	 * until it receives a soft interrupt, and then the
+	 * secondary CPU branches to this address.
+	 */
+	writel(virt_to_phys(ox820_secondary_startup),
+					HOLDINGPEN_LOCATION);
+	ox820_init_fiq();
+
+	ox820_set_fiq_regs(0);
+}
+
+struct smp_operations ox820_smp_ops __initdata = {
+	.smp_init_cpus		= ox820_smp_init_cpus,
+	.smp_prepare_cpus	= ox820_smp_prepare_cpus,
+	.smp_secondary_init	= ox820_secondary_init,
+	.smp_boot_secondary	= ox820_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= ox820_cpu_die,
+#endif
+};
diff -Naur a/arch/arm/Makefile b/arch/arm/Makefile
--- a/arch/arm/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/Makefile	2015-02-11 08:26:27.000000000 -0800
@@ -182,6 +182,7 @@
 machine-$(CONFIG_ARCH_OMAP1)		+= omap1
 machine-$(CONFIG_ARCH_OMAP2PLUS)	+= omap2
 machine-$(CONFIG_ARCH_ORION5X)		+= orion5x
+machine-$(CONFIG_ARCH_OXNAS)		+= oxnas
 machine-$(CONFIG_ARCH_PICOXCELL)	+= picoxcell
 machine-$(CONFIG_ARCH_PXA)		+= pxa
 machine-$(CONFIG_ARCH_QCOM)		+= qcom
diff -Naur a/arch/arm/mm/flush.c b/arch/arm/mm/flush.c
--- a/arch/arm/mm/flush.c	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/mm/flush.c	2015-02-11 08:26:27.000000000 -0800
@@ -314,7 +314,11 @@
 
 	mapping = page_mapping(page);
 
+#ifndef CONFIG_DMA_CACHE_FIQ_BROADCAST
 	if (!cache_ops_need_broadcast() &&
+#else
+	if (
+#endif
 	    mapping && !page_mapped(page))
 		clear_bit(PG_dcache_clean, &page->flags);
 	else {
diff -Naur a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
--- a/arch/arm/mm/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/mm/Kconfig	2015-02-11 08:26:27.000000000 -0800
@@ -844,6 +844,17 @@
 	  in hardware, other workarounds are needed (e.g. cache
 	  maintenance broadcasting in software via FIQ).
 
+config DMA_CACHE_FIQ_BROADCAST
+	bool "Enable fiq broadcast DMA cache maintenance"
+	depends on CPU_V6K && SMP
+	select FIQ
+	help
+	  The Snoop Control Unit on ARM11MPCore does not detect the
+	  cache maintenance operations and the dma_{map,unmap}_area()
+	  functions may leave stale cache entries on other CPUs. By
+	  enabling this option, fiq broadcast in the ARMv6
+	  DMA cache maintenance functions is performed.
+
 config OUTER_CACHE
 	bool
 
diff -Naur a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
--- a/arch/arm/tools/mach-types	2015-01-29 17:41:03.000000000 -0800
+++ b/arch/arm/tools/mach-types	2015-02-11 08:26:27.000000000 -0800
@@ -228,6 +228,7 @@
 edb9307a		MACH_EDB9307A		EDB9307A		1128
 omap_3430sdp		MACH_OMAP_3430SDP	OMAP_3430SDP		1138
 vstms			MACH_VSTMS		VSTMS			1140
+ox820			MACH_OX820		OX820			1152
 micro9m			MACH_MICRO9M		MICRO9M			1169
 bug			MACH_BUG		BUG			1179
 at91sam9263ek		MACH_AT91SAM9263EK	AT91SAM9263EK		1202
diff -Naur a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
--- a/drivers/acpi/sleep.c	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/acpi/sleep.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,870 +0,0 @@
-/*
- * sleep.c - ACPI sleep support.
- *
- * Copyright (c) 2005 Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
- * Copyright (c) 2004 David Shaohua Li <shaohua.li@intel.com>
- * Copyright (c) 2000-2003 Patrick Mochel
- * Copyright (c) 2003 Open Source Development Lab
- *
- * This file is released under the GPLv2.
- *
- */
-
-#include <linux/delay.h>
-#include <linux/irq.h>
-#include <linux/dmi.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/suspend.h>
-#include <linux/reboot.h>
-#include <linux/acpi.h>
-#include <linux/module.h>
-#include <asm/io.h>
-#include <trace/events/power.h>
-
-#include "internal.h"
-#include "sleep.h"
-
-static u8 sleep_states[ACPI_S_STATE_COUNT];
-
-static void acpi_sleep_tts_switch(u32 acpi_state)
-{
-	acpi_status status;
-
-	status = acpi_execute_simple_method(NULL, "\\_TTS", acpi_state);
-	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
-		/*
-		 * OS can't evaluate the _TTS object correctly. Some warning
-		 * message will be printed. But it won't break anything.
-		 */
-		printk(KERN_NOTICE "Failure in evaluating _TTS object\n");
-	}
-}
-
-static int tts_notify_reboot(struct notifier_block *this,
-			unsigned long code, void *x)
-{
-	acpi_sleep_tts_switch(ACPI_STATE_S5);
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block tts_notifier = {
-	.notifier_call	= tts_notify_reboot,
-	.next		= NULL,
-	.priority	= 0,
-};
-
-static int acpi_sleep_prepare(u32 acpi_state)
-{
-#ifdef CONFIG_ACPI_SLEEP
-	/* do we have a wakeup address for S2 and S3? */
-	if (acpi_state == ACPI_STATE_S3) {
-		if (!acpi_wakeup_address)
-			return -EFAULT;
-		acpi_set_firmware_waking_vector(acpi_wakeup_address);
-
-	}
-	ACPI_FLUSH_CPU_CACHE();
-#endif
-	printk(KERN_INFO PREFIX "Preparing to enter system sleep state S%d\n",
-		acpi_state);
-	acpi_enable_wakeup_devices(acpi_state);
-	acpi_enter_sleep_state_prep(acpi_state);
-	return 0;
-}
-
-static bool acpi_sleep_state_supported(u8 sleep_state)
-{
-	acpi_status status;
-	u8 type_a, type_b;
-
-	status = acpi_get_sleep_type_data(sleep_state, &type_a, &type_b);
-	return ACPI_SUCCESS(status) && (!acpi_gbl_reduced_hardware
-		|| (acpi_gbl_FADT.sleep_control.address
-			&& acpi_gbl_FADT.sleep_status.address));
-}
-
-#ifdef CONFIG_ACPI_SLEEP
-static u32 acpi_target_sleep_state = ACPI_STATE_S0;
-
-u32 acpi_target_system_state(void)
-{
-	return acpi_target_sleep_state;
-}
-EXPORT_SYMBOL_GPL(acpi_target_system_state);
-
-static bool pwr_btn_event_pending;
-
-/*
- * The ACPI specification wants us to save NVS memory regions during hibernation
- * and to restore them during the subsequent resume.  Windows does that also for
- * suspend to RAM.  However, it is known that this mechanism does not work on
- * all machines, so we allow the user to disable it with the help of the
- * 'acpi_sleep=nonvs' kernel command line option.
- */
-static bool nvs_nosave;
-
-void __init acpi_nvs_nosave(void)
-{
-	nvs_nosave = true;
-}
-
-/*
- * The ACPI specification wants us to save NVS memory regions during hibernation
- * but says nothing about saving NVS during S3.  Not all versions of Windows
- * save NVS on S3 suspend either, and it is clear that not all systems need
- * NVS to be saved at S3 time.  To improve suspend/resume time, allow the
- * user to disable saving NVS on S3 if their system does not require it, but
- * continue to save/restore NVS for S4 as specified.
- */
-static bool nvs_nosave_s3;
-
-void __init acpi_nvs_nosave_s3(void)
-{
-	nvs_nosave_s3 = true;
-}
-
-/*
- * ACPI 1.0 wants us to execute _PTS before suspending devices, so we allow the
- * user to request that behavior by using the 'acpi_old_suspend_ordering'
- * kernel command line option that causes the following variable to be set.
- */
-static bool old_suspend_ordering;
-
-void __init acpi_old_suspend_ordering(void)
-{
-	old_suspend_ordering = true;
-}
-
-static int __init init_old_suspend_ordering(const struct dmi_system_id *d)
-{
-	acpi_old_suspend_ordering();
-	return 0;
-}
-
-static int __init init_nvs_nosave(const struct dmi_system_id *d)
-{
-	acpi_nvs_nosave();
-	return 0;
-}
-
-static struct dmi_system_id acpisleep_dmi_table[] __initdata = {
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Abit KN9 (nForce4 variant)",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "http://www.abit.com.tw/"),
-		DMI_MATCH(DMI_BOARD_NAME, "KN9 Series(NF-CK804)"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "HP xw4600 Workstation",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "HP xw4600 Workstation"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Asus Pundit P1-AH2 (M2N8L motherboard)",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTek Computer INC."),
-		DMI_MATCH(DMI_BOARD_NAME, "M2N8L"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Panasonic CF51-2L",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR,
-				"Matsushita Electric Industrial Co.,Ltd."),
-		DMI_MATCH(DMI_BOARD_NAME, "CF51-2L"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-FW41E_H",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW41E_H"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-FW21E",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW21E"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-FW21M",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW21M"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCEB17FX",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB17FX"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-SR11M",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR11M"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Everex StepNote Series",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Everex Systems, Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "Everex StepNote Series"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCEB1Z1E",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1Z1E"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-NW130D",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-NW130D"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCCW29FX",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCCW29FX"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Averatec AV1020-ED2",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "AVERATEC"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "1000 Series"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Asus A8N-SLI DELUXE",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
-		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI DELUXE"),
-		},
-	},
-	{
-	.callback = init_old_suspend_ordering,
-	.ident = "Asus A8N-SLI Premium",
-	.matches = {
-		DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
-		DMI_MATCH(DMI_BOARD_NAME, "A8N-SLI Premium"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-SR26GN_P",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-SR26GN_P"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VPCEB1S1E",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VPCEB1S1E"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Sony Vaio VGN-FW520F",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
-		DMI_MATCH(DMI_PRODUCT_NAME, "VGN-FW520F"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Asus K54C",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "K54C"),
-		},
-	},
-	{
-	.callback = init_nvs_nosave,
-	.ident = "Asus K54HR",
-	.matches = {
-		DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
-		DMI_MATCH(DMI_PRODUCT_NAME, "K54HR"),
-		},
-	},
-	{},
-};
-
-static void acpi_sleep_dmi_check(void)
-{
-	int year;
-
-	if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year >= 2012)
-		acpi_nvs_nosave_s3();
-
-	dmi_check_system(acpisleep_dmi_table);
-}
-
-/**
- * acpi_pm_freeze - Disable the GPEs and suspend EC transactions.
- */
-static int acpi_pm_freeze(void)
-{
-	acpi_disable_all_gpes();
-	acpi_os_wait_events_complete();
-	acpi_ec_block_transactions();
-	return 0;
-}
-
-/**
- * acpi_pre_suspend - Enable wakeup devices, "freeze" EC and save NVS.
- */
-static int acpi_pm_pre_suspend(void)
-{
-	acpi_pm_freeze();
-	return suspend_nvs_save();
-}
-
-/**
- *	__acpi_pm_prepare - Prepare the platform to enter the target state.
- *
- *	If necessary, set the firmware waking vector and do arch-specific
- *	nastiness to get the wakeup code to the waking vector.
- */
-static int __acpi_pm_prepare(void)
-{
-	int error = acpi_sleep_prepare(acpi_target_sleep_state);
-	if (error)
-		acpi_target_sleep_state = ACPI_STATE_S0;
-
-	return error;
-}
-
-/**
- *	acpi_pm_prepare - Prepare the platform to enter the target sleep
- *		state and disable the GPEs.
- */
-static int acpi_pm_prepare(void)
-{
-	int error = __acpi_pm_prepare();
-	if (!error)
-		error = acpi_pm_pre_suspend();
-
-	return error;
-}
-
-static int find_powerf_dev(struct device *dev, void *data)
-{
-	struct acpi_device *device = to_acpi_device(dev);
-	const char *hid = acpi_device_hid(device);
-
-	return !strcmp(hid, ACPI_BUTTON_HID_POWERF);
-}
-
-/**
- *	acpi_pm_finish - Instruct the platform to leave a sleep state.
- *
- *	This is called after we wake back up (or if entering the sleep state
- *	failed).
- */
-static void acpi_pm_finish(void)
-{
-	struct device *pwr_btn_dev;
-	u32 acpi_state = acpi_target_sleep_state;
-
-	acpi_ec_unblock_transactions();
-	suspend_nvs_free();
-
-	if (acpi_state == ACPI_STATE_S0)
-		return;
-
-	printk(KERN_INFO PREFIX "Waking up from system sleep state S%d\n",
-		acpi_state);
-	acpi_disable_wakeup_devices(acpi_state);
-	acpi_leave_sleep_state(acpi_state);
-
-	/* reset firmware waking vector */
-	acpi_set_firmware_waking_vector((acpi_physical_address) 0);
-
-	acpi_target_sleep_state = ACPI_STATE_S0;
-
-	acpi_resume_power_resources();
-
-	/* If we were woken with the fixed power button, provide a small
-	 * hint to userspace in the form of a wakeup event on the fixed power
-	 * button device (if it can be found).
-	 *
-	 * We delay the event generation til now, as the PM layer requires
-	 * timekeeping to be running before we generate events. */
-	if (!pwr_btn_event_pending)
-		return;
-
-	pwr_btn_event_pending = false;
-	pwr_btn_dev = bus_find_device(&acpi_bus_type, NULL, NULL,
-				      find_powerf_dev);
-	if (pwr_btn_dev) {
-		pm_wakeup_event(pwr_btn_dev, 0);
-		put_device(pwr_btn_dev);
-	}
-}
-
-/**
- * acpi_pm_start - Start system PM transition.
- */
-static void acpi_pm_start(u32 acpi_state)
-{
-	acpi_target_sleep_state = acpi_state;
-	acpi_sleep_tts_switch(acpi_target_sleep_state);
-	acpi_scan_lock_acquire();
-}
-
-/**
- * acpi_pm_end - Finish up system PM transition.
- */
-static void acpi_pm_end(void)
-{
-	acpi_scan_lock_release();
-	/*
-	 * This is necessary in case acpi_pm_finish() is not called during a
-	 * failing transition to a sleep state.
-	 */
-	acpi_target_sleep_state = ACPI_STATE_S0;
-	acpi_sleep_tts_switch(acpi_target_sleep_state);
-}
-#else /* !CONFIG_ACPI_SLEEP */
-#define acpi_target_sleep_state	ACPI_STATE_S0
-static inline void acpi_sleep_dmi_check(void) {}
-#endif /* CONFIG_ACPI_SLEEP */
-
-#ifdef CONFIG_SUSPEND
-static u32 acpi_suspend_states[] = {
-	[PM_SUSPEND_ON] = ACPI_STATE_S0,
-	[PM_SUSPEND_STANDBY] = ACPI_STATE_S1,
-	[PM_SUSPEND_MEM] = ACPI_STATE_S3,
-	[PM_SUSPEND_MAX] = ACPI_STATE_S5
-};
-
-/**
- *	acpi_suspend_begin - Set the target system sleep state to the state
- *		associated with given @pm_state, if supported.
- */
-static int acpi_suspend_begin(suspend_state_t pm_state)
-{
-	u32 acpi_state = acpi_suspend_states[pm_state];
-	int error;
-
-	error = (nvs_nosave || nvs_nosave_s3) ? 0 : suspend_nvs_alloc();
-	if (error)
-		return error;
-
-	if (!sleep_states[acpi_state]) {
-		pr_err("ACPI does not support sleep state S%u\n", acpi_state);
-		return -ENOSYS;
-	}
-
-	acpi_pm_start(acpi_state);
-	return 0;
-}
-
-/**
- *	acpi_suspend_enter - Actually enter a sleep state.
- *	@pm_state: ignored
- *
- *	Flush caches and go to sleep. For STR we have to call arch-specific
- *	assembly, which in turn call acpi_enter_sleep_state().
- *	It's unfortunate, but it works. Please fix if you're feeling frisky.
- */
-static int acpi_suspend_enter(suspend_state_t pm_state)
-{
-	acpi_status status = AE_OK;
-	u32 acpi_state = acpi_target_sleep_state;
-	int error;
-
-	ACPI_FLUSH_CPU_CACHE();
-
-	trace_suspend_resume(TPS("acpi_suspend"), acpi_state, true);
-	switch (acpi_state) {
-	case ACPI_STATE_S1:
-		barrier();
-		status = acpi_enter_sleep_state(acpi_state);
-		break;
-
-	case ACPI_STATE_S3:
-		if (!acpi_suspend_lowlevel)
-			return -ENOSYS;
-		error = acpi_suspend_lowlevel();
-		if (error)
-			return error;
-		pr_info(PREFIX "Low-level resume complete\n");
-		break;
-	}
-	trace_suspend_resume(TPS("acpi_suspend"), acpi_state, false);
-
-	/* This violates the spec but is required for bug compatibility. */
-	acpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);
-
-	/* Reprogram control registers */
-	acpi_leave_sleep_state_prep(acpi_state);
-
-	/* ACPI 3.0 specs (P62) says that it's the responsibility
-	 * of the OSPM to clear the status bit [ implying that the
-	 * POWER_BUTTON event should not reach userspace ]
-	 *
-	 * However, we do generate a small hint for userspace in the form of
-	 * a wakeup event. We flag this condition for now and generate the
-	 * event later, as we're currently too early in resume to be able to
-	 * generate wakeup events.
-	 */
-	if (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3)) {
-		acpi_event_status pwr_btn_status = ACPI_EVENT_FLAG_DISABLED;
-
-		acpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);
-
-		if (pwr_btn_status & ACPI_EVENT_FLAG_SET) {
-			acpi_clear_event(ACPI_EVENT_POWER_BUTTON);
-			/* Flag for later */
-			pwr_btn_event_pending = true;
-		}
-	}
-
-	/*
-	 * Disable and clear GPE status before interrupt is enabled. Some GPEs
-	 * (like wakeup GPE) haven't handler, this can avoid such GPE misfire.
-	 * acpi_leave_sleep_state will reenable specific GPEs later
-	 */
-	acpi_disable_all_gpes();
-	/* Allow EC transactions to happen. */
-	acpi_ec_unblock_transactions_early();
-
-	suspend_nvs_restore();
-
-	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
-}
-
-static int acpi_suspend_state_valid(suspend_state_t pm_state)
-{
-	u32 acpi_state;
-
-	switch (pm_state) {
-	case PM_SUSPEND_ON:
-	case PM_SUSPEND_STANDBY:
-	case PM_SUSPEND_MEM:
-		acpi_state = acpi_suspend_states[pm_state];
-
-		return sleep_states[acpi_state];
-	default:
-		return 0;
-	}
-}
-
-static const struct platform_suspend_ops acpi_suspend_ops = {
-	.valid = acpi_suspend_state_valid,
-	.begin = acpi_suspend_begin,
-	.prepare_late = acpi_pm_prepare,
-	.enter = acpi_suspend_enter,
-	.wake = acpi_pm_finish,
-	.end = acpi_pm_end,
-};
-
-/**
- *	acpi_suspend_begin_old - Set the target system sleep state to the
- *		state associated with given @pm_state, if supported, and
- *		execute the _PTS control method.  This function is used if the
- *		pre-ACPI 2.0 suspend ordering has been requested.
- */
-static int acpi_suspend_begin_old(suspend_state_t pm_state)
-{
-	int error = acpi_suspend_begin(pm_state);
-	if (!error)
-		error = __acpi_pm_prepare();
-
-	return error;
-}
-
-/*
- * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
- * been requested.
- */
-static const struct platform_suspend_ops acpi_suspend_ops_old = {
-	.valid = acpi_suspend_state_valid,
-	.begin = acpi_suspend_begin_old,
-	.prepare_late = acpi_pm_pre_suspend,
-	.enter = acpi_suspend_enter,
-	.wake = acpi_pm_finish,
-	.end = acpi_pm_end,
-	.recover = acpi_pm_finish,
-};
-
-static int acpi_freeze_begin(void)
-{
-	acpi_scan_lock_acquire();
-	return 0;
-}
-
-static int acpi_freeze_prepare(void)
-{
-	acpi_enable_all_wakeup_gpes();
-	enable_irq_wake(acpi_gbl_FADT.sci_interrupt);
-	return 0;
-}
-
-static void acpi_freeze_restore(void)
-{
-	disable_irq_wake(acpi_gbl_FADT.sci_interrupt);
-	acpi_enable_all_runtime_gpes();
-}
-
-static void acpi_freeze_end(void)
-{
-	acpi_scan_lock_release();
-}
-
-static const struct platform_freeze_ops acpi_freeze_ops = {
-	.begin = acpi_freeze_begin,
-	.prepare = acpi_freeze_prepare,
-	.restore = acpi_freeze_restore,
-	.end = acpi_freeze_end,
-};
-
-static void acpi_sleep_suspend_setup(void)
-{
-	int i;
-
-	for (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++)
-		if (acpi_sleep_state_supported(i))
-			sleep_states[i] = 1;
-
-	suspend_set_ops(old_suspend_ordering ?
-		&acpi_suspend_ops_old : &acpi_suspend_ops);
-	freeze_set_ops(&acpi_freeze_ops);
-}
-
-#else /* !CONFIG_SUSPEND */
-static inline void acpi_sleep_suspend_setup(void) {}
-#endif /* !CONFIG_SUSPEND */
-
-#ifdef CONFIG_HIBERNATION
-static unsigned long s4_hardware_signature;
-static struct acpi_table_facs *facs;
-static bool nosigcheck;
-
-void __init acpi_no_s4_hw_signature(void)
-{
-	nosigcheck = true;
-}
-
-static int acpi_hibernation_begin(void)
-{
-	int error;
-
-	error = nvs_nosave ? 0 : suspend_nvs_alloc();
-	if (!error)
-		acpi_pm_start(ACPI_STATE_S4);
-
-	return error;
-}
-
-static int acpi_hibernation_enter(void)
-{
-	acpi_status status = AE_OK;
-
-	ACPI_FLUSH_CPU_CACHE();
-
-	/* This shouldn't return.  If it returns, we have a problem */
-	status = acpi_enter_sleep_state(ACPI_STATE_S4);
-	/* Reprogram control registers */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
-
-	return ACPI_SUCCESS(status) ? 0 : -EFAULT;
-}
-
-static void acpi_hibernation_leave(void)
-{
-	/*
-	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to
-	 * enable it here.
-	 */
-	acpi_enable();
-	/* Reprogram control registers */
-	acpi_leave_sleep_state_prep(ACPI_STATE_S4);
-	/* Check the hardware signature */
-	if (facs && s4_hardware_signature != facs->hardware_signature)
-		pr_crit("ACPI: Hardware changed while hibernated, success doubtful!\n");
-	/* Restore the NVS memory area */
-	suspend_nvs_restore();
-	/* Allow EC transactions to happen. */
-	acpi_ec_unblock_transactions_early();
-}
-
-static void acpi_pm_thaw(void)
-{
-	acpi_ec_unblock_transactions();
-	acpi_enable_all_runtime_gpes();
-}
-
-static const struct platform_hibernation_ops acpi_hibernation_ops = {
-	.begin = acpi_hibernation_begin,
-	.end = acpi_pm_end,
-	.pre_snapshot = acpi_pm_prepare,
-	.finish = acpi_pm_finish,
-	.prepare = acpi_pm_prepare,
-	.enter = acpi_hibernation_enter,
-	.leave = acpi_hibernation_leave,
-	.pre_restore = acpi_pm_freeze,
-	.restore_cleanup = acpi_pm_thaw,
-};
-
-/**
- *	acpi_hibernation_begin_old - Set the target system sleep state to
- *		ACPI_STATE_S4 and execute the _PTS control method.  This
- *		function is used if the pre-ACPI 2.0 suspend ordering has been
- *		requested.
- */
-static int acpi_hibernation_begin_old(void)
-{
-	int error;
-	/*
-	 * The _TTS object should always be evaluated before the _PTS object.
-	 * When the old_suspended_ordering is true, the _PTS object is
-	 * evaluated in the acpi_sleep_prepare.
-	 */
-	acpi_sleep_tts_switch(ACPI_STATE_S4);
-
-	error = acpi_sleep_prepare(ACPI_STATE_S4);
-
-	if (!error) {
-		if (!nvs_nosave)
-			error = suspend_nvs_alloc();
-		if (!error) {
-			acpi_target_sleep_state = ACPI_STATE_S4;
-			acpi_scan_lock_acquire();
-		}
-	}
-	return error;
-}
-
-/*
- * The following callbacks are used if the pre-ACPI 2.0 suspend ordering has
- * been requested.
- */
-static const struct platform_hibernation_ops acpi_hibernation_ops_old = {
-	.begin = acpi_hibernation_begin_old,
-	.end = acpi_pm_end,
-	.pre_snapshot = acpi_pm_pre_suspend,
-	.prepare = acpi_pm_freeze,
-	.finish = acpi_pm_finish,
-	.enter = acpi_hibernation_enter,
-	.leave = acpi_hibernation_leave,
-	.pre_restore = acpi_pm_freeze,
-	.restore_cleanup = acpi_pm_thaw,
-	.recover = acpi_pm_finish,
-};
-
-static void acpi_sleep_hibernate_setup(void)
-{
-	if (!acpi_sleep_state_supported(ACPI_STATE_S4))
-		return;
-
-	hibernation_set_ops(old_suspend_ordering ?
-			&acpi_hibernation_ops_old : &acpi_hibernation_ops);
-	sleep_states[ACPI_STATE_S4] = 1;
-	if (nosigcheck)
-		return;
-
-	acpi_get_table(ACPI_SIG_FACS, 1, (struct acpi_table_header **)&facs);
-	if (facs)
-		s4_hardware_signature = facs->hardware_signature;
-}
-#else /* !CONFIG_HIBERNATION */
-static inline void acpi_sleep_hibernate_setup(void) {}
-#endif /* !CONFIG_HIBERNATION */
-
-int acpi_suspend(u32 acpi_state)
-{
-	suspend_state_t states[] = {
-		[1] = PM_SUSPEND_STANDBY,
-		[3] = PM_SUSPEND_MEM,
-		[5] = PM_SUSPEND_MAX
-	};
-
-	if (acpi_state < 6 && states[acpi_state])
-		return pm_suspend(states[acpi_state]);
-	if (acpi_state == 4)
-		return hibernate();
-	return -EINVAL;
-}
-
-static void acpi_power_off_prepare(void)
-{
-	/* Prepare to power off the system */
-	acpi_sleep_prepare(ACPI_STATE_S5);
-	acpi_disable_all_gpes();
-}
-
-static void acpi_power_off(void)
-{
-	/* acpi_sleep_prepare(ACPI_STATE_S5) should have already been called */
-	printk(KERN_DEBUG "%s called\n", __func__);
-	local_irq_disable();
-	acpi_enter_sleep_state(ACPI_STATE_S5);
-}
-
-int __init acpi_sleep_init(void)
-{
-	char supported[ACPI_S_STATE_COUNT * 3 + 1];
-	char *pos = supported;
-	int i;
-
-	acpi_sleep_dmi_check();
-
-	sleep_states[ACPI_STATE_S0] = 1;
-
-	acpi_sleep_suspend_setup();
-	acpi_sleep_hibernate_setup();
-
-	if (acpi_sleep_state_supported(ACPI_STATE_S5)) {
-		sleep_states[ACPI_STATE_S5] = 1;
-		pm_power_off_prepare = acpi_power_off_prepare;
-		pm_power_off = acpi_power_off;
-	}
-
-	supported[0] = 0;
-	for (i = 0; i < ACPI_S_STATE_COUNT; i++) {
-		if (sleep_states[i])
-			pos += sprintf(pos, " S%d", i);
-	}
-	pr_info(PREFIX "(supports%s)\n", supported);
-
-	/*
-	 * Register the tts_notifier to reboot notifier list so that the _TTS
-	 * object can also be evaluated when the system enters S5.
-	 */
-	register_reboot_notifier(&tts_notifier);
-	return 0;
-}
diff -Naur a/drivers/ata/Kconfig b/drivers/ata/Kconfig
--- a/drivers/ata/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/ata/Kconfig	2015-02-11 08:27:03.000000000 -0800
@@ -385,6 +385,13 @@
 
 	  If unsure, say N.
 
+config SATA_OXNAS
+	tristate "PLXTECH NAS782X SATA support"
+	help
+	  This option enables support for Nas782x Serial ATA controller.
+
+	  If unsure, say N.
+
 comment "PATA SFF controllers with BMDMA"
 
 config PATA_ALI
diff -Naur a/drivers/ata/Makefile b/drivers/ata/Makefile
--- a/drivers/ata/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/ata/Makefile	2015-02-11 08:27:03.000000000 -0800
@@ -37,6 +37,7 @@
 obj-$(CONFIG_SATA_ULI)		+= sata_uli.o
 obj-$(CONFIG_SATA_VIA)		+= sata_via.o
 obj-$(CONFIG_SATA_VITESSE)	+= sata_vsc.o
+obj-$(CONFIG_SATA_OXNAS)	+= sata_oxnas.o
 
 # SFF PATA w/ BMDMA
 obj-$(CONFIG_PATA_ALI)		+= pata_ali.o
diff -Naur a/drivers/ata/sata_oxnas.c b/drivers/ata/sata_oxnas.c
--- a/drivers/ata/sata_oxnas.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/ata/sata_oxnas.c	2015-02-11 08:27:03.000000000 -0800
@@ -0,0 +1,1877 @@
+#include <linux/ata.h>
+#include <linux/libata.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+
+#include <mach/utils.h>
+
+/* sgdma requst structure */
+typedef struct {
+	volatile u32 qualifier;
+	volatile u32 control;
+	dma_addr_t src_pa;
+	dma_addr_t dst_pa;
+} __attribute ((aligned(4),packed)) sgdma_request_t;
+
+
+/* Controller information */
+enum {
+	//SATA_OXNAS_MAX_PRD	= 63,
+	//SATA_OXNAS_MAX_PRD_USABLE	= SATA_OXNAS_MAX_PRD - 1,
+	SATA_OXNAS_MAX_PRD = 254,
+	SATA_OXNAS_DMA_SIZE = SATA_OXNAS_MAX_PRD * sizeof(struct ata_bmdma_prd) +
+							sizeof(sgdma_request_t),
+	SATA_OXNAS_MAX_PORTS	= 1,
+	/** The different Oxsemi SATA core version numbers */
+	SATA_OXNAS_CORE_VERSION = 0x1f3,
+	SATA_OXNAS_IRQ_FLAG	= IRQF_SHARED,
+	SATA_OXNAS_HOST_FLAGS	= (ATA_FLAG_SATA | ATA_FLAG_PIO_DMA |
+			ATA_FLAG_NO_ATAPI /*| ATA_FLAG_NCQ*/),
+	SATA_OXNAS_QUEUE_DEPTH	= 32,
+
+	SATA_OXNAS_DMA_BOUNDARY = 0xFFFFFFFF,
+};
+
+
+/*
+ * SATA Port Registers
+ */
+enum {
+	/** sata host port register offsets */
+	ORB1 = 0x00,
+	ORB2 = 0x04,
+	ORB3 = 0x08,
+	ORB4 = 0x0C,
+	ORB5 = 0x10,
+	MASTER_STATUS = 0x10,
+	FIS_CTRL = 0x18,
+	FIS_DATA = 0x1C,
+	INT_STATUS = 0x30,
+	INT_CLEAR = 0x30,
+	INT_ENABLE = 0x34,
+	INT_DISABLE = 0x38,
+	VERSION = 0x3C,
+	SATA_CONTROL = 0x5C,
+	SATA_COMMAND = 0x60,
+	HID_FEATURES = 0x64,
+	PORT_CONTROL = 0x68,
+	DRIVE_CONTROL = 0x6C,
+	/** These registers allow access to the link layer registers
+	that reside in a different clock domain to the processor bus */
+	LINK_DATA = 0x70,
+	LINK_RD_ADDR = 0x74,
+	LINK_WR_ADDR = 0x78,
+	LINK_CONTROL = 0x7C,
+	/* window control */
+	WIN1LO = 0x80,
+	WIN1HI = 0x84,
+	WIN2LO = 0x88,
+	WIN2HI = 0x8C,
+	WIN0_CONTROL = 0x90,
+
+};
+
+/** sata port register bits */
+enum{
+	/**,
+	 * commands to issue in the master status to tell it to move shadow ,
+	 * registers to the actual device ,
+	 */
+	SATA_OPCODE_MASK = 0x00000007,
+	CMD_WRITE_TO_ORB_REGS_NO_COMMAND = 0x4,
+	CMD_WRITE_TO_ORB_REGS = 0x2,
+	CMD_SYNC_ESCAPE = 0x7,
+	CMD_CORE_BUSY = (1 << 7),
+	CMD_DRIVE_SELECT_SHIFT = 12,
+	CMD_DRIVE_SELECT_MASK = (0xf << CMD_DRIVE_SELECT_SHIFT),
+
+	/** interrupt bits */
+	INT_END_OF_CMD = 1 << 0,
+	INT_LINK_SERROR = 1 << 1,
+	INT_ERROR = 1 << 2,
+	INT_LINK_IRQ = 1 << 3,
+	INT_REG_ACCESS_ERR = 1 << 7,
+	INT_BIST_FIS  = 1 << 11,
+	INT_MASKABLE = INT_END_OF_CMD| INT_LINK_SERROR|INT_ERROR |INT_LINK_IRQ |
+					INT_REG_ACCESS_ERR | INT_BIST_FIS,
+	INT_WANT  = INT_END_OF_CMD  |INT_LINK_SERROR |INT_REG_ACCESS_ERR |INT_ERROR ,
+	INT_ERRORS  = INT_LINK_SERROR | INT_REG_ACCESS_ERR |INT_ERROR,
+
+	/** raw interrupt bits, unmaskable, but do not generate interrupts */
+	RAW_END_OF_CMD  = INT_END_OF_CMD << 16,
+	RAW_LINK_SERROR = INT_LINK_SERROR  << 16,
+	RAW_ERROR  = INT_ERROR << 16,
+	RAW_LINK_IRQ  = INT_LINK_IRQ << 16,
+	RAW_REG_ACCESS_ERR = INT_REG_ACCESS_ERR << 16,
+	RAW_BIST_FIS  = INT_BIST_FIS << 16,
+	RAW_WANT  = INT_WANT << 16,
+	RAW_ERRORS  = INT_ERRORS << 16,
+
+	/**
+	 * variables to write to the device control register to set the current device,
+	 * ie, master or slave,
+	 */
+	DR_CON_48 = 2,
+	DR_CON_28 = 0,
+
+	SATA_CTL_ERR_MASK = 0x00000016,
+
+};
+
+/* ATA SGDMA register offsets */
+enum {
+	SGDMA_CONTROL = 0x0,
+	SGDMA_STATUS = 0x4,
+	SGDMA_REQUESTPTR = 0x8,
+	SGDMA_RESETS = 0xC,
+	SGDMA_CORESIZE = 0x10,
+};
+
+enum {
+	/* see DMA core docs for the values. Out means from memory (bus A) out to
+	disk (bus B) */
+	SGDMA_REQCTL0OUT = 0x0497c03d,
+	/* burst mode disabled when no micro code used */
+	SGDMA_REQCTL0IN = 0x0493a3c1,
+	SGDMA_REQCTL1OUT = 0x0497c07d,
+	SGDMA_REQCTL1IN = 0x0497a3c5,
+	SGDMA_CONTROL_NOGO = 0x3e,
+	SGDMA_CONTROL_GO = SGDMA_CONTROL_NOGO | 1,
+	SGDMA_ERRORMASK = 0x3f,
+	SGDMA_BUSY = 0x80,
+
+	SGDMA_RESETS_CTRL = 1 << 0,
+	SGDMA_RESETS_ARBT = 1 << 1,
+	SGDMA_RESETS_AHB = 1 << 2,
+	SGDMA_RESETS_ALL = SGDMA_RESETS_CTRL|
+						SGDMA_RESETS_ARBT|SGDMA_RESETS_AHB,
+
+	/* Final EOTs */
+	SGDMA_REQQUAL = 0x00220001,
+
+};
+
+/** SATA core register offsets */
+enum {
+	DM_DBG1 = 0x000,
+	RAID_SET = 0x004,
+	DM_DBG2 = 0x008,
+	DATACOUNT_PORT0 = 0x010,
+	DATACOUNT_PORT1 = 0x014,
+	CORE_INT_STATUS = 0x030,
+	CORE_INT_CLEAR = 0x030,
+	CORE_INT_ENABLE = 0x034,
+	CORE_INT_DISABLE  = 0x038,
+	CORE_REBUILD_ENABLE = 0x050,
+	CORE_FAILED_PORT_R = 0x054,
+	DEVICE_CONTROL = 0x068,
+	EXCESS = 0x06C,
+	RAID_SIZE_LOW = 0x070,
+	RAID_SIZE_HIGH = 0x074,
+	PORT_ERROR_MASK = 0x078,
+	IDLE_STATUS = 0x07C,
+	RAID_CONTROL = 0x090,
+	DATA_PLANE_CTRL = 0x0AC,
+	CORE_DATAPLANE_STAT = 0x0b8,
+	PROC_PC = 0x100,
+	CONFIG_IN = 0x3d8,
+	PROC_START = 0x3f0,
+	PROC_RESET = 0x3f4,
+	UCODE_STORE = 0x1000,
+	RAID_WP_BOT_LOW = 0x1FF0,
+	RAID_WP_BOT_HIGH  = 0x1FF4,
+	RAID_WP_TOP_LOW = 0x1FF8,
+	RAID_WP_TOP_HIGH  = 0x1FFC,
+	DATA_MUX_RAM0 = 0x8000,
+	DATA_MUX_RAM1 = 0xA000,
+};
+
+enum {
+	/* Sata core debug1 register bits */
+	CORE_PORT0_DATA_DIR_BIT = 20,
+	CORE_PORT1_DATA_DIR_BIT = 21,
+	CORE_PORT0_DATA_DIR = 1 << CORE_PORT0_DATA_DIR_BIT,
+	CORE_PORT1_DATA_DIR = 1 << CORE_PORT1_DATA_DIR_BIT,
+
+	/** sata core control register bits */
+	SCTL_CLR_ERR = 0x00003016,
+	RAID_CLR_ERR = 0x0000011e,
+
+	/* Interrupts direct from the ports */
+	NORMAL_INTS_WANTED =0x00000303,
+
+	/* shift these left by port number */
+	COREINT_HOST = 0x00000001,
+	COREINT_END = 0x00000100,
+	CORERAW_HOST = COREINT_HOST << 16,
+	CORERAW_END = COREINT_END  << 16,
+
+	/* Interrupts from the RAID controller only */
+	RAID_INTS_WANTED = 0x00008300,
+
+	/* The bits in the IDLE_STATUS that, when set indicate an idle core */
+	IDLE_CORES = (1 << 18) | (1 << 19),
+
+	/* Data plane control error-mask mask and bit, these bit in the data plane
+	control mask out errors from the ports that prevent the SGDMA care from sending
+	an interrupt */
+	DPC_ERROR_MASK = 0x00000300,
+	DPC_ERROR_MASK_BIT = 0x00000100,
+	/* enable jbod micro-code */
+	DPC_JBOD_UCODE = 1 << 0,
+	DPC_FIS_SWCH = 1 << 1,
+
+	/** Device Control register bits */
+	DEVICE_CONTROL_DMABT = 1 << 4,
+	DEVICE_CONTROL_ABORT = 1 << 2,
+	DEVICE_CONTROL_PAD = 1 << 3,
+	DEVICE_CONTROL_PADPAT = 1 << 16,
+	DEVICE_CONTROL_PRTRST = 1 << 8,
+	DEVICE_CONTROL_RAMRST = 1 << 12,
+	DEVICE_CONTROL_ATA_ERR_OVERRIDE =1 << 28,
+
+	/** oxsemi HW raid modes */
+	OXNASSATA_NOTRAID = 0,
+	OXNASSATA_RAID0 = 1,
+	OXNASSATA_RAID1 = 2,
+	/** OX820 specific HW-RAID register values */
+	RAID_TWODISKS = 3,
+	UNKNOWN_MODE = ~0,
+};
+
+/* SATA PHY Registers */
+enum {
+	PHY_STAT = 0x00,
+	PHY_DATA = 0x04,
+};
+
+enum {
+	STAT_READ_VALID = (1 << 21),
+	STAT_CR_ACK = (1 << 20),
+	STAT_CR_READ = (1 << 19),
+	STAT_CR_WRITE = (1 << 18),
+	STAT_CAP_DATA = (1 << 17),
+	STAT_CAP_ADDR = (1 << 16),
+
+	STAT_ACK_ANY = (STAT_CR_ACK|STAT_CR_READ|STAT_CR_WRITE|
+						STAT_CAP_DATA|STAT_CAP_ADDR),
+
+	CR_READ_ENABLE = (1<<16),
+	CR_WRITE_ENABLE = (1<<17),
+	CR_CAP_DATA = (1<<18),
+};
+
+enum {
+	/* Link layer registers */
+	SERROR_IRQ_MASK = 5,
+};
+
+typedef enum {
+    OXNAS_SATA_SOFTRESET = 1,
+    OXNAS_SATA_REINIT = 2,
+} cleanup_recovery_t;
+
+enum {
+		OXNAS_SATA_UCODE_RAID0,
+		OXNAS_SATA_UCODE_RAID1,
+		OXNAS_SATA_UCODE_JBOD,
+		OXNAS_SATA_UCODE_NONE,
+};
+
+struct sata_oxnas_host_priv {
+	void __iomem *port_base[SATA_OXNAS_MAX_PORTS];
+	void __iomem *sgdma_base[SATA_OXNAS_MAX_PORTS];
+	void __iomem *core_base;
+	void __iomem *phy_base;
+	dma_addr_t dma_base;
+	void __iomem *dma_base_va;
+	size_t dma_size;
+	int irq;
+	u32 port_in_eh;
+	struct clk *clk;
+	struct reset_control *rst_sata;
+	struct reset_control *rst_link;
+	struct reset_control *rst_phy;
+};
+
+
+struct sata_oxnas_port_priv {
+	void __iomem *port_base;
+	void __iomem *sgdma_base;
+	void __iomem *core_base;
+	sgdma_request_t *sgdma_request;
+	dma_addr_t sgdma_request_pa;
+
+};
+
+static u8 sata_oxnas_check_status(struct ata_port *ap);
+cleanup_recovery_t sata_oxnas_cleanup(struct ata_host* ah);
+static void sata_oxnas_tf_load(struct ata_port *ap, const struct ata_taskfile *tf);
+static void sata_oxnas_irq_on(struct ata_port *ap);
+static void sata_oxnas_post_reset_init(struct ata_port* ap);
+
+/* ??????????????????????????????????? */
+static void wait_cr_ack(void __iomem *phy_base){
+	while ((ioread32(phy_base + PHY_STAT) >> 16) & 0x1f)
+		/* wait for an ack bit to be set */ ;
+}
+
+static u16 read_cr(void __iomem *phy_base, u16 address)
+{
+	iowrite32((u32)address, phy_base + PHY_STAT);
+	wait_cr_ack(phy_base);
+	iowrite32(CR_READ_ENABLE, phy_base + PHY_DATA);
+	wait_cr_ack(phy_base);
+	return (u16)ioread32(phy_base + PHY_STAT);
+}
+
+static void write_cr(void __iomem *phy_base, u16 data, u16 address)
+{
+	iowrite32((u32)address, phy_base + PHY_STAT);
+	wait_cr_ack(phy_base);
+	iowrite32((data | CR_CAP_DATA), phy_base + PHY_DATA);
+	wait_cr_ack(phy_base);
+	iowrite32(CR_WRITE_ENABLE, phy_base + PHY_DATA);
+	wait_cr_ack(phy_base);
+}
+
+#define PH_GAIN		 2
+#define FR_GAIN		 3
+#define PH_GAIN_OFFSET  6
+#define FR_GAIN_OFFSET  8
+#define PH_GAIN_MASK  (0x3 << PH_GAIN_OFFSET)
+#define FR_GAIN_MASK  (0x3 << FR_GAIN_OFFSET)
+#define USE_INT_SETTING  (1<<5)
+
+void workaround5458(struct ata_host *ah){
+	struct sata_oxnas_host_priv *hd = ah->private_data;
+	void __iomem *phy_base = hd->phy_base;
+	unsigned i;
+
+	for (i=0; i<2;i++){
+		u16 rx_control = read_cr(phy_base, 0x201d + (i<<8));
+		rx_control &= ~(PH_GAIN_MASK | FR_GAIN_MASK);
+		rx_control |= PH_GAIN << PH_GAIN_OFFSET;
+		rx_control |= (FR_GAIN << FR_GAIN_OFFSET) | USE_INT_SETTING ;
+		write_cr(phy_base, rx_control, 0x201d+(i<<8));
+	}
+}
+
+/**
+ * allows access to the link layer registers
+ * @param link_reg the link layer register to access (oxsemi indexing ie
+ *		00 = static config, 04 = phy ctrl)
+ */
+void sata_oxnas_link_write(struct ata_port *ap, unsigned int link_reg, u32 val)
+{
+	struct sata_oxnas_port_priv *port_priv = ap->private_data;
+	void __iomem *port_base = port_priv->port_base;
+	u32 patience;
+
+	DPRINTK("[0x%02x]->0x%08x\n", link_reg, val);
+
+	iowrite32(val, port_base + LINK_DATA);
+
+	/* accessed twice as a work around for a bug in the SATA abp bridge
+	 * hardware (bug 6828) */
+	iowrite32(link_reg , port_base + LINK_WR_ADDR);
+	ioread32(port_base + LINK_WR_ADDR);
+
+	for (patience = 0x100000; patience > 0;--patience) {
+		if (ioread32(port_base + LINK_CONTROL) & 0x00000001) {
+			break;
+		}
+	}
+}
+
+static int sata_oxnas_scr_write_port(struct ata_port *ap, unsigned int sc_reg, u32 val)
+{
+	sata_oxnas_link_write(ap, 0x20 + (sc_reg * 4), val);
+	return 0;
+}
+
+static int sata_oxnas_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)
+{
+	return sata_oxnas_scr_write_port(link->ap, sc_reg, val);
+}
+
+/* FIXME lock */
+u32 sata_oxnas_link_read(struct ata_port *ap, unsigned int link_reg)
+{
+	struct sata_oxnas_port_priv *pd = ap->private_data;
+	void __iomem *port_base = pd->port_base;
+	u32 result;
+	u32 patience;
+
+	/* accessed twice as a work around for a bug in the SATA abp bridge
+	 * hardware (bug 6828) */
+	iowrite32(link_reg, port_base + LINK_RD_ADDR);
+	ioread32(port_base + LINK_RD_ADDR);
+
+	for (patience = 0x100000; patience > 0; --patience) {
+		if (ioread32(port_base + LINK_CONTROL) & 0x00000001) {
+			break;
+		}
+	}
+	if (patience == 0)
+		DPRINTK("link read timed out\n");
+
+	result = readl(port_base + LINK_DATA);
+
+	return result;
+}
+
+static int sata_oxnas_scr_read_port(struct ata_port *ap, unsigned int sc_reg, u32 *val)
+{
+	*val = sata_oxnas_link_read(ap, 0x20 + (sc_reg*4));
+	return 0;
+}
+
+static int sata_oxnas_scr_read(struct ata_link *link,
+			     unsigned int sc_reg, u32 *val)
+{
+
+	return sata_oxnas_scr_read_port(link->ap, sc_reg, val);
+}
+
+/**
+ * sata_oxnas_irq_clear is called during probe just before the interrupt handler is
+ * registered, to be sure hardware is quiet. It clears and masks interrupt bits
+ * in the SATA core.
+ *
+ * @param ap hardware with the registers in
+ */
+static void sata_oxnas_irq_clear(struct ata_port* ap)
+{
+	struct sata_oxnas_port_priv *port_priv = ap->private_data;
+
+	/* clear pending interrupts */
+	iowrite32(~0, port_priv->port_base + INT_CLEAR);
+	iowrite32(COREINT_END, port_priv->core_base + CORE_INT_CLEAR);
+}
+
+/**
+ * qc_issue is used to make a command active, once the hardware and S/G tables
+ * have been prepared. IDE BMDMA drivers use the helper function
+ * ata_qc_issue_prot() for taskfile protocol-based dispatch. More advanced drivers
+ * roll their own ->qc_issue implementation, using this as the "issue new ATA
+ * command to hardware" hook.
+ * @param qc the queued command to issue
+ */
+static unsigned int sata_oxnas_qc_issue(struct ata_queued_cmd *qc)
+{
+	struct sata_oxnas_port_priv* pd = qc->ap->private_data;
+	void __iomem *port_base = pd->port_base;
+	void __iomem *core_base = pd->core_base;
+	int port_no = qc->ap->port_no;
+	u32 reg;
+
+	/* check the core is idle */
+	if (ioread32(port_base + SATA_COMMAND) & CMD_CORE_BUSY)
+	{
+		int count = 0;
+		DPRINTK("core busy for a command on port %d\n" ,qc->ap->port_no);
+		do {
+			mdelay(1);
+			if (++count > 100) {
+				DPRINTK("core busy for a command on port %d\n",qc->ap->port_no);
+				//CrazyDumpDebug();
+				sata_oxnas_cleanup(qc->ap->host);
+			}
+		} while (ioread32(port_base + SATA_COMMAND) & CMD_CORE_BUSY);
+	}
+
+	/* enable passing of error signals to DMA sub-core by clearing the
+	appropriate bit (all transfers are on dma channel 0)*/
+	reg = ioread32(core_base + DATA_PLANE_CTRL);
+	reg &= ~(DPC_ERROR_MASK_BIT << port_no);
+	iowrite32(reg, core_base + DATA_PLANE_CTRL);
+
+	/* Disable all interrupts for ports and RAID controller */
+	iowrite32(~0, port_base + INT_DISABLE);
+
+	/* Disable all interrupts for core */
+	iowrite32(~0, core_base + CORE_INT_DISABLE);
+	wmb();
+
+	/* Load the command settings into the orb registers */
+	sata_oxnas_tf_load(qc->ap, &qc->tf);
+
+	/* both pio and dma commands use dma */
+	if (ata_is_dma(qc->tf.protocol) || ata_is_pio(qc->tf.protocol))
+	{
+		/* Start the DMA */
+		iowrite32(SGDMA_CONTROL_GO,	pd->sgdma_base + SGDMA_CONTROL);
+		wmb();
+	}
+
+	/* enable End of command interrupt */
+	iowrite32(INT_WANT, port_base + INT_ENABLE);
+	iowrite32(COREINT_END, core_base + CORE_INT_ENABLE);
+	wmb();
+
+	/* Start the command */
+	reg = ioread32(port_base + SATA_COMMAND);
+	reg &= ~SATA_OPCODE_MASK;
+	reg |= CMD_WRITE_TO_ORB_REGS;
+	iowrite32(reg , port_base + SATA_COMMAND);
+	wmb();
+
+	return 0;
+}
+
+/**
+ * Will schedule the libATA error handler on the premise that there has
+ * been a hotplug event on the port specified
+ */
+void sata_oxnas_checkforhotplug(struct ata_port* ap)
+{
+	DPRINTK("ENTER\n");
+
+	ata_ehi_hotplugged(&ap->link.eh_info);
+	ata_port_freeze(ap);
+}
+
+
+static inline int sata_oxnas_is_host_frozen(struct ata_host* ah)
+{
+	struct sata_oxnas_host_priv *hd = ah->private_data;
+	smp_rmb();
+	return hd->port_in_eh;
+}
+
+static inline u32 sata_oxnas_hostportbusy(struct ata_port* ap)
+{
+	struct sata_oxnas_port_priv* pd = ap->private_data;
+	return ioread32(pd->port_base + SATA_COMMAND) & CMD_CORE_BUSY;
+}
+
+static inline u32 sata_oxnas_hostdmabusy(struct ata_port* ap)
+{
+	struct sata_oxnas_port_priv* pd = ap->private_data;
+	return  ioread32(pd->sgdma_base + SGDMA_STATUS) & SGDMA_BUSY;
+}
+
+
+/**
+ * Turns on the cores clock and resets it
+ */
+static void sata_oxnas_reset_core(struct ata_host *ah)
+{
+	struct sata_oxnas_host_priv *host_priv = ah->private_data;
+
+	DPRINTK("ENTER\n");
+	clk_prepare_enable(host_priv->clk);
+
+	reset_control_assert(host_priv->rst_sata);
+	reset_control_assert(host_priv->rst_link);
+	reset_control_assert(host_priv->rst_phy);
+
+	udelay(50);
+
+	// un-reset the PHY, then Link and Controller
+	reset_control_deassert(host_priv->rst_phy);
+	udelay(50);
+
+	reset_control_deassert(host_priv->rst_sata);
+	reset_control_deassert(host_priv->rst_link);
+	udelay(50);
+
+	workaround5458(ah);
+	/* tune for sata compatability */
+	sata_oxnas_link_write(ah->ports[0], 0x60, 0x2988);
+
+	/* each port in turn */
+	sata_oxnas_link_write(ah->ports[0], 0x70, 0x55629);
+	udelay(50);
+}
+
+
+/**
+ *
+ * Called after an identify device command has worked out what kind of device
+ * is on the port
+ *
+ * @param port The port to configure
+ * @param pdev The hardware associated with controlling the port
+ */
+static void sata_oxnas_dev_config(struct ata_device* pdev)
+{
+	struct sata_oxnas_port_priv *pd = pdev->link->ap->private_data;
+	void __iomem *port_base = pd->port_base;
+	u32 reg;
+
+	DPRINTK("ENTER\n");
+	/* Set the bits to put the port into 28 or 48-bit node */
+	reg = ioread32(port_base + DRIVE_CONTROL);
+	reg &= ~3;
+	reg |= (pdev->flags & ATA_DFLAG_LBA48) ? DR_CON_48 : DR_CON_28;
+	iowrite32(reg, port_base + DRIVE_CONTROL);
+
+	/* if this is an ATA-6 disk, put the port into ATA-5 auto translate mode */
+	if (pdev->flags & ATA_DFLAG_LBA48) {
+		reg = ioread32(port_base + PORT_CONTROL);
+		reg |= 2;
+		iowrite32(reg, port_base + PORT_CONTROL);
+	}
+}
+/**
+ * called to write a taskfile into the ORB registers
+ * @param ap hardware with the registers in
+ * @param tf taskfile to write to the registers
+ */
+static void sata_oxnas_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)
+{
+	u32 count = 0;
+	u32 Orb1 = 0;
+	u32 Orb2 = 0;
+	u32 Orb3 = 0;
+	u32 Orb4 = 0;
+	u32 Command_Reg;
+	struct sata_oxnas_port_priv *port_priv = ap->private_data;
+	void __iomem *port_base = port_priv->port_base;
+	unsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;
+
+	/* wait a maximum of 10ms for the core to be idle */
+	do {
+		Command_Reg = ioread32(port_base + SATA_COMMAND);
+		if (!(Command_Reg & CMD_CORE_BUSY)) {
+			break;
+		}
+		count++;
+		udelay(50);
+	} while (count < 200);
+
+	/* check if the ctl register has interrupts disabled or enabled and
+	modify the interrupt enable registers on the ata core as required */
+	if (tf->ctl & ATA_NIEN) {
+		/* interrupts disabled */
+		u32 mask = (COREINT_END << ap->port_no);
+		iowrite32(mask, port_priv->core_base + CORE_INT_DISABLE);
+		sata_oxnas_irq_clear(ap);
+	} else {
+		sata_oxnas_irq_on(ap);
+	}
+
+	Orb2 |= (tf->command) << 24;
+
+	/* write 48 or 28 bit tf parameters */
+	if (is_addr) {
+		/* set LBA bit as it's an address */
+		Orb1 |= (tf->device & ATA_LBA) << 24;
+
+		if (tf->flags & ATA_TFLAG_LBA48) {
+			Orb1 |= ATA_LBA << 24;
+			Orb2 |= (tf->hob_nsect) << 8 ;
+			Orb3 |= (tf->hob_lbal) << 24;
+			Orb4 |= (tf->hob_lbam) << 0 ;
+			Orb4 |= (tf->hob_lbah) << 8 ;
+			Orb4 |= (tf->hob_feature)<< 16;
+		} else {
+			Orb3 |= (tf->device & 0xf)<< 24;
+		}
+
+		/* write 28-bit lba */
+		Orb2 |= (tf->nsect)  << 0 ;
+		Orb2 |= (tf->feature) << 16;
+		Orb3 |= (tf->lbal)  << 0 ;
+		Orb3 |= (tf->lbam)  << 8 ;
+		Orb3 |= (tf->lbah)  << 16;
+		Orb4 |= (tf->ctl) << 24;
+	}
+
+	if (tf->flags & ATA_TFLAG_DEVICE) {
+		Orb1 |= (tf->device) << 24;
+	}
+	ap->last_ctl = tf->ctl;
+
+	/* write values to registers */
+	iowrite32(Orb1, port_base + ORB1);
+	iowrite32(Orb2, port_base + ORB2);
+	iowrite32(Orb3, port_base + ORB3);
+	iowrite32(Orb4, port_base + ORB4);
+}
+
+
+void sata_oxnas_set_mode(struct ata_port* ap, u32 mode, u32 force)
+{
+	struct sata_oxnas_port_priv *port_priv = ap->private_data;
+	void __iomem *core_base = port_priv->core_base;
+
+	unsigned int *src;
+	void __iomem *dst;
+	unsigned int progmicrocode = 0;
+	unsigned int changeparameters = 0;
+	static u32 previous_mode = UNKNOWN_MODE;
+
+	/* these micro-code programs _should_ include the version word */
+
+	/* JBOD */
+	static const unsigned int jbod[] = {
+		0x07B400AC, 0x0228A280, 0x00200001, 0x00204002, 0x00224001,
+		0x00EE0009, 0x00724901, 0x01A24903, 0x00E40009, 0x00224001,
+		0x00621120, 0x0183C908, 0x00E20005, 0x00718908, 0x0198A206,
+		0x00621124, 0x0183C908, 0x00E20046, 0x00621104, 0x0183C908,
+		0x00E20015, 0x00EE009D, 0x01A3E301, 0x00E2001B, 0x0183C900,
+		0x00E2001B, 0x00210001, 0x00EE0020, 0x01A3E302, 0x00E2009D,
+		0x0183C901, 0x00E2009D, 0x00210002, 0x0235D700, 0x0208A204,
+		0x0071C908, 0x000F8207, 0x000FC207, 0x0071C920, 0x000F8507,
+		0x000FC507, 0x0228A240, 0x02269A40, 0x00094004, 0x00621104,
+		0x0180C908, 0x00E40031, 0x00621112, 0x01A3C801, 0x00E2002B,
+		0x00294000, 0x0228A220, 0x01A69ABF, 0x002F8000, 0x002FC000,
+		0x0198A204, 0x0001C022, 0x01B1A220, 0x0001C106, 0x00088007,
+		0x0183C903, 0x00E2009D, 0x0228A220, 0x0071890C, 0x0208A206,
+		0x0198A206, 0x0001C022, 0x01B1A220, 0x0001C106, 0x00088007,
+		0x00EE009D, 0x00621104, 0x0183C908, 0x00E2004A, 0x00EE009D,
+		0x01A3C901, 0x00E20050, 0x0021E7FF, 0x0183E007, 0x00E2009D,
+		0x00EE0054, 0x0061600B, 0x0021E7FF, 0x0183C507, 0x00E2009D,
+		0x01A3E301, 0x00E2005A, 0x0183C900, 0x00E2005A, 0x00210001,
+		0x00EE005F, 0x01A3E302, 0x00E20005, 0x0183C901, 0x00E20005,
+		0x00210002, 0x0235D700, 0x0208A204, 0x000F8109, 0x000FC109,
+		0x0071C918, 0x000F8407, 0x000FC407, 0x0001C022, 0x01A1A2BF,
+		0x0001C106, 0x00088007, 0x02269A40, 0x00094004, 0x00621112,
+		0x01A3C801, 0x00E4007F, 0x00621104, 0x0180C908, 0x00E4008D,
+		0x00621128, 0x0183C908, 0x00E2006C, 0x01A3C901, 0x00E2007B,
+		0x0021E7FF, 0x0183E007, 0x00E2007F, 0x00EE006C, 0x0061600B,
+		0x0021E7FF, 0x0183C507, 0x00E4006C, 0x00621111, 0x01A3C801,
+		0x00E2007F, 0x00621110, 0x01A3C801, 0x00E20082, 0x0228A220,
+		0x00621119, 0x01A3C801, 0x00E20086, 0x0001C022, 0x01B1A220,
+		0x0001C106, 0x00088007, 0x0198A204, 0x00294000, 0x01A69ABF,
+		0x002F8000, 0x002FC000, 0x0183C903, 0x00E20005, 0x0228A220,
+		0x0071890C, 0x0208A206, 0x0198A206, 0x0001C022, 0x01B1A220,
+		0x0001C106, 0x00088007, 0x00EE009D, 0x00621128, 0x0183C908,
+		0x00E20005, 0x00621104, 0x0183C908, 0x00E200A6, 0x0062111C,
+		0x0183C908, 0x00E20005, 0x0071890C, 0x0208A206, 0x0198A206,
+		0x00718908, 0x0208A206, 0x00EE0005, ~0
+	};
+
+	/* Bi-Modal RAID-0/1 */
+	static const unsigned int raid[] = {
+		0x00F20145, 0x00EE20FA, 0x00EE20A7, 0x0001C009, 0x00EE0004,
+		0x00220000, 0x0001000B, 0x037003FF, 0x00700018, 0x037003FE,
+		0x037043FD, 0x00704118, 0x037043FC, 0x01A3D240, 0x00E20017,
+		0x00B3C235, 0x00E40018, 0x0093C104, 0x00E80014, 0x0093C004,
+		0x00E80017, 0x01020000, 0x00274020, 0x00EE0083, 0x0080C904,
+		0x0093C104, 0x00EA0020, 0x0093C103, 0x00EC001F, 0x00220002,
+		0x00924104, 0x0005C009, 0x00EE0058, 0x0093CF04, 0x00E80026,
+		0x00900F01, 0x00600001, 0x00910400, 0x00EE0058, 0x00601604,
+		0x01A00003, 0x00E2002C, 0x01018000, 0x00274040, 0x00EE0083,
+		0x0093CF03, 0x00EC0031, 0x00220003, 0x00924F04, 0x0005C009,
+		0x00810104, 0x00B3C235, 0x00E20037, 0x0022C000, 0x00218210,
+		0x00EE0039, 0x0022C001, 0x00218200, 0x00600401, 0x00A04901,
+		0x00604101, 0x01A0C401, 0x00E20040, 0x00216202, 0x00EE0041,
+		0x00216101, 0x02018506, 0x00EE2141, 0x00904901, 0x00E20049,
+		0x00A00401, 0x00600001, 0x02E0C301, 0x00EE2141, 0x00216303,
+		0x037003EE, 0x01A3C001, 0x00E40105, 0x00250080, 0x00204000,
+		0x002042F1, 0x0004C001, 0x00230001, 0x00100006, 0x02C18605,
+		0x00100006, 0x01A3D502, 0x00E20055, 0x00EE0053, 0x00004009,
+		0x00000004, 0x00B3C235, 0x00E40062, 0x0022C001, 0x0020C000,
+		0x00EE2141, 0x0020C001, 0x00EE2141, 0x00EE006B, 0x0022C000,
+		0x0060D207, 0x00EE2141, 0x00B3C242, 0x00E20069, 0x01A3D601,
+		0x00E2006E, 0x02E0C301, 0x00EE2141, 0x00230001, 0x00301303,
+		0x00EE007B, 0x00218210, 0x01A3C301, 0x00E20073, 0x00216202,
+		0x00EE0074, 0x00216101, 0x02018506, 0x00214000, 0x037003EE,
+		0x01A3C001, 0x00E40108, 0x00230001, 0x00100006, 0x00250080,
+		0x00204000, 0x002042F1, 0x0004C001, 0x00EE007F, 0x0024C000,
+		0x01A3D1F0, 0x00E20088, 0x00230001, 0x00300000, 0x01A3D202,
+		0x00E20085, 0x00EE00A5, 0x00B3C800, 0x00E20096, 0x00218000,
+		0x00924709, 0x0005C009, 0x00B20802, 0x00E40093, 0x037103FD,
+		0x00710418, 0x037103FC, 0x00EE0006, 0x00220000, 0x0001000F,
+		0x00EE0006, 0x00800B0C, 0x00B00001, 0x00204000, 0x00208550,
+		0x00208440, 0x002083E0, 0x00208200, 0x00208100, 0x01008000,
+		0x037083EE, 0x02008212, 0x02008216, 0x01A3C201, 0x00E400A5,
+		0x0100C000, 0x00EE20FA, 0x02800000, 0x00208000, 0x00B24C00,
+		0x00E400AD, 0x00224001, 0x00724910, 0x0005C009, 0x00B3CDC4,
+		0x00E200D5, 0x00B3CD29, 0x00E200D5, 0x00B3CD20, 0x00E200D5,
+		0x00B3CD24, 0x00E200D5, 0x00B3CDC5, 0x00E200D2, 0x00B3CD39,
+		0x00E200D2, 0x00B3CD30, 0x00E200D2, 0x00B3CD34, 0x00E200D2,
+		0x00B3CDCA, 0x00E200CF, 0x00B3CD35, 0x00E200CF, 0x00B3CDC8,
+		0x00E200CC, 0x00B3CD25, 0x00E200CC, 0x00B3CD40, 0x00E200CB,
+		0x00B3CD42, 0x00E200CB, 0x01018000, 0x00EE0083, 0x0025C000,
+		0x036083EE, 0x0000800D, 0x00EE00D8, 0x036083EE, 0x00208035,
+		0x00EE00DA, 0x036083EE, 0x00208035, 0x00EE00DA, 0x00208007,
+		0x036083EE, 0x00208025, 0x036083EF, 0x02400000, 0x01A3D208,
+		0x00E200D8, 0x0067120A, 0x0021C000, 0x0021C224, 0x00220000,
+		0x00404B1C, 0x00600105, 0x00800007, 0x0020C00E, 0x00214000,
+		0x01004000, 0x01A0411F, 0x00404E01, 0x01A3C101, 0x00E200F1,
+		0x00B20800, 0x00E400D8, 0x00220001, 0x0080490B, 0x00B04101,
+		0x0040411C, 0x00EE00E1, 0x02269A01, 0x01020000, 0x02275D80,
+		0x01A3D202, 0x00E200F4, 0x01B75D80, 0x01030000, 0x01B69A01,
+		0x00EE00D8, 0x01A3D204, 0x00E40104, 0x00224000, 0x0020C00E,
+		0x0020001E, 0x00214000, 0x01004000, 0x0212490E, 0x00214001,
+		0x01004000, 0x02400000, 0x00B3D702, 0x00E80112, 0x00EE010E,
+		0x00B3D702, 0x00E80112, 0x00B3D702, 0x00E4010E, 0x00230001,
+		0x00EE0140, 0x00200005, 0x036003EE, 0x00204001, 0x00EE0116,
+		0x00230001, 0x00100006, 0x02C18605, 0x00100006, 0x01A3D1F0,
+		0x00E40083, 0x037003EE, 0x01A3C002, 0x00E20121, 0x0020A300,
+		0x0183D102, 0x00E20124, 0x037003EE, 0x01A00005, 0x036003EE,
+		0x01A0910F, 0x00B3C20F, 0x00E2012F, 0x01A3D502, 0x00E20116,
+		0x01A3C002, 0x00E20116, 0x00B3D702, 0x00E4012C, 0x00300000,
+		0x00EE011F, 0x02C18605, 0x00100006, 0x00EE0116, 0x01A3D1F0,
+		0x00E40083, 0x037003EE, 0x01A3C004, 0x00E20088, 0x00200003,
+		0x036003EE, 0x01A3D502, 0x00E20136, 0x00230001, 0x00B3C101,
+		0x00E4012C, 0x00100006, 0x02C18605, 0x00100006, 0x00204000,
+		0x00EE0116, 0x00100006, 0x01A3D1F0, 0x00E40083, 0x01000000,
+		0x02400000, ~0
+	};
+
+	if (force) {
+		previous_mode = UNKNOWN_MODE;
+	}
+
+	if (mode == previous_mode) {
+		return;
+	}
+
+	/* decide what needs to be done using the STD in my logbook*/
+	switch(previous_mode) {
+	case OXNASSATA_RAID1:
+		switch(mode) {
+		case OXNASSATA_RAID0:
+			changeparameters = 1;
+			break;
+		case OXNASSATA_NOTRAID:
+			changeparameters = 1;
+			progmicrocode = 1;
+			break;
+		}
+		break;
+	case OXNASSATA_RAID0:
+		switch(mode) {
+		case OXNASSATA_RAID1:
+			changeparameters = 1;
+			break;
+		case OXNASSATA_NOTRAID:
+			changeparameters = 1;
+			progmicrocode = 1;
+			break;
+		}
+		break;
+	case OXNASSATA_NOTRAID:
+	case UNKNOWN_MODE:
+		changeparameters = 1;
+		progmicrocode = 1;
+		break;
+	}
+
+	/* no need to reprogram everything if already in the right mode */
+	if (progmicrocode) {
+		/* reset micro-code processor */
+		iowrite32(1, core_base + PROC_RESET);
+		wmb();
+
+		/* select micro-code */
+		switch(mode) {
+		case OXNASSATA_RAID1:
+		case OXNASSATA_RAID0:
+			VPRINTK("Loading RAID micro-code\n");
+			src = (unsigned int*)&raid[1];
+			break;
+		case OXNASSATA_NOTRAID:
+			VPRINTK("Loading JBOD micro-code\n");
+			src = (unsigned int*)&jbod[1];
+			break;
+		default:
+			BUG();
+			break;
+		}
+
+		/* load micro code */
+		dst = core_base + UCODE_STORE;
+		while (*src != ~0) {
+			iowrite32(*src, dst);
+			src++;
+			dst += sizeof(*src);
+		}
+		wmb();
+	}
+
+	if (changeparameters) {
+		u32 reg;
+		/* set other mode dependent flags */
+		switch(mode) {
+		case OXNASSATA_RAID1:
+			/* clear JBOD mode */
+			reg = ioread32(core_base + DATA_PLANE_CTRL);
+			reg |= DPC_JBOD_UCODE;
+			reg &= ~DPC_FIS_SWCH;
+			iowrite32(reg, core_base + DATA_PLANE_CTRL);
+			wmb();
+
+			/* set the hardware up for RAID-1 */
+			iowrite32(0, core_base + RAID_WP_BOT_LOW);
+			iowrite32(0, core_base + RAID_WP_BOT_HIGH);
+			iowrite32(0xffffffff, core_base + RAID_WP_TOP_LOW);
+			iowrite32(0x7fffffff, core_base + RAID_WP_TOP_HIGH);
+			iowrite32(0, core_base + RAID_SIZE_LOW);
+			iowrite32(0, core_base + RAID_SIZE_HIGH);
+			wmb();
+			break;
+		case OXNASSATA_RAID0:
+			/* clear JBOD mode */
+			reg = ioread32(core_base + DATA_PLANE_CTRL);
+			reg |= DPC_JBOD_UCODE;
+			reg &= ~DPC_FIS_SWCH;
+			iowrite32(reg, core_base + DATA_PLANE_CTRL);
+			wmb();
+
+			/* set the hardware up for RAID-1 */
+			iowrite32(0, core_base + RAID_WP_BOT_LOW);
+			iowrite32(0, core_base + RAID_WP_BOT_HIGH);
+			iowrite32(0xffffffff, core_base + RAID_WP_TOP_LOW);
+			iowrite32(0x7fffffff, core_base + RAID_WP_TOP_HIGH);
+			iowrite32(0xffffffff, core_base + RAID_SIZE_LOW);
+			iowrite32(0x7fffffff, core_base + RAID_SIZE_HIGH);
+			wmb();
+			break;
+		case OXNASSATA_NOTRAID:
+			/* enable jbod mode */
+			reg = ioread32(core_base + DATA_PLANE_CTRL);
+			reg &= ~DPC_JBOD_UCODE;
+			reg |= DPC_FIS_SWCH;
+			iowrite32(reg, core_base + DATA_PLANE_CTRL);
+			wmb();
+
+			/* start micro-code processor*/
+			iowrite32(1, core_base + PROC_START);
+			break;
+		default:
+			break;
+		}
+	}
+
+	previous_mode = mode;
+}
+
+/**
+ * sends a sync-escape if there is a link present
+ */
+static inline void sata_oxnas_send_sync_escape(struct ata_port *ap)
+{
+	struct sata_oxnas_port_priv *pd = ap->private_data;
+	u32 reg;
+
+	/* read the SSTATUS register and only send a sync escape if there is a
+	* link active */
+	if ((sata_oxnas_link_read(ap, 0x20) & 3) == 3) {
+		reg = ioread32(pd->port_base + SATA_COMMAND);
+		reg &= ~SATA_OPCODE_MASK;
+		reg |= CMD_SYNC_ESCAPE;
+		iowrite32(reg, pd->port_base + SATA_COMMAND);
+	}
+}
+
+/* clears errors */
+static inline void sata_oxnas_clear_CS_error(u32* base)
+{
+	u32 reg;
+	reg = ioread32(base + SATA_CONTROL);
+	reg &= SATA_CTL_ERR_MASK;
+	iowrite32(reg, base + SATA_CONTROL);
+}
+
+/**
+ * Clears the error caused by the core's registers being accessed when the
+ * core is busy.
+ */
+static inline void sata_oxnas_clear_reg_access_error(u32* base)
+{
+	u32 reg;
+	reg = ioread32(base + INT_STATUS);
+
+	DPRINTK("ENTER\n");
+	if (reg & INT_REG_ACCESS_ERR) {
+		printk("clearing register access error\n");
+		iowrite32(INT_REG_ACCESS_ERR, base + INT_STATUS);
+	}
+	if (reg & INT_REG_ACCESS_ERR) {
+		printk("register access error didn't clear\n");
+	}
+}
+
+/**
+ * Clean up all the state machines in the sata core.
+ * @return post cleanup action required
+ */
+cleanup_recovery_t sata_oxnas_cleanup(struct ata_host* ah)
+{
+	int actions_required = 0;
+
+	printk(KERN_INFO "ox820sata: reseting SATA core\n");
+
+	/* core not recovering, reset it */
+	mdelay(5);
+	sata_oxnas_reset_core(ah);
+	mdelay(5);
+	actions_required |= OXNAS_SATA_REINIT;
+	/* Perform any SATA core re-initialisation after reset */
+	/* post reset init needs to be called for both ports as there's one reset
+	for both ports*/
+
+	sata_oxnas_post_reset_init(ah->ports[0]);
+
+	return actions_required;
+}
+
+void sata_oxnas_freeze_host(struct ata_port* ap)
+{
+	struct sata_oxnas_host_priv *hd = ap->host->private_data;
+
+	DPRINTK("ENTER\n");
+	hd->port_in_eh |= BIT(ap->port_no);
+	smp_wmb();
+}
+
+void sata_oxnas_thaw_host(struct ata_port* ap)
+{
+	struct sata_oxnas_host_priv *hd = ap->host->private_data;
+
+	DPRINTK("ENTER\n");
+	hd->port_in_eh &= ~BIT(ap->port_no);
+	smp_wmb();
+}
+
+static void sata_oxnas_post_internal_cmd(struct ata_queued_cmd *qc)
+{
+	DPRINTK("ENTER\n");
+	if (qc->flags & ATA_QCFLAG_FAILED) {
+		 /* If the core is busy here, make it idle */
+		sata_oxnas_cleanup(qc->ap->host);
+	}
+}
+
+
+/**
+ * turn on the interrupts
+ *
+ * @param ap Hardware with the registers in
+ */
+static void sata_oxnas_irq_on(struct ata_port *ap)
+{
+	struct sata_oxnas_port_priv *pd = ap->private_data;
+	u32 mask = (COREINT_END << ap->port_no);
+
+	/* Clear pending interrupts */
+	iowrite32(~0, pd->port_base + INT_CLEAR);
+	iowrite32(mask, pd->core_base + CORE_INT_STATUS);
+	wmb();
+
+	/* enable End of command interrupt */
+	iowrite32(INT_WANT, pd->port_base + INT_ENABLE);
+	iowrite32(mask, pd->core_base + CORE_INT_ENABLE);
+}
+
+
+/** @return true if the port has a cable connected */
+int sata_oxnas_check_link(struct ata_port* ap)
+{
+	int reg;
+
+	sata_oxnas_scr_read_port(ap, SCR_STATUS, &reg);
+	/* Check for the cable present indicated by SCR status bit-0 set */
+	return (reg & 0x1);
+}
+
+/**
+ *	ata_std_postreset - standard postreset callback
+ *	@link: the target ata_link
+ *	@classes: classes of attached devices
+ *
+ *	This function is invoked after a successful reset. Note that
+ *	the device might have been reset more than once using
+ *	different reset methods before postreset is invoked.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ */
+static void sata_oxnas_postreset(struct ata_link *link, unsigned int *classes)
+{
+	struct ata_port *ap = link->ap;
+
+	unsigned int dev;
+
+	DPRINTK("ENTER\n");
+	ata_std_postreset(link, classes);
+
+	/* turn on phy error detection by removing the masks */
+	sata_oxnas_link_write(ap , 0x0c, 0x30003);
+
+	/* bail out if no device is present */
+	if (classes[0] == ATA_DEV_NONE && classes[1] == ATA_DEV_NONE) {
+		DPRINTK("EXIT, no device\n");
+		return;
+	}
+
+	/* go through all the devices and configure them */
+	for (dev = 0; dev < ATA_MAX_DEVICES; ++dev) {
+		if (ap->link.device[dev].class == ATA_DEV_ATA) {
+			sata_oxnas_dev_config(&(ap->link.device[dev]));
+		}
+	}
+
+	DPRINTK("EXIT\n");
+}
+
+/**
+ * Called to read the hardware registers / DMA buffers, to
+ * obtain the current set of taskfile register values.
+ * @param ap hardware with the registers in
+ * @param tf taskfile to read the registers into
+ */
+static void sata_oxnas_tf_read(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	struct sata_oxnas_port_priv *port_priv = ap->private_data;
+	void __iomem *port_base = port_priv->port_base;
+	/* read the orb registers */
+	u32 Orb1 = ioread32(port_base + ORB1);
+	u32 Orb2 = ioread32(port_base + ORB2);
+	u32 Orb3 = ioread32(port_base + ORB3);
+	u32 Orb4 = ioread32(port_base + ORB4);
+
+	/* read common 28/48 bit tf parameters */
+	tf->device = (Orb1 >> 24);
+	tf->nsect = (Orb2 >> 0);
+	tf->feature = (Orb2 >> 16);
+	tf->command = sata_oxnas_check_status(ap);
+
+	/* read 48 or 28 bit tf parameters */
+	if (tf->flags & ATA_TFLAG_LBA48) {
+		tf->hob_nsect = (Orb2 >> 8) ;
+		tf->lbal = (Orb3 >> 0) ;
+		tf->lbam = (Orb3 >> 8) ;
+		tf->lbah = (Orb3 >> 16) ;
+		tf->hob_lbal = (Orb3 >> 24) ;
+		tf->hob_lbam = (Orb4 >> 0) ;
+		tf->hob_lbah = (Orb4 >> 8) ;
+		/* feature ext and control are write only */
+	} else {
+		/* read 28-bit lba */
+		tf->lbal = (Orb3 >> 0) ;
+		tf->lbam = (Orb3 >> 8) ;
+		tf->lbah = (Orb3 >> 16) ;
+	}
+}
+
+/**
+ * Read a result task-file from the sata core registers.
+ */
+static bool sata_oxnas_qc_fill_rtf(struct ata_queued_cmd *qc)
+{
+	/* Read the most recently received FIS from the SATA core ORB registers
+	 and convert to an ATA taskfile */
+	sata_oxnas_tf_read(qc->ap, &qc->result_tf);
+	return true;
+}
+
+/**
+ * Reads the Status ATA shadow register from hardware.
+ *
+ * @return The status register
+ */
+static u8 sata_oxnas_check_status(struct ata_port *ap)
+{
+	u32 Reg;
+	u8 status;
+	struct sata_oxnas_port_priv *port_priv = ap->private_data;
+	void __iomem *port_base = port_priv->port_base;
+
+	/* read byte 3 of Orb2 register */
+	status = ioread32(port_base + ORB2) >> 24;
+
+	/* check for the drive going missing indicated by SCR status bits 0-3 = 0 */
+	sata_oxnas_scr_read_port(ap, SCR_STATUS, &Reg);
+
+	if (!(Reg & 0x1)) {
+		status |= ATA_DF;
+		status |= ATA_ERR;
+	}
+
+	return status;
+}
+
+/**
+ * ata_qc_new - Request an available ATA command, for queueing
+ * @ap: Port associated with device @dev
+ * @return non zero will refuse a new command, zero will may grant on subject
+ *		 to conditions elsewhere.
+ *
+ */
+static int sata_oxnas_qc_new(struct ata_port *ap)
+{
+	struct sata_oxnas_host_priv *hd = ap->host->private_data;
+	smp_rmb();
+	return hd->port_in_eh;
+}
+
+/**
+ * Prepare as much as possible for a command without involving anything that is
+ * shared between ports.
+ */
+static void sata_oxnas_qc_prep(struct ata_queued_cmd* qc)
+{
+	struct sata_oxnas_port_priv *pd;
+	int port_no = qc->ap->port_no;
+
+	/* if the port's not connected, complete now with an error */
+	/*
+	if (!sata_oxnas_check_link(qc->ap)) {
+		printk(KERN_ERR "port %d not connected completing with error\n",qc->ap->port_no);
+		qc->err_mask |= AC_ERR_ATA_BUS;
+		ata_qc_complete(qc);
+	}
+	*/
+	/* both pio and dma commands use dma */
+	if (ata_is_dma(qc->tf.protocol) || ata_is_pio(qc->tf.protocol))
+	{
+
+		/* program the scatterlist into the prd table */
+		ata_bmdma_qc_prep(qc);
+
+		/* point the sgdma controller at the dma request structure */
+		pd = qc->ap->private_data;
+
+		iowrite32(pd->sgdma_request_pa, pd->sgdma_base + SGDMA_REQUESTPTR);
+
+		/* setup the request table */
+		if (port_no == 0) {
+			pd->sgdma_request->control = (qc->dma_dir == DMA_FROM_DEVICE) ?
+										SGDMA_REQCTL0IN : SGDMA_REQCTL0OUT ;
+		} else {
+			pd->sgdma_request->control = (qc->dma_dir == DMA_FROM_DEVICE) ?
+										SGDMA_REQCTL1IN : SGDMA_REQCTL1OUT ;
+		}
+		pd->sgdma_request->qualifier = SGDMA_REQQUAL;
+		pd->sgdma_request->src_pa = qc->ap->bmdma_prd_dma;
+		pd->sgdma_request->dst_pa = qc->ap->bmdma_prd_dma;
+		smp_wmb();
+
+		/* tell it to wait */
+		iowrite32(SGDMA_CONTROL_NOGO, pd->sgdma_base + SGDMA_CONTROL);
+	}
+}
+
+static int sata_oxnas_port_start(struct ata_port *ap)
+{
+	struct sata_oxnas_host_priv *host_priv = ap->host->private_data;
+	struct device *dev = ap->host->dev;
+	struct sata_oxnas_port_priv *pp;
+	void *mem;
+	dma_addr_t mem_dma;
+
+	DPRINTK("ENTER\n");
+
+	pp = kzalloc(sizeof(*pp), GFP_KERNEL);
+	if (!pp)
+		return -ENOMEM;
+
+	pp->port_base = host_priv->port_base[ap->port_no];
+	pp->sgdma_base = host_priv->sgdma_base[ap->port_no];
+	pp->core_base = host_priv->core_base;
+
+	/* preallocated */
+	if (host_priv->dma_size >= SATA_OXNAS_DMA_SIZE * SATA_OXNAS_MAX_PORTS) {
+		mem_dma = host_priv->dma_base + ap->port_no * SATA_OXNAS_DMA_SIZE;
+		mem = ioremap(mem_dma, SATA_OXNAS_DMA_SIZE);
+
+	} else {
+		mem = dma_alloc_coherent(dev, SATA_OXNAS_DMA_SIZE, &mem_dma,
+					 GFP_KERNEL);
+	}
+	if (!mem)
+		goto err_ret;
+
+	pp->sgdma_request_pa = mem_dma;
+	pp->sgdma_request = mem;
+	ap->bmdma_prd_dma = mem_dma + sizeof(sgdma_request_t);
+	ap->bmdma_prd = mem +  sizeof(sgdma_request_t);
+
+	ap->private_data = pp;
+
+	sata_oxnas_post_reset_init(ap);
+
+	return 0;
+
+err_ret:
+	kfree(pp);
+	return -ENOMEM;
+
+}
+
+static void sata_oxnas_port_stop(struct ata_port *ap)
+{
+	struct device *dev = ap->host->dev;
+	struct sata_oxnas_port_priv *pp = ap->private_data;
+	struct sata_oxnas_host_priv *host_priv = ap->host->private_data;
+	DPRINTK("ENTER\n");
+	ap->private_data = NULL;
+	if (host_priv->dma_size) {
+		iounmap(pp->sgdma_request);
+	} else {
+		dma_free_coherent(dev, SATA_OXNAS_DMA_SIZE,
+				  pp->sgdma_request, pp->sgdma_request_pa);
+	}
+
+	kfree(pp);
+}
+
+static void sata_oxnas_post_reset_init(struct ata_port* ap)
+{
+	struct sata_oxnas_port_priv *pd = ap->private_data;
+	uint dev;
+	int no_microcode = 0;
+	DPRINTK("ENTER\n");
+	if(no_microcode)
+	{
+		u32 reg;
+
+		sata_oxnas_set_mode(ap, UNKNOWN_MODE, 1);
+		reg = readl(pd->core_base + DEVICE_CONTROL);
+		reg |= DEVICE_CONTROL_ATA_ERR_OVERRIDE;
+		writel(reg, pd->core_base + DEVICE_CONTROL);
+
+	} else {
+		/* JBOD uCode */
+		sata_oxnas_set_mode(ap, OXNASSATA_NOTRAID, 1);
+
+		/* Turn the work around off as it may have been left on by any HW-RAID
+		code that we've been working with */
+		writel(0x0, pd->core_base + PORT_ERROR_MASK);
+	}
+	/* turn on phy error detection by removing the masks */
+	sata_oxnas_link_write(ap, 0x0C, 0x30003);
+
+	/* enable hotplug event detection */
+	sata_oxnas_scr_write_port(ap, SCR_ERROR, ~0);
+	sata_oxnas_scr_write_port(ap, SERROR_IRQ_MASK, 0x03feffff);
+	sata_oxnas_scr_write_port(ap, SCR_ACTIVE, ~0 & ~(1 << 26) & ~(1 << 16));
+
+	/* enable interrupts for ports */
+	sata_oxnas_irq_on(ap);
+
+	/* go through all the devices and configure them */
+	for (dev = 0; dev < ATA_MAX_DEVICES; ++dev) {
+		if (ap->link.device[dev].class == ATA_DEV_ATA) {
+			sata_std_hardreset(&ap->link, NULL, jiffies + HZ);
+			sata_oxnas_dev_config(&(ap->link.device[dev]));
+		}
+	}
+
+	/* clean up any remaining errors */
+	sata_oxnas_scr_write_port(ap, SCR_ERROR, ~0);
+	VPRINTK("done\n");
+}
+
+/**
+ * host_stop() is called when the rmmod or hot unplug process begins. The
+ * hook must stop all hardware interrupts, DMA engines, etc.
+ *
+ * @param ap hardware with the registers in
+ */
+static void sata_oxnas_host_stop(struct ata_host *host_set)
+{
+	DPRINTK("\n");
+}
+
+
+#define ERROR_HW_ACQUIRE_TIMEOUT_JIFFIES (10 * HZ)
+static void sata_oxnas_error_handler(struct ata_port *ap)
+{
+	DPRINTK("Enter port_no %d\n", ap->port_no);
+	sata_oxnas_freeze_host(ap);
+
+	/* If the core is busy here, make it idle */
+	sata_oxnas_cleanup(ap->host);
+
+	ata_std_error_handler(ap);
+
+	sata_oxnas_thaw_host(ap);
+}
+
+static int sata_oxnas_softreset(struct ata_link *link, unsigned int *class,
+				 unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	struct sata_oxnas_port_priv *pd = ap->private_data;
+	void __iomem *port_base = pd->port_base;
+	int rc;
+
+	struct ata_taskfile tf;
+	u32 Command_Reg;
+
+	DPRINTK("ENTER\n");
+
+	port_base = pd->port_base;
+
+	if (ata_link_offline(link)) {
+		DPRINTK("PHY reports no device\n");
+		*class = ATA_DEV_NONE;
+		goto out;
+	}
+
+	/* write value to register */
+	iowrite32((ap->ctl) << 24, port_base + ORB4);
+
+	/* command the core to send a control FIS */
+	Command_Reg = ioread32(port_base + SATA_COMMAND);
+	Command_Reg &= ~SATA_OPCODE_MASK;
+	Command_Reg |= CMD_WRITE_TO_ORB_REGS_NO_COMMAND;
+	iowrite32(Command_Reg, port_base + SATA_COMMAND);
+	udelay(20);	/* FIXME: flush */
+
+	/* write value to register */
+	iowrite32((ap->ctl | ATA_SRST) << 24, port_base + ORB4);
+
+	/* command the core to send a control FIS */
+	Command_Reg &= ~SATA_OPCODE_MASK;
+	Command_Reg |= CMD_WRITE_TO_ORB_REGS_NO_COMMAND;
+	iowrite32(Command_Reg, port_base + SATA_COMMAND);
+	udelay(20);	/* FIXME: flush */
+
+	/* write value to register */
+	iowrite32((ap->ctl) << 24, port_base + ORB4);
+
+	/* command the core to send a control FIS */
+	Command_Reg &= ~SATA_OPCODE_MASK;
+	Command_Reg |= CMD_WRITE_TO_ORB_REGS_NO_COMMAND;
+	iowrite32(Command_Reg, port_base + SATA_COMMAND);
+
+	msleep(150);
+
+	rc = ata_sff_wait_ready(link, deadline);
+
+	/* if link is occupied, -ENODEV too is an error */
+	if (rc && (rc != -ENODEV || sata_scr_valid(link))) {
+		ata_link_printk(link, KERN_ERR, "SRST failed (errno=%d)\n", rc);
+		return rc;
+	}
+
+	/* determine by signature whether we have ATA or ATAPI devices */
+	sata_oxnas_tf_read(ap, &tf);
+	*class = ata_dev_classify(&tf);
+
+ if (*class == ATA_DEV_UNKNOWN) {
+		*class = ATA_DEV_NONE;
+	}
+ out:
+	DPRINTK("EXIT, class=%u\n", *class);
+	return 0;
+}
+
+
+int	sata_oxnas_init_controller(struct ata_host *host)
+{
+	return 0;
+}
+
+/**
+ * Ref bug-6320
+ *
+ * This code is a work around for a DMA hardware bug that will repeat the
+ * penultimate 8-bytes on some reads. This code will check that the amount
+ * of data transferred is a multiple of 512 bytes, if not the in it will
+ * fetch the correct data from a buffer in the SATA core and copy it into
+ * memory.
+ *
+ * @param port SATA port to check and if necessary, correct.
+ */
+static int ox820sata_bug_6320_workaround(struct ata_port *ap)
+{
+	struct sata_oxnas_port_priv *pd = ap->private_data;
+	void __iomem *core_base = pd->core_base;
+	int is_read;
+	int quads_transferred;
+	int remainder;
+	int sector_quads_remaining;
+	int bug_present = 0;
+
+	/* Only want to apply fix to reads */
+	is_read = !(readl(core_base + DM_DBG1) & (ap->port_no ?
+			BIT(CORE_PORT1_DATA_DIR_BIT) : BIT(CORE_PORT0_DATA_DIR_BIT)));
+
+	/* Check for an incomplete transfer, i.e. not a multiple of 512 bytes
+	   transferred (datacount_port register counts quads transferred) */
+	quads_transferred =
+		readl(core_base + (ap->port_no ? DATACOUNT_PORT1 : DATACOUNT_PORT0));
+
+	remainder = quads_transferred & 0x7f;
+	sector_quads_remaining = remainder ? (0x80 - remainder): 0;
+
+	if (is_read && (sector_quads_remaining == 2)) {
+		bug_present = 1;
+	} else if (sector_quads_remaining) {
+		if (is_read) {
+			printk(KERN_WARNING "SATA read fixup cannot deal with %d quads remaining\n",
+				sector_quads_remaining);
+		} else {
+			printk(KERN_WARNING "SATA write fixup of %d quads remaining not supported\n",
+				sector_quads_remaining);
+		}
+	}
+
+	return bug_present;
+}
+
+/* This port done an interrupt */
+static void sata_oxnas_port_irq(struct ata_port* ap, int force_error)
+{
+	struct ata_queued_cmd* qc;
+	struct sata_oxnas_port_priv* pd = ap->private_data;
+	void __iomem *port_base = pd->port_base;
+
+	u32 int_status;
+	unsigned long flags = 0;
+
+	//DPRINTK("ENTER irqstatus %x\n", ioread32(port_base + INT_STATUS));
+/*
+	if (ap->qc_active & (1 << ATA_TAG_INTERNAL)) {
+			qc = ata_qc_from_tag(ap, ATA_TAG_INTERNAL);
+			DPRINTK("completing non-ncq cmd\n");
+
+			if (qc) {
+				ata_qc_complete(qc);
+			}
+			return;
+	}
+*/
+
+	qc = ata_qc_from_tag(ap, ap->link.active_tag);
+
+
+	/* record the port's interrupt */
+	int_status = ioread32(port_base + INT_STATUS);
+
+	/* If there's no command associated with this IRQ, ignore it. We may get
+	spurious interrupts when cleaning-up after a failed command, ignore these
+	too. */
+	if (likely(qc)) {
+		/* get the status before any error cleanup */
+		qc->err_mask = ac_err_mask(sata_oxnas_check_status(ap));
+		if (force_error) {
+			// Pretend there has been a link error
+			qc->err_mask |= AC_ERR_ATA_BUS;
+			DPRINTK(" ####force error####\n");
+		}
+		/* tell libata we're done */
+		local_irq_save(flags);
+		sata_oxnas_irq_clear(ap);
+		local_irq_restore(flags);
+		ata_qc_complete(qc);
+	} else {
+		VPRINTK("Ignoring interrupt, can't find the command tag= %d %08x\n",
+				ap->link.active_tag, ap->qc_active);
+	}
+
+	/* maybe a hotplug event */
+	if (unlikely(int_status & INT_LINK_SERROR)) {
+		u32 serror;
+
+		sata_oxnas_scr_read_port(ap, SCR_ERROR, &serror);
+		if(serror & (SERR_DEV_XCHG | SERR_PHYRDY_CHG)) {
+			ata_ehi_hotplugged(&ap->link.eh_info);
+			ata_port_freeze(ap);
+		}
+	}
+}
+
+/**
+ * irq_handler is the interrupt handling routine registered with the system,
+ * by libata.
+ */
+static irqreturn_t sata_oxnas_interrupt(int irq, void *dev_instance)
+{
+	struct ata_host *ah = dev_instance;
+	struct sata_oxnas_host_priv* hd = ah->private_data;
+	void __iomem *core_base = hd->core_base;
+
+	u32 int_status;
+	irqreturn_t ret = IRQ_NONE;
+	u32 port_no;
+	int bug_present;
+
+	/* loop until there are no more interrupts */
+	while ((int_status = ioread32(core_base + CORE_INT_STATUS)) & COREINT_END) {
+
+		/* clear any interrupt */
+		iowrite32(int_status, core_base + CORE_INT_CLEAR);
+
+		/* Only need this workaround for single disk systems as dual disk will
+		 use uCode which prevents this read underrun problem from occuring.
+		 All single disk systems will use port 0 */
+
+		for (port_no = 0; port_no < SATA_OXNAS_MAX_PORTS; ++port_no) {
+			/* check the raw end of command interrupt to see if the port is
+			done */
+			u32 mask = (CORERAW_HOST << port_no);
+			if (int_status & mask) {
+				/* this port had an interrupt, clear it */
+				iowrite32(mask, core_base + CORE_INT_CLEAR);
+				bug_present = ox820sata_bug_6320_workaround(ah->ports[port_no]);
+				sata_oxnas_port_irq(ah->ports[port_no], bug_present);
+				ret = IRQ_HANDLED;
+			}
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * scsi mid-layer and libata interface structures
+ */
+static struct scsi_host_template sata_oxnas_sht = {
+	ATA_NCQ_SHT("sata_oxnas"),
+	.can_queue = SATA_OXNAS_QUEUE_DEPTH,
+	.sg_tablesize = SATA_OXNAS_MAX_PRD,
+	.dma_boundary = ATA_DMA_BOUNDARY,
+	.unchecked_isa_dma  = 0,
+};
+
+
+static struct ata_port_operations sata_oxnas_ops = {
+	.inherits		= &sata_port_ops,
+	//.qc_new = sata_oxnas_qc_new,
+	//.qc_defer = ata_std_qc_defer,
+	.qc_prep = sata_oxnas_qc_prep,
+	.qc_issue = sata_oxnas_qc_issue,
+	.qc_fill_rtf = sata_oxnas_qc_fill_rtf,
+
+	.scr_read = sata_oxnas_scr_read,
+	.scr_write = sata_oxnas_scr_write,
+
+	//.freeze = sata_oxnas_freeze,
+	//.thaw = sata_oxnas_thaw,
+	.softreset = sata_oxnas_softreset,
+	//.hardreset = sata_oxnas_hardreset,
+	.postreset = sata_oxnas_postreset,
+	.error_handler = sata_oxnas_error_handler,
+	.post_internal_cmd = sata_oxnas_post_internal_cmd,
+
+	.port_start = sata_oxnas_port_start,
+	.port_stop = sata_oxnas_port_stop,
+
+	.host_stop = sata_oxnas_host_stop,
+	//.pmp_attach = sata_oxnas_pmp_attach,
+	//.pmp_detach = sata_oxnas_pmp_detach,
+	.sff_check_status = sata_oxnas_check_status,
+};
+
+static const struct ata_port_info sata_oxnas_port_info =
+{
+	 .flags = SATA_OXNAS_HOST_FLAGS,
+	 .pio_mask = ATA_PIO4,
+	 .udma_mask = ATA_UDMA6,
+	 .port_ops = &sata_oxnas_ops,
+ };
+
+static int sata_oxnas_probe(struct platform_device *ofdev)
+{
+	int retval = -ENXIO;
+	void __iomem *port_base = NULL;
+	void __iomem *sgdma_base = NULL;
+	void __iomem *core_base = NULL;
+	void __iomem *phy_base = NULL;
+	struct reset_control *rstc;
+
+	struct resource res = {};
+	struct sata_oxnas_host_priv *host_priv = NULL;
+	int irq = 0;
+	struct ata_host *host = NULL;
+	struct clk *clk = NULL;
+
+	const struct ata_port_info *ppi[] = { &sata_oxnas_port_info, NULL };
+
+	port_base = of_iomap(ofdev->dev.of_node, 0);
+	if (!port_base)
+		goto error_exit_with_cleanup;
+
+	sgdma_base = of_iomap(ofdev->dev.of_node, 1);
+	if (!sgdma_base)
+		goto error_exit_with_cleanup;
+
+	core_base = of_iomap(ofdev->dev.of_node, 2);
+	if (!core_base)
+		goto error_exit_with_cleanup;
+
+	phy_base = of_iomap(ofdev->dev.of_node, 3);
+	if (!phy_base)
+		goto error_exit_with_cleanup;
+
+	host_priv = devm_kzalloc(&ofdev->dev, sizeof(struct sata_oxnas_host_priv), GFP_KERNEL);
+	if (!host_priv)
+		goto error_exit_with_cleanup;
+
+	host_priv->port_base[0] = port_base;
+	host_priv->sgdma_base[0] = sgdma_base;
+	host_priv->core_base = core_base;
+	host_priv->phy_base = phy_base;
+
+	if(!of_address_to_resource(ofdev->dev.of_node, 4, &res)) {
+		host_priv->dma_base = res.start;
+		host_priv->dma_size = resource_size(&res);
+	}
+
+	irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);
+	if (!irq) {
+		dev_err(&ofdev->dev, "invalid irq from platform\n");
+		goto error_exit_with_cleanup;
+	}
+	host_priv->irq = irq;
+
+	clk = of_clk_get(ofdev->dev.of_node, 0);
+	if (IS_ERR(clk)) {
+		retval = PTR_ERR(clk);
+		clk = NULL;
+		goto error_exit_with_cleanup;
+	}
+	host_priv->clk = clk;
+
+	rstc = devm_reset_control_get(&ofdev->dev, "sata");
+	if (IS_ERR(rstc)) {
+		retval = PTR_ERR(rstc);
+		goto error_exit_with_cleanup;
+	}
+	host_priv->rst_sata = rstc;
+
+	rstc = devm_reset_control_get(&ofdev->dev, "link");
+	if (IS_ERR(rstc)) {
+		retval = PTR_ERR(rstc);
+		goto error_exit_with_cleanup;
+	}
+	host_priv->rst_link = rstc;
+
+	rstc = devm_reset_control_get(&ofdev->dev, "phy");
+	if (IS_ERR(rstc)) {
+		retval = PTR_ERR(rstc);
+		goto error_exit_with_cleanup;
+	}
+	host_priv->rst_phy = rstc;
+
+	/* allocate host structure */
+	host = ata_host_alloc_pinfo(&ofdev->dev, ppi, SATA_OXNAS_MAX_PORTS);
+	if (!host) {
+		retval = -ENOMEM;
+		goto error_exit_with_cleanup;
+	}
+	host->private_data = host_priv;
+	host->iomap = port_base;
+
+	/* initialize host controller */
+	retval = sata_oxnas_init_controller(host);
+	if(retval)
+		goto error_exit_with_cleanup;
+
+	/*
+	 * Now, register with libATA core, this will also initiate the
+	 * device discovery process, invoking our port_start() handler &
+	 * error_handler() to execute a dummy softreset EH session
+	 */
+	ata_host_activate(host, irq, sata_oxnas_interrupt, SATA_OXNAS_IRQ_FLAG,
+			  &sata_oxnas_sht);
+
+	return 0;
+
+error_exit_with_cleanup:
+	if (irq)
+		irq_dispose_mapping(host_priv->irq);
+	if (clk)
+		clk_put(clk);
+	if (host)
+		ata_host_detach(host);
+	if (port_base)
+		iounmap(port_base);
+	if (sgdma_base)
+		iounmap(sgdma_base);
+	if (core_base)
+		iounmap(core_base);
+	if (phy_base)
+		iounmap(phy_base);
+	return retval;
+}
+
+
+static int sata_oxnas_remove(struct platform_device *ofdev)
+{
+	struct ata_host *host = dev_get_drvdata(&ofdev->dev);
+	struct sata_oxnas_host_priv *host_priv = host->private_data;
+
+	ata_host_detach(host);
+
+	irq_dispose_mapping(host_priv->irq);
+	iounmap(host_priv->port_base);
+	iounmap(host_priv->sgdma_base);
+	iounmap(host_priv->core_base);
+
+	// reset Controller, Link and PHY
+	reset_control_assert(host_priv->rst_sata);
+	reset_control_assert(host_priv->rst_link);
+	reset_control_assert(host_priv->rst_phy);
+
+	// Disable the clock to the SATA block
+	clk_disable_unprepare(host_priv->clk);
+	clk_put(host_priv->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sata_oxnas_suspend(struct platform_device *op, pm_message_t state)
+{
+	struct ata_host *host = dev_get_drvdata(&op->dev);
+	return ata_host_suspend(host, state);
+}
+
+static int sata_oxnas_resume(struct platform_device *op)
+{
+	struct ata_host *host = dev_get_drvdata(&op->dev);
+	//struct sata_oxnas_host_priv *host_priv = host->private_data;
+	int ret;
+	struct ata_port *ap = host->ports[0];
+	//struct sata_oxnas_port_priv *pp = ap->private_data;
+
+	ret = sata_oxnas_init_controller(host);
+	if (ret) {
+		dev_err(&op->dev, "Error initializing hardware\n");
+		return ret;
+	}
+	ata_host_resume(host);
+	return 0;
+}
+#endif
+
+
+
+static struct of_device_id oxnas_sata_match[] = {
+	{
+		.compatible = "plxtech,nas782x-sata",
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, oxnas_sata_match);
+
+static struct platform_driver oxnas_sata_driver = {
+	.driver = {
+		.name = "oxnas-sata",
+		.owner = THIS_MODULE,
+		.of_match_table = oxnas_sata_match,
+	},
+	.probe		= sata_oxnas_probe,
+	.remove		= sata_oxnas_remove,
+#ifdef CONFIG_PM
+	.suspend	= sata_oxnas_suspend,
+	.resume		= sata_oxnas_resume,
+#endif
+};
+
+module_platform_driver(oxnas_sata_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("Oxford Semiconductor Ltd.");
+MODULE_DESCRIPTION("934 SATA core controler");
diff -Naur a/drivers/clk/clk-oxnas.c b/drivers/clk/clk-oxnas.c
--- a/drivers/clk/clk-oxnas.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/clk/clk-oxnas.c	2015-02-11 08:27:03.000000000 -0800
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2010 Broadcom
+ * Copyright (C) 2012 Stephen Warren
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/stringify.h>
+#include <linux/reset.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/utils.h>
+
+#define MHZ (1000 * 1000)
+
+static unsigned long plla_clk_recalc_rate(struct clk_hw *hw,
+	unsigned long parent_rate)
+{
+	unsigned long fin = parent_rate;
+	unsigned long pll0;
+	unsigned long fbdiv, refdiv, outdiv;
+
+	pll0 = readl_relaxed(SYS_CTRL_PLLA_CTRL0);
+	refdiv = (pll0 >> PLLA_REFDIV_SHIFT) & PLLA_REFDIV_MASK;
+	refdiv += 1;
+	outdiv = (pll0 >> PLLA_OUTDIV_SHIFT) & PLLA_OUTDIV_MASK;
+	outdiv += 1;
+	fbdiv = readl_relaxed(SYS_CTRL_PLLA_CTRL1);
+
+	/* seems we will not be here when pll is bypassed, so ignore this case */
+
+	return fin / MHZ * fbdiv / (refdiv * outdiv) / 32768 * MHZ;
+}
+
+static const char *pll_clk_parents[] = {
+	"oscillator",
+};
+
+static struct clk_ops plla_ops = {
+	.recalc_rate = plla_clk_recalc_rate,
+};
+
+static struct clk_init_data clk_plla_init = {
+	.name = "plla",
+	.ops = &plla_ops,
+	.parent_names = pll_clk_parents,
+	.num_parents = ARRAY_SIZE(pll_clk_parents),
+};
+
+static struct clk_hw plla_hw = {
+	.init = &clk_plla_init,
+};
+
+static struct device_node *node_pllb;
+
+int pllb_clk_enable(struct clk_hw *hw)
+{
+	struct reset_control *rstc;
+
+	rstc = of_reset_control_get(node_pllb, NULL);
+	if (IS_ERR(rstc))
+		return PTR_ERR(rstc);
+
+	/* put PLL into bypass */
+	oxnas_register_set_mask(SEC_CTRL_PLLB_CTRL0, BIT(PLLB_BYPASS));
+	wmb();
+	udelay(10);
+	reset_control_assert(rstc);
+	udelay(10);
+	// set PLL B control information
+	writel((1 << PLLB_ENSAT) | (1 << PLLB_OUTDIV) | (2 << PLLB_REFDIV),
+				SEC_CTRL_PLLB_CTRL0);
+	reset_control_deassert(rstc);
+	reset_control_put(rstc);
+	udelay(100);
+	oxnas_register_clear_mask(SEC_CTRL_PLLB_CTRL0, BIT(PLLB_BYPASS));
+
+	return 0;
+}
+
+void pllb_clk_disable(struct clk_hw *hw)
+{
+	struct reset_control *rstc;
+
+	/* put PLL into bypass */
+	oxnas_register_set_mask(SEC_CTRL_PLLB_CTRL0, BIT(PLLB_BYPASS));
+	wmb();
+	udelay(10);
+
+	rstc = of_reset_control_get(node_pllb, NULL);
+	if (!IS_ERR(rstc))
+		reset_control_assert(rstc);
+}
+
+static struct clk_ops pllb_ops = {
+	.enable = pllb_clk_enable,
+	.disable = pllb_clk_disable,
+};
+
+static struct clk_init_data clk_pllb_init = {
+	.name = "pllb",
+	.ops = &pllb_ops,
+	.parent_names = pll_clk_parents,
+	.num_parents = ARRAY_SIZE(pll_clk_parents),
+};
+
+static struct clk_hw pllb_hw = {
+	.init = &clk_pllb_init,
+};
+
+/* standard gate clock */
+struct clk_std {
+	struct clk_hw hw;
+	signed char bit;
+};
+
+#define NUM_STD_CLKS 17
+#define to_stdclk(_hw) container_of(_hw, struct clk_std, hw)
+
+static int std_clk_is_enabled(struct clk_hw *hw)
+{
+	struct clk_std *std = to_stdclk(hw);
+	return readl_relaxed(SYSCTRL_CLK_STAT) & BIT(std->bit);
+}
+
+static int std_clk_enable(struct clk_hw *hw)
+{
+	struct clk_std *std = to_stdclk(hw);
+	writel(BIT(std->bit), SYS_CTRL_CLK_SET_CTRL);
+	return 0;
+}
+
+static void std_clk_disable(struct clk_hw *hw)
+{
+	struct clk_std *std = to_stdclk(hw);
+	writel(BIT(std->bit), SYS_CTRL_CLK_CLR_CTRL);
+}
+
+static struct clk_ops std_clk_ops = {
+	.enable = std_clk_enable,
+	.disable = std_clk_disable,
+	.is_enabled = std_clk_is_enabled,
+};
+
+static const char *std_clk_parents[] = {
+	"oscillator",
+};
+
+static const char *eth_parents[] = {
+	"gmacclk",
+};
+
+#define DECLARE_STD_CLKP(__clk, __bit, __parent)	\
+static struct clk_init_data clk_##__clk##_init = {	\
+	.name = __stringify(__clk),			\
+	.ops = &std_clk_ops,				\
+	.parent_names = __parent,		\
+	.num_parents = ARRAY_SIZE(std_clk_parents),	\
+};							\
+							\
+static struct clk_std clk_##__clk = {			\
+	.bit = __bit,					\
+	.hw = {						\
+		.init = &clk_##__clk##_init,		\
+	},						\
+}
+
+#define DECLARE_STD_CLK(__clk, __bit) DECLARE_STD_CLKP(__clk, __bit, std_clk_parents)
+
+DECLARE_STD_CLK(leon, 0);
+DECLARE_STD_CLK(dma_sgdma, 1);
+DECLARE_STD_CLK(cipher, 2);
+DECLARE_STD_CLK(sd, 3);
+DECLARE_STD_CLK(sata, 4);
+DECLARE_STD_CLK(audio, 5);
+DECLARE_STD_CLK(usbmph, 6);
+DECLARE_STD_CLKP(etha, 7, eth_parents);
+DECLARE_STD_CLK(pciea, 8);
+DECLARE_STD_CLK(static, 9);
+DECLARE_STD_CLK(ethb, 10);
+DECLARE_STD_CLK(pcieb, 11);
+DECLARE_STD_CLK(ref600, 12);
+DECLARE_STD_CLK(usbdev, 13);
+
+struct clk_hw *std_clk_hw_tbl[] = {
+	&clk_leon.hw,
+	&clk_dma_sgdma.hw,
+	&clk_cipher.hw,
+	&clk_sd.hw,
+	&clk_sata.hw,
+	&clk_audio.hw,
+	&clk_usbmph.hw,
+	&clk_etha.hw,
+	&clk_pciea.hw,
+	&clk_static.hw,
+	&clk_ethb.hw,
+	&clk_pcieb.hw,
+	&clk_ref600.hw,
+	&clk_usbdev.hw,
+};
+
+struct clk *std_clk_tbl[ARRAY_SIZE(std_clk_hw_tbl)];
+
+static struct clk_onecell_data std_clk_data;
+
+void __init oxnas_init_stdclk(struct device_node *np)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(std_clk_hw_tbl); i++) {
+		std_clk_tbl[i] = clk_register(NULL, std_clk_hw_tbl[i]);
+		BUG_ON(IS_ERR(std_clk_tbl[i]));
+	}
+	std_clk_data.clks = std_clk_tbl;
+	std_clk_data.clk_num = ARRAY_SIZE(std_clk_tbl);
+	of_clk_add_provider(np, of_clk_src_onecell_get, &std_clk_data);
+}
+CLK_OF_DECLARE(oxnas_pllstd, "plxtech,nas782x-stdclk", oxnas_init_stdclk);
+
+void __init oxnas_init_plla(struct device_node *np)
+{
+	struct clk *clk;
+
+	clk = clk_register(NULL, &plla_hw);
+	BUG_ON(IS_ERR(clk));
+	/* mark it as enabled */
+	clk_prepare_enable(clk);
+	of_clk_add_provider(np, of_clk_src_simple_get, clk);
+}
+CLK_OF_DECLARE(oxnas_plla, "plxtech,nas782x-plla", oxnas_init_plla);
+
+void __init oxnas_init_pllb(struct device_node *np)
+{
+	struct clk *clk;
+
+	node_pllb = np;
+
+	clk = clk_register(NULL, &pllb_hw);
+	BUG_ON(IS_ERR(clk));
+	of_clk_add_provider(np, of_clk_src_simple_get, clk);
+}
+CLK_OF_DECLARE(oxnas_pllb, "plxtech,nas782x-pllb", oxnas_init_pllb);
diff -Naur a/drivers/clk/Makefile b/drivers/clk/Makefile
--- a/drivers/clk/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/clk/Makefile	2015-02-11 08:27:03.000000000 -0800
@@ -40,6 +40,7 @@
 obj-$(CONFIG_ARCH_VT8500)		+= clk-vt8500.o
 obj-$(CONFIG_COMMON_CLK_WM831X)		+= clk-wm831x.o
 obj-$(CONFIG_COMMON_CLK_XGENE)		+= clk-xgene.o
+obj-$(CONFIG_ARCH_OXNAS)		+= clk-oxnas.o
 obj-$(CONFIG_COMMON_CLK_AT91)		+= at91/
 obj-$(CONFIG_ARCH_BCM_MOBILE)		+= bcm/
 obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
@@ -68,3 +69,4 @@
 obj-$(CONFIG_COMMON_CLK_VERSATILE)	+= versatile/
 obj-$(CONFIG_X86)			+= x86/
 obj-$(CONFIG_ARCH_ZYNQ)			+= zynq/
+
diff -Naur a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
--- a/drivers/clocksource/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/clocksource/Kconfig	2015-02-11 08:27:03.000000000 -0800
@@ -223,4 +223,10 @@
 	  ARM Versatile, RealView and Versatile Express reference
 	  platforms.
 
+config CLKSRC_RPS_TIMER
+	def_bool y if ARCH_OXNAS
+	select CLKSRC_MMIO
+	help
+	  This option enables support for the oxnas rps timers.
+
 endmenu
diff -Naur a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
--- a/drivers/clocksource/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/clocksource/Makefile	2015-02-11 08:27:03.000000000 -0800
@@ -46,3 +46,5 @@
 obj-$(CONFIG_ARCH_HAS_TICK_BROADCAST)	+= dummy_timer.o
 obj-$(CONFIG_ARCH_KEYSTONE)		+= timer-keystone.o
 obj-$(CONFIG_CLKSRC_VERSATILE)		+= versatile.o
+obj-$(CONFIG_CLKSRC_RPS_TIMER)		+= oxnas_rps_timer.o
+
diff -Naur a/drivers/clocksource/oxnas_rps_timer.c b/drivers/clocksource/oxnas_rps_timer.c
--- a/drivers/clocksource/oxnas_rps_timer.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/clocksource/oxnas_rps_timer.c	2015-02-11 08:27:03.000000000 -0800
@@ -0,0 +1,96 @@
+/*
+ * arch/arm/mach-ox820/rps-time.c
+ *
+ * Copyright (C) 2009 Oxford Semiconductor Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/clockchips.h>
+#include <linux/clk.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/sched_clock.h>
+#include <mach/hardware.h>
+
+enum {
+	TIMER_LOAD = 0,
+	TIMER_CURR = 4,
+	TIMER_CTRL = 8,
+	TIMER_CLRINT = 0xC,
+
+	TIMER_BITS = 24,
+
+	TIMER_MAX_VAL = (1 << TIMER_BITS) - 1,
+
+	TIMER_PERIODIC = (1 << 6),
+	TIMER_ENABLE = (1 << 7),
+
+	TIMER_DIV1  = (0 << 2),
+	TIMER_DIV16  = (1 << 2),
+	TIMER_DIV256  = (2 << 2),
+
+	TIMER1_OFFSET = 0,
+	TIMER2_OFFSET = 0x20,
+
+};
+
+static u64 notrace rps_read_sched_clock(void)
+{
+        return (u64) ~readl_relaxed(RPSA_TIMER2_VAL);
+}
+
+static void __init rps_clocksource_init(void __iomem *base, ulong ref_rate)
+{
+	int ret;
+	ulong clock_rate;
+	/* use prescale 16 */
+	clock_rate = ref_rate / 16;
+
+	iowrite32(TIMER_MAX_VAL, base + TIMER_LOAD);
+	iowrite32(TIMER_PERIODIC | TIMER_ENABLE | TIMER_DIV16, base + TIMER_CTRL);
+
+	ret = clocksource_mmio_init(base + TIMER_CURR, "rps_clocksource_timer",
+					clock_rate, 250, TIMER_BITS,
+					clocksource_mmio_readl_down);
+	if (ret)
+		panic("can't register clocksource\n");
+
+	sched_clock_register(rps_read_sched_clock, TIMER_BITS, clock_rate);
+}
+
+static void __init rps_timer_init(struct device_node *np)
+{
+	struct clk *refclk;
+	unsigned long ref_rate;
+	void __iomem *base;
+
+	refclk = of_clk_get(np, 0);
+
+	if(IS_ERR(refclk) || clk_prepare_enable(refclk))
+		panic("rps_timer_init: failed to get refclk\n");
+	ref_rate = clk_get_rate(refclk);
+
+	base = of_iomap(np, 0);
+	if(!base)
+		panic("rps_timer_init: failed to map io\n");
+
+	rps_clocksource_init(base + TIMER2_OFFSET, ref_rate);
+}
+
+CLOCKSOURCE_OF_DECLARE(nas782x, "plxtech,nas782x-rps-timer", rps_timer_init);
diff -Naur a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
--- a/drivers/irqchip/irq-gic.c	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/irqchip/irq-gic.c	2015-02-11 08:27:03.000000000 -0800
@@ -1046,5 +1046,6 @@
 IRQCHIP_DECLARE(cortex_a7_gic, "arm,cortex-a7-gic", gic_of_init);
 IRQCHIP_DECLARE(msm_8660_qgic, "qcom,msm-8660-qgic", gic_of_init);
 IRQCHIP_DECLARE(msm_qgic2, "qcom,msm-qgic2", gic_of_init);
+IRQCHIP_DECLARE(arm11_mpcore_gic, "arm,arm11mp-gic", gic_of_init);
 
 #endif
diff -Naur a/drivers/irqchip/irq-rps.c b/drivers/irqchip/irq-rps.c
--- a/drivers/irqchip/irq-rps.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/irqchip/irq-rps.c	2015-02-11 08:27:03.000000000 -0800
@@ -0,0 +1,143 @@
+#include <linux/irqdomain.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/err.h>
+#include <asm/io.h>
+
+#include "irqchip.h"
+
+struct rps_chip_data {
+	void __iomem *base;
+	struct irq_chip chip;
+	struct irq_domain *domain;
+} rps_data;
+
+enum {
+	RPS_IRQ_BASE = 64,
+	RPS_IRQ_COUNT = 32,
+	PRS_HWIRQ_BASE = 0,
+
+	RPS_STATUS = 0,
+	RPS_RAW_STATUS = 4,
+	RPS_UNMASK = 8,
+	RPS_MASK = 0xc,
+};
+
+/*
+ * Routines to acknowledge, disable and enable interrupts
+ */
+static void rps_mask_irq(struct irq_data *d)
+{
+	struct rps_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	u32 mask = BIT(d->hwirq);
+	iowrite32(mask, chip_data->base + RPS_MASK);
+}
+
+static void rps_unmask_irq(struct irq_data *d)
+{
+	struct rps_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	u32 mask = BIT(d->hwirq);
+	iowrite32(mask, chip_data->base + RPS_UNMASK);
+}
+
+static struct irq_chip rps_chip = {
+	.name			= "RPS",
+	.irq_mask		= rps_mask_irq,
+	.irq_unmask		= rps_unmask_irq,
+};
+
+static int rps_irq_domain_xlate(struct irq_domain *d,
+				struct device_node *controller,
+				const u32 *intspec, unsigned int intsize,
+				unsigned long *out_hwirq, unsigned int *out_type)
+{
+	if (d->of_node != controller)
+		return -EINVAL;
+	if (intsize < 1)
+		return -EINVAL;
+
+	*out_hwirq = intspec[0];
+	/* Honestly I do not know the type */
+	*out_type = IRQ_TYPE_LEVEL_HIGH;
+
+	return 0;
+}
+
+static int rps_irq_domain_map(struct irq_domain *d, unsigned int irq,
+				irq_hw_number_t hw)
+{
+	irq_set_chip_and_handler(irq, &rps_chip, handle_level_irq);
+	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	irq_set_chip_data(irq, d->host_data);
+	return 0;
+}
+
+const struct irq_domain_ops rps_irq_domain_ops = {
+	.map = rps_irq_domain_map,
+	.xlate = rps_irq_domain_xlate,
+};
+
+static void rps_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
+{
+	struct rps_chip_data *chip_data = irq_get_handler_data(irq);
+	struct irq_chip *chip = irq_get_chip(irq);
+	unsigned int cascade_irq, rps_irq;
+	u32 status;
+
+	chained_irq_enter(chip, desc);
+
+	status = ioread32(chip_data->base + RPS_STATUS);
+	rps_irq = __ffs(status);
+	cascade_irq = irq_find_mapping(chip_data->domain, rps_irq);
+
+	if (unlikely(rps_irq >= RPS_IRQ_COUNT))
+		handle_bad_irq(cascade_irq, desc);
+	else
+		generic_handle_irq(cascade_irq);
+
+	chained_irq_exit(chip, desc);
+}
+
+#ifdef CONFIG_OF
+int __init rps_of_init(struct device_node *node, struct device_node *parent)
+{
+	void __iomem *rps_base;
+	int irq_start = RPS_IRQ_BASE;
+	int irq_base;
+	int irq;
+
+	if (WARN_ON(!node))
+		return -ENODEV;
+
+	rps_base = of_iomap(node, 0);
+	WARN(!rps_base, "unable to map rps registers\n");
+	rps_data.base = rps_base;
+
+	irq_base = irq_alloc_descs(irq_start, 0, RPS_IRQ_COUNT, numa_node_id());
+	if (IS_ERR_VALUE(irq_base)) {
+		WARN(1, "Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n",
+		     irq_start);
+		irq_base = irq_start;
+	}
+
+	rps_data.domain = irq_domain_add_legacy(node, RPS_IRQ_COUNT, irq_base,
+			PRS_HWIRQ_BASE, &rps_irq_domain_ops, &rps_data);
+
+	if (WARN_ON(!rps_data.domain))
+		return -ENOMEM;
+
+	if (parent) {
+		irq = irq_of_parse_and_map(node, 0);
+		if (irq_set_handler_data(irq, &rps_data) != 0)
+			BUG();
+		irq_set_chained_handler(irq, rps_handle_cascade_irq);
+	}
+	return 0;
+
+}
+
+IRQCHIP_DECLARE(nas782x, "plxtech,nas782x-rps", rps_of_init);
+#endif
diff -Naur a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
--- a/drivers/irqchip/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/irqchip/Kconfig	2015-02-11 08:27:03.000000000 -0800
@@ -15,6 +15,11 @@
 	select IRQ_DOMAIN
 	select MULTI_IRQ_HANDLER
 
+config PLXTECH_RPS
+	def_bool y if ARHC_OXNAS
+	depends on ARCH_OXNAS
+	select IRQ_DOMAIN
+
 config ARM_NVIC
 	bool
 	select IRQ_DOMAIN
diff -Naur a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
--- a/drivers/irqchip/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/irqchip/Makefile	2015-02-11 12:28:55.000000000 -0800
@@ -37,4 +37,5 @@
 obj-$(CONFIG_IRQ_CROSSBAR)		+= irq-crossbar.o
 obj-$(CONFIG_BRCMSTB_L2_IRQ)		+= irq-brcmstb-l2.o \
 					   irq-bcm7120-l2.o
++obj-$(CONFIG_PLXTECH_RPS)		+= irq-rps.o
 obj-$(CONFIG_KEYSTONE_IRQ)		+= irq-keystone.o
diff -Naur a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
--- a/drivers/mtd/nand/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/mtd/nand/Kconfig	2015-02-11 08:27:03.000000000 -0800
@@ -516,4 +516,12 @@
 	  Enables support for NAND Flash chips on Lantiq XWAY SoCs. NAND is attached
 	  to the External Bus Unit (EBU).
 
+config MTD_NAND_OXNAS
+	tristate "Support for NAND on Plxtech NAS782X SoC"
+	depends on ARCH_OXNAS
+	select MTD_NAND_PLATFORM
+	help
+	  Enables support for NAND Flash chips on Plxtech NAS782X SoCs. NAND is attached
+	  to the STATIC Unit.
+
 endif # MTD_NAND
diff -Naur a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
--- a/drivers/mtd/nand/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/mtd/nand/Makefile	2015-02-11 08:27:03.000000000 -0800
@@ -50,5 +50,6 @@
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
 obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
 obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
+obj-$(CONFIG_MTD_NAND_OXNAS)		+= oxnas_nand.o
 
 nand-objs := nand_base.o nand_bbt.o nand_timings.o
diff -Naur a/drivers/mtd/nand/oxnas_nand.c b/drivers/mtd/nand/oxnas_nand.c
--- a/drivers/mtd/nand/oxnas_nand.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/mtd/nand/oxnas_nand.c	2015-02-11 08:27:03.000000000 -0800
@@ -0,0 +1,102 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/mtd/nand.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <mach/utils.h>
+
+/* nand commands */
+#define NAND_CMD_ALE		BIT(18)
+#define NAND_CMD_CLE		BIT(19)
+#define NAND_CMD_CS		0
+#define NAND_CMD_RESET		0xff
+#define NAND_CMD		(NAND_CMD_CS | NAND_CMD_CLE)
+#define NAND_ADDR		(NAND_CMD_CS | NAND_CMD_ALE)
+#define NAND_DATA		(NAND_CMD_CS)
+
+static void oxnas_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		nandaddr &= ~(NAND_CMD | NAND_ADDR);
+		if (ctrl & NAND_CLE)
+			nandaddr |= NAND_CMD;
+		else if (ctrl & NAND_ALE)
+			nandaddr |= NAND_ADDR;
+		this->IO_ADDR_W = (void __iomem *) nandaddr;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, (void __iomem *) nandaddr);
+}
+
+static int oxnas_nand_probe(struct platform_device *pdev)
+{
+	/* enable clock and release static block reset */
+	struct clk *clk = of_clk_get(pdev->dev.of_node, 0);
+
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	clk_prepare_enable(clk);
+	device_reset(&pdev->dev);
+
+	return 0;
+}
+
+/* allow users to override the partition in DT using the cmdline */
+static const char *part_probes[] = { "cmdlinepart", "ofpart", NULL };
+
+static struct platform_nand_data oxnas_nand_data = {
+	.chip = {
+		.nr_chips		= 1,
+		.chip_delay		= 30,
+		.part_probe_types	= part_probes,
+	},
+	.ctrl = {
+		.probe		= oxnas_nand_probe,
+		.cmd_ctrl	= oxnas_cmd_ctrl,
+	}
+};
+
+/*
+ * Try to find the node inside the DT. If it is available attach out
+ * platform_nand_data
+ */
+static int __init oxnas_register_nand(void)
+{
+	struct device_node *node;
+	struct platform_device *pdev;
+
+	node = of_find_compatible_node(NULL, NULL, "plxtech,nand-nas782x");
+	if (!node)
+		return -ENOENT;
+	pdev = of_find_device_by_node(node);
+	if (!pdev)
+		return -EINVAL;
+	pdev->dev.platform_data = &oxnas_nand_data;
+	of_node_put(node);
+	return 0;
+}
+
+subsys_initcall(oxnas_register_nand);
+
+static const struct of_device_id oxnas_nand_ids[] = {
+	{ .compatible = "plxtech,nand-nas782x"},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, oxnas_nand_ids);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ma Haijun");
+MODULE_DESCRIPTION("NAND glue for Oxnas platforms");
+MODULE_ALIAS("platform:oxnas_nand");
diff -Naur a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
--- a/drivers/net/appletalk/ltpc.c	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/net/appletalk/ltpc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,1285 +0,0 @@
-/***    ltpc.c -- a driver for the LocalTalk PC card.
- *
- *      Copyright (c) 1995,1996 Bradford W. Johnson <johns393@maroon.tc.umn.edu>
- *
- *      This software may be used and distributed according to the terms
- *      of the GNU General Public License, incorporated herein by reference.
- *
- *      This is ALPHA code at best.  It may not work for you.  It may
- *      damage your equipment.  It may damage your relations with other
- *      users of your network.  Use it at your own risk!
- *
- *      Based in part on:
- *      skeleton.c      by Donald Becker
- *      dummy.c         by Nick Holloway and Alan Cox
- *      loopback.c      by Ross Biro, Fred van Kampen, Donald Becker
- *      the netatalk source code (UMICH)
- *      lots of work on the card...
- *
- *      I do not have access to the (proprietary) SDK that goes with the card.
- *      If you do, I don't want to know about it, and you can probably write
- *      a better driver yourself anyway.  This does mean that the pieces that
- *      talk to the card are guesswork on my part, so use at your own risk!
- *
- *      This is my first try at writing Linux networking code, and is also
- *      guesswork.  Again, use at your own risk!  (Although on this part, I'd
- *      welcome suggestions)
- *
- *      This is a loadable kernel module which seems to work at my site
- *      consisting of a 1.2.13 linux box running netatalk 1.3.3, and with
- *      the kernel support from 1.3.3b2 including patches routing.patch
- *      and ddp.disappears.from.chooser.  In order to run it, you will need
- *      to patch ddp.c and aarp.c in the kernel, but only a little...
- *
- *      I'm fairly confident that while this is arguably badly written, the
- *      problems that people experience will be "higher level", that is, with
- *      complications in the netatalk code.  The driver itself doesn't do
- *      anything terribly complicated -- it pretends to be an ether device
- *      as far as netatalk is concerned, strips the DDP data out of the ether
- *      frame and builds a LLAP packet to send out the card.  In the other
- *      direction, it receives LLAP frames from the card and builds a fake
- *      ether packet that it then tosses up to the networking code.  You can
- *      argue (correctly) that this is an ugly way to do things, but it
- *      requires a minimal amount of fooling with the code in ddp.c and aarp.c.
- *
- *      The card will do a lot more than is used here -- I *think* it has the
- *      layers up through ATP.  Even if you knew how that part works (which I
- *      don't) it would be a big job to carve up the kernel ddp code to insert
- *      things at a higher level, and probably a bad idea...
- *
- *      There are a number of other cards that do LocalTalk on the PC.  If
- *      nobody finds any insurmountable (at the netatalk level) problems
- *      here, this driver should encourage people to put some work into the
- *      other cards (some of which I gather are still commercially available)
- *      and also to put hooks for LocalTalk into the official ddp code.
- *
- *      I welcome comments and suggestions.  This is my first try at Linux
- *      networking stuff, and there are probably lots of things that I did
- *      suboptimally.  
- *
- ***/
-
-/***
- *
- * $Log: ltpc.c,v $
- * Revision 1.1.2.1  2000/03/01 05:35:07  jgarzik
- * at and tr cleanup
- *
- * Revision 1.8  1997/01/28 05:44:54  bradford
- * Clean up for non-module a little.
- * Hacked about a bit to clean things up - Alan Cox 
- * Probably broken it from the origina 1.8
- *
-
- * 1998/11/09: David Huggins-Daines <dhd@debian.org>
- * Cleaned up the initialization code to use the standard autoirq methods,
-   and to probe for things in the standard order of i/o, irq, dma.  This
-   removes the "reset the reset" hack, because I couldn't figure out an
-   easy way to get the card to trigger an interrupt after it.
- * Added support for passing configuration parameters on the kernel command
-   line and through insmod
- * Changed the device name from "ltalk0" to "lt0", both to conform with the
-   other localtalk driver, and to clear up the inconsistency between the
-   module and the non-module versions of the driver :-)
- * Added a bunch of comments (I was going to make some enums for the state
-   codes and the register offsets, but I'm still not sure exactly what their
-   semantics are)
- * Don't poll anymore in interrupt-driven mode
- * It seems to work as a module now (as of 2.1.127), but I don't think
-   I'm responsible for that...
-
- *
- * Revision 1.7  1996/12/12 03:42:33  bradford
- * DMA alloc cribbed from 3c505.c.
- *
- * Revision 1.6  1996/12/12 03:18:58  bradford
- * Added virt_to_bus; works in 2.1.13.
- *
- * Revision 1.5  1996/12/12 03:13:22  root
- * xmitQel initialization -- think through better though.
- *
- * Revision 1.4  1996/06/18 14:55:55  root
- * Change names to ltpc. Tabs. Took a shot at dma alloc,
- * although more needs to be done eventually.
- *
- * Revision 1.3  1996/05/22 14:59:39  root
- * Change dev->open, dev->close to track dummy.c in 1.99.(around 7)
- *
- * Revision 1.2  1996/05/22 14:58:24  root
- * Change tabs mostly.
- *
- * Revision 1.1  1996/04/23 04:45:09  root
- * Initial revision
- *
- * Revision 0.16  1996/03/05 15:59:56  root
- * Change ARPHRD_LOCALTLK definition to the "real" one.
- *
- * Revision 0.15  1996/03/05 06:28:30  root
- * Changes for kernel 1.3.70.  Still need a few patches to kernel, but
- * it's getting closer.
- *
- * Revision 0.14  1996/02/25 17:38:32  root
- * More cleanups.  Removed query to card on get_stats.
- *
- * Revision 0.13  1996/02/21  16:27:40  root
- * Refix debug_print_skb.  Fix mac.raw gotcha that appeared in 1.3.65.
- * Clean up receive code a little.
- *
- * Revision 0.12  1996/02/19  16:34:53  root
- * Fix debug_print_skb.  Kludge outgoing snet to 0 when using startup
- * range.  Change debug to mask: 1 for verbose, 2 for higher level stuff
- * including packet printing, 4 for lower level (card i/o) stuff.
- *
- * Revision 0.11  1996/02/12  15:53:38  root
- * Added router sends (requires new aarp.c patch)
- *
- * Revision 0.10  1996/02/11  00:19:35  root
- * Change source LTALK_LOGGING debug switch to insmod ... debug=2.
- *
- * Revision 0.9  1996/02/10  23:59:35  root
- * Fixed those fixes for 1.2 -- DANGER!  The at.h that comes with netatalk
- * has a *different* definition of struct sockaddr_at than the Linux kernel
- * does.  This is an "insidious and invidious" bug...
- * (Actually the preceding comment is false -- it's the atalk.h in the
- * ancient atalk-0.06 that's the problem)
- *
- * Revision 0.8  1996/02/10 19:09:00  root
- * Merge 1.3 changes.  Tested OK under 1.3.60.
- *
- * Revision 0.7  1996/02/10 17:56:56  root
- * Added debug=1 parameter on insmod for debugging prints.  Tried
- * to fix timer unload on rmmod, but I don't think that's the problem.
- *
- * Revision 0.6  1995/12/31  19:01:09  root
- * Clean up rmmod, irq comments per feedback from Corin Anderson (Thanks Corey!)
- * Clean up initial probing -- sometimes the card wakes up latched in reset.
- *
- * Revision 0.5  1995/12/22  06:03:44  root
- * Added comments in front and cleaned up a bit.
- * This version sent out to people.
- *
- * Revision 0.4  1995/12/18  03:46:44  root
- * Return shortDDP to longDDP fake to 0/0.  Added command structs.
- *
- ***/
-
-/* ltpc jumpers are:
-*
-*	Interrupts -- set at most one.  If none are set, the driver uses
-*	polled mode.  Because the card was developed in the XT era, the
-*	original documentation refers to IRQ2.  Since you'll be running
-*	this on an AT (or later) class machine, that really means IRQ9.
-*
-*	SW1	IRQ 4
-*	SW2	IRQ 3
-*	SW3	IRQ 9 (2 in original card documentation only applies to XT)
-*
-*
-*	DMA -- choose DMA 1 or 3, and set both corresponding switches.
-*
-*	SW4	DMA 3
-*	SW5	DMA 1
-*	SW6	DMA 3
-*	SW7	DMA 1
-*
-*
-*	I/O address -- choose one.  
-*
-*	SW8	220 / 240
-*/
-
-/*	To have some stuff logged, do 
-*	insmod ltpc.o debug=1
-*
-*	For a whole bunch of stuff, use higher numbers.
-*
-*	The default is 0, i.e. no messages except for the probe results.
-*/
-
-/* insmod-tweakable variables */
-static int debug;
-#define DEBUG_VERBOSE 1
-#define DEBUG_UPPER 2
-#define DEBUG_LOWER 4
-
-static int io;
-static int irq;
-static int dma;
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/interrupt.h>
-#include <linux/ptrace.h>
-#include <linux/ioport.h>
-#include <linux/spinlock.h>
-#include <linux/in.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/if_arp.h>
-#include <linux/if_ltalk.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/atalk.h>
-#include <linux/bitops.h>
-#include <linux/gfp.h>
-
-#include <asm/dma.h>
-#include <asm/io.h>
-
-/* our stuff */
-#include "ltpc.h"
-
-static DEFINE_SPINLOCK(txqueue_lock);
-static DEFINE_SPINLOCK(mbox_lock);
-
-/* function prototypes */
-static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
-	void *dbuf, int dbuflen);
-static int sendup_buffer (struct net_device *dev);
-
-/* Dma Memory related stuff, cribbed directly from 3c505.c */
-
-static unsigned long dma_mem_alloc(int size)
-{
-        int order = get_order(size);
-
-        return __get_dma_pages(GFP_KERNEL, order);
-}
-
-/* DMA data buffer, DMA command buffer */
-static unsigned char *ltdmabuf;
-static unsigned char *ltdmacbuf;
-
-/* private struct, holds our appletalk address */
-
-struct ltpc_private
-{
-	struct atalk_addr my_addr;
-};
-
-/* transmit queue element struct */
-
-struct xmitQel {
-	struct xmitQel *next;
-	/* command buffer */
-	unsigned char *cbuf;
-	short cbuflen;
-	/* data buffer */
-	unsigned char *dbuf;
-	short dbuflen;
-	unsigned char QWrite;	/* read or write data */
-	unsigned char mailbox;
-};
-
-/* the transmit queue itself */
-
-static struct xmitQel *xmQhd, *xmQtl;
-
-static void enQ(struct xmitQel *qel)
-{
-	unsigned long flags;
-	qel->next = NULL;
-	
-	spin_lock_irqsave(&txqueue_lock, flags);
-	if (xmQtl) {
-		xmQtl->next = qel;
-	} else {
-		xmQhd = qel;
-	}
-	xmQtl = qel;
-	spin_unlock_irqrestore(&txqueue_lock, flags);
-
-	if (debug & DEBUG_LOWER)
-		printk("enqueued a 0x%02x command\n",qel->cbuf[0]);
-}
-
-static struct xmitQel *deQ(void)
-{
-	unsigned long flags;
-	int i;
-	struct xmitQel *qel=NULL;
-	
-	spin_lock_irqsave(&txqueue_lock, flags);
-	if (xmQhd) {
-		qel = xmQhd;
-		xmQhd = qel->next;
-		if(!xmQhd) xmQtl = NULL;
-	}
-	spin_unlock_irqrestore(&txqueue_lock, flags);
-
-	if ((debug & DEBUG_LOWER) && qel) {
-		int n;
-		printk(KERN_DEBUG "ltpc: dequeued command ");
-		n = qel->cbuflen;
-		if (n>100) n=100;
-		for(i=0;i<n;i++) printk("%02x ",qel->cbuf[i]);
-		printk("\n");
-	}
-
-	return qel;
-}
-
-/* and... the queue elements we'll be using */
-static struct xmitQel qels[16];
-
-/* and their corresponding mailboxes */
-static unsigned char mailbox[16];
-static unsigned char mboxinuse[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
-
-static int wait_timeout(struct net_device *dev, int c)
-{
-	/* returns true if it stayed c */
-	/* this uses base+6, but it's ok */
-	int i;
-
-	/* twenty second or so total */
-
-	for(i=0;i<200000;i++) {
-		if ( c != inb_p(dev->base_addr+6) ) return 0;
-		udelay(100);
-	}
-	return 1; /* timed out */
-}
-
-/* get the first free mailbox */
-
-static int getmbox(void)
-{
-	unsigned long flags;
-	int i;
-
-	spin_lock_irqsave(&mbox_lock, flags);
-	for(i=1;i<16;i++) if(!mboxinuse[i]) {
-		mboxinuse[i]=1;
-		spin_unlock_irqrestore(&mbox_lock, flags);
-		return i;
-	}
-	spin_unlock_irqrestore(&mbox_lock, flags);
-	return 0;
-}
-
-/* read a command from the card */
-static void handlefc(struct net_device *dev)
-{
-	/* called *only* from idle, non-reentrant */
-	int dma = dev->dma;
-	int base = dev->base_addr;
-	unsigned long flags;
-
-
-	flags=claim_dma_lock();
-	disable_dma(dma);
-	clear_dma_ff(dma);
-	set_dma_mode(dma,DMA_MODE_READ);
-	set_dma_addr(dma,virt_to_bus(ltdmacbuf));
-	set_dma_count(dma,50);
-	enable_dma(dma);
-	release_dma_lock(flags);
-
-	inb_p(base+3);
-	inb_p(base+2);
-
-	if ( wait_timeout(dev,0xfc) ) printk("timed out in handlefc\n");
-}
-
-/* read data from the card */
-static void handlefd(struct net_device *dev)
-{
-	int dma = dev->dma;
-	int base = dev->base_addr;
-	unsigned long flags;
-
-	flags=claim_dma_lock();
-	disable_dma(dma);
-	clear_dma_ff(dma);
-	set_dma_mode(dma,DMA_MODE_READ);
-	set_dma_addr(dma,virt_to_bus(ltdmabuf));
-	set_dma_count(dma,800);
-	enable_dma(dma);
-	release_dma_lock(flags);
-
-	inb_p(base+3);
-	inb_p(base+2);
-
-	if ( wait_timeout(dev,0xfd) ) printk("timed out in handlefd\n");
-	sendup_buffer(dev);
-} 
-
-static void handlewrite(struct net_device *dev)
-{
-	/* called *only* from idle, non-reentrant */
-	/* on entry, 0xfb and ltdmabuf holds data */
-	int dma = dev->dma;
-	int base = dev->base_addr;
-	unsigned long flags;
-	
-	flags=claim_dma_lock();
-	disable_dma(dma);
-	clear_dma_ff(dma);
-	set_dma_mode(dma,DMA_MODE_WRITE);
-	set_dma_addr(dma,virt_to_bus(ltdmabuf));
-	set_dma_count(dma,800);
-	enable_dma(dma);
-	release_dma_lock(flags);
-	
-	inb_p(base+3);
-	inb_p(base+2);
-
-	if ( wait_timeout(dev,0xfb) ) {
-		flags=claim_dma_lock();
-		printk("timed out in handlewrite, dma res %d\n",
-			get_dma_residue(dev->dma) );
-		release_dma_lock(flags);
-	}
-}
-
-static void handleread(struct net_device *dev)
-{
-	/* on entry, 0xfb */
-	/* on exit, ltdmabuf holds data */
-	int dma = dev->dma;
-	int base = dev->base_addr;
-	unsigned long flags;
-
-	
-	flags=claim_dma_lock();
-	disable_dma(dma);
-	clear_dma_ff(dma);
-	set_dma_mode(dma,DMA_MODE_READ);
-	set_dma_addr(dma,virt_to_bus(ltdmabuf));
-	set_dma_count(dma,800);
-	enable_dma(dma);
-	release_dma_lock(flags);
-
-	inb_p(base+3);
-	inb_p(base+2);
-	if ( wait_timeout(dev,0xfb) ) printk("timed out in handleread\n");
-}
-
-static void handlecommand(struct net_device *dev)
-{
-	/* on entry, 0xfa and ltdmacbuf holds command */
-	int dma = dev->dma;
-	int base = dev->base_addr;
-	unsigned long flags;
-
-	flags=claim_dma_lock();
-	disable_dma(dma);
-	clear_dma_ff(dma);
-	set_dma_mode(dma,DMA_MODE_WRITE);
-	set_dma_addr(dma,virt_to_bus(ltdmacbuf));
-	set_dma_count(dma,50);
-	enable_dma(dma);
-	release_dma_lock(flags);
-	inb_p(base+3);
-	inb_p(base+2);
-	if ( wait_timeout(dev,0xfa) ) printk("timed out in handlecommand\n");
-} 
-
-/* ready made command for getting the result from the card */
-static unsigned char rescbuf[2] = {LT_GETRESULT,0};
-static unsigned char resdbuf[2];
-
-static int QInIdle;
-
-/* idle expects to be called with the IRQ line high -- either because of
- * an interrupt, or because the line is tri-stated
- */
-
-static void idle(struct net_device *dev)
-{
-	unsigned long flags;
-	int state;
-	/* FIXME This is initialized to shut the warning up, but I need to
-	 * think this through again.
-	 */
-	struct xmitQel *q = NULL;
-	int oops;
-	int i;
-	int base = dev->base_addr;
-
-	spin_lock_irqsave(&txqueue_lock, flags);
-	if(QInIdle) {
-		spin_unlock_irqrestore(&txqueue_lock, flags);
-		return;
-	}
-	QInIdle = 1;
-	spin_unlock_irqrestore(&txqueue_lock, flags);
-
-	/* this tri-states the IRQ line */
-	(void) inb_p(base+6);
-
-	oops = 100;
-
-loop:
-	if (0>oops--) { 
-		printk("idle: looped too many times\n");
-		goto done;
-	}
-
-	state = inb_p(base+6);
-	if (state != inb_p(base+6)) goto loop;
-
-	switch(state) {
-		case 0xfc:
-			/* incoming command */
-			if (debug & DEBUG_LOWER) printk("idle: fc\n");
-			handlefc(dev); 
-			break;
-		case 0xfd:
-			/* incoming data */
-			if(debug & DEBUG_LOWER) printk("idle: fd\n");
-			handlefd(dev); 
-			break;
-		case 0xf9:
-			/* result ready */
-			if (debug & DEBUG_LOWER) printk("idle: f9\n");
-			if(!mboxinuse[0]) {
-				mboxinuse[0] = 1;
-				qels[0].cbuf = rescbuf;
-				qels[0].cbuflen = 2;
-				qels[0].dbuf = resdbuf;
-				qels[0].dbuflen = 2;
-				qels[0].QWrite = 0;
-				qels[0].mailbox = 0;
-				enQ(&qels[0]);
-			}
-			inb_p(dev->base_addr+1);
-			inb_p(dev->base_addr+0);
-			if( wait_timeout(dev,0xf9) )
-				printk("timed out idle f9\n");
-			break;
-		case 0xf8:
-			/* ?? */
-			if (xmQhd) {
-				inb_p(dev->base_addr+1);
-				inb_p(dev->base_addr+0);
-				if(wait_timeout(dev,0xf8) )
-					printk("timed out idle f8\n");
-			} else {
-				goto done;
-			}
-			break;
-		case 0xfa:
-			/* waiting for command */
-			if(debug & DEBUG_LOWER) printk("idle: fa\n");
-			if (xmQhd) {
-				q=deQ();
-				memcpy(ltdmacbuf,q->cbuf,q->cbuflen);
-				ltdmacbuf[1] = q->mailbox;
-				if (debug>1) { 
-					int n;
-					printk("ltpc: sent command     ");
-					n = q->cbuflen;
-					if (n>100) n=100;
-					for(i=0;i<n;i++)
-						printk("%02x ",ltdmacbuf[i]);
-					printk("\n");
-				}
-				handlecommand(dev);
-					if(0xfa==inb_p(base+6)) {
-						/* we timed out, so return */
-						goto done;
-					} 
-			} else {
-				/* we don't seem to have a command */
-				if (!mboxinuse[0]) {
-					mboxinuse[0] = 1;
-					qels[0].cbuf = rescbuf;
-					qels[0].cbuflen = 2;
-					qels[0].dbuf = resdbuf;
-					qels[0].dbuflen = 2;
-					qels[0].QWrite = 0;
-					qels[0].mailbox = 0;
-					enQ(&qels[0]);
-				} else {
-					printk("trouble: response command already queued\n");
-					goto done;
-				}
-			} 
-			break;
-		case 0Xfb:
-			/* data transfer ready */
-			if(debug & DEBUG_LOWER) printk("idle: fb\n");
-			if(q->QWrite) {
-				memcpy(ltdmabuf,q->dbuf,q->dbuflen);
-				handlewrite(dev);
-			} else {
-				handleread(dev);
-				/* non-zero mailbox numbers are for
-				   commmands, 0 is for GETRESULT
-				   requests */
-				if(q->mailbox) {
-					memcpy(q->dbuf,ltdmabuf,q->dbuflen);
-				} else { 
-					/* this was a result */
-					mailbox[ 0x0f & ltdmabuf[0] ] = ltdmabuf[1];
-					mboxinuse[0]=0;
-				}
-			}
-			break;
-	}
-	goto loop;
-
-done:
-	QInIdle=0;
-
-	/* now set the interrupts back as appropriate */
-	/* the first read takes it out of tri-state (but still high) */
-	/* the second resets it */
-	/* note that after this point, any read of base+6 will
-	   trigger an interrupt */
-
-	if (dev->irq) {
-		inb_p(base+7);
-		inb_p(base+7);
-	}
-}
-
-
-static int do_write(struct net_device *dev, void *cbuf, int cbuflen,
-	void *dbuf, int dbuflen)
-{
-
-	int i = getmbox();
-	int ret;
-
-	if(i) {
-		qels[i].cbuf = cbuf;
-		qels[i].cbuflen = cbuflen;
-		qels[i].dbuf = dbuf;
-		qels[i].dbuflen = dbuflen;
-		qels[i].QWrite = 1;
-		qels[i].mailbox = i;  /* this should be initted rather */
-		enQ(&qels[i]);
-		idle(dev);
-		ret = mailbox[i];
-		mboxinuse[i]=0;
-		return ret;
-	}
-	printk("ltpc: could not allocate mbox\n");
-	return -1;
-}
-
-static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
-	void *dbuf, int dbuflen)
-{
-
-	int i = getmbox();
-	int ret;
-
-	if(i) {
-		qels[i].cbuf = cbuf;
-		qels[i].cbuflen = cbuflen;
-		qels[i].dbuf = dbuf;
-		qels[i].dbuflen = dbuflen;
-		qels[i].QWrite = 0;
-		qels[i].mailbox = i;  /* this should be initted rather */
-		enQ(&qels[i]);
-		idle(dev);
-		ret = mailbox[i];
-		mboxinuse[i]=0;
-		return ret;
-	}
-	printk("ltpc: could not allocate mbox\n");
-	return -1;
-}
-
-/* end of idle handlers -- what should be seen is do_read, do_write */
-
-static struct timer_list ltpc_timer;
-
-static netdev_tx_t ltpc_xmit(struct sk_buff *skb, struct net_device *dev);
-
-static int read_30 ( struct net_device *dev)
-{
-	lt_command c;
-	c.getflags.command = LT_GETFLAGS;
-	return do_read(dev, &c, sizeof(c.getflags),&c,0);
-}
-
-static int set_30 (struct net_device *dev,int x)
-{
-	lt_command c;
-	c.setflags.command = LT_SETFLAGS;
-	c.setflags.flags = x;
-	return do_write(dev, &c, sizeof(c.setflags),&c,0);
-}
-
-/* LLAP to DDP translation */
-
-static int sendup_buffer (struct net_device *dev)
-{
-	/* on entry, command is in ltdmacbuf, data in ltdmabuf */
-	/* called from idle, non-reentrant */
-
-	int dnode, snode, llaptype, len; 
-	int sklen;
-	struct sk_buff *skb;
-	struct lt_rcvlap *ltc = (struct lt_rcvlap *) ltdmacbuf;
-
-	if (ltc->command != LT_RCVLAP) {
-		printk("unknown command 0x%02x from ltpc card\n",ltc->command);
-		return -1;
-	}
-	dnode = ltc->dnode;
-	snode = ltc->snode;
-	llaptype = ltc->laptype;
-	len = ltc->length; 
-
-	sklen = len;
-	if (llaptype == 1) 
-		sklen += 8;  /* correct for short ddp */
-	if(sklen > 800) {
-		printk(KERN_INFO "%s: nonsense length in ltpc command 0x14: 0x%08x\n",
-			dev->name,sklen);
-		return -1;
-	}
-
-	if ( (llaptype==0) || (llaptype>2) ) {
-		printk(KERN_INFO "%s: unknown LLAP type: %d\n",dev->name,llaptype);
-		return -1;
-	}
-
-
-	skb = dev_alloc_skb(3+sklen);
-	if (skb == NULL) 
-	{
-		printk("%s: dropping packet due to memory squeeze.\n",
-			dev->name);
-		return -1;
-	}
-	skb->dev = dev;
-
-	if (sklen > len)
-		skb_reserve(skb,8);
-	skb_put(skb,len+3);
-	skb->protocol = htons(ETH_P_LOCALTALK);
-	/* add LLAP header */
-	skb->data[0] = dnode;
-	skb->data[1] = snode;
-	skb->data[2] = llaptype;
-	skb_reset_mac_header(skb);	/* save pointer to llap header */
-	skb_pull(skb,3);
-
-	/* copy ddp(s,e)hdr + contents */
-	skb_copy_to_linear_data(skb, ltdmabuf, len);
-
-	skb_reset_transport_header(skb);
-
-	dev->stats.rx_packets++;
-	dev->stats.rx_bytes += skb->len;
-
-	/* toss it onwards */
-	netif_rx(skb);
-	return 0;
-}
-
-/* the handler for the board interrupt */
- 
-static irqreturn_t
-ltpc_interrupt(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-
-	if (dev==NULL) {
-		printk("ltpc_interrupt: unknown device.\n");
-		return IRQ_NONE;
-	}
-
-	inb_p(dev->base_addr+6);  /* disable further interrupts from board */
-
-	idle(dev); /* handle whatever is coming in */
- 
-	/* idle re-enables interrupts from board */ 
-
-	return IRQ_HANDLED;
-}
-
-/***
- *
- *    The ioctls that the driver responds to are:
- *
- *    SIOCSIFADDR -- do probe using the passed node hint.
- *    SIOCGIFADDR -- return net, node.
- *
- *    some of this stuff should be done elsewhere.
- *
- ***/
-
-static int ltpc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-	struct sockaddr_at *sa = (struct sockaddr_at *) &ifr->ifr_addr;
-	/* we'll keep the localtalk node address in dev->pa_addr */
-	struct ltpc_private *ltpc_priv = netdev_priv(dev);
-	struct atalk_addr *aa = &ltpc_priv->my_addr;
-	struct lt_init c;
-	int ltflags;
-
-	if(debug & DEBUG_VERBOSE) printk("ltpc_ioctl called\n");
-
-	switch(cmd) {
-		case SIOCSIFADDR:
-
-			aa->s_net  = sa->sat_addr.s_net;
-      
-			/* this does the probe and returns the node addr */
-			c.command = LT_INIT;
-			c.hint = sa->sat_addr.s_node;
-
-			aa->s_node = do_read(dev,&c,sizeof(c),&c,0);
-
-			/* get all llap frames raw */
-			ltflags = read_30(dev);
-			ltflags |= LT_FLAG_ALLLAP;
-			set_30 (dev,ltflags);  
-
-			dev->broadcast[0] = 0xFF;
-			dev->dev_addr[0] = aa->s_node;
-
-			dev->addr_len=1;
-   
-			return 0;
-
-		case SIOCGIFADDR:
-
-			sa->sat_addr.s_net = aa->s_net;
-			sa->sat_addr.s_node = aa->s_node;
-
-			return 0;
-
-		default: 
-			return -EINVAL;
-	}
-}
-
-static void set_multicast_list(struct net_device *dev)
-{
-	/* This needs to be present to keep netatalk happy. */
-	/* Actually netatalk needs fixing! */
-}
-
-static int ltpc_poll_counter;
-
-static void ltpc_poll(unsigned long l)
-{
-	struct net_device *dev = (struct net_device *) l;
-
-	del_timer(&ltpc_timer);
-
-	if(debug & DEBUG_VERBOSE) {
-		if (!ltpc_poll_counter) {
-			ltpc_poll_counter = 50;
-			printk("ltpc poll is alive\n");
-		}
-		ltpc_poll_counter--;
-	}
-  
-	if (!dev)
-		return;  /* we've been downed */
-
-	/* poll 20 times per second */
-	idle(dev);
-	ltpc_timer.expires = jiffies + HZ/20;
-	
-	add_timer(&ltpc_timer);
-}
-
-/* DDP to LLAP translation */
-
-static netdev_tx_t ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	/* in kernel 1.3.xx, on entry skb->data points to ddp header,
-	 * and skb->len is the length of the ddp data + ddp header
-	 */
-	int i;
-	struct lt_sendlap cbuf;
-	unsigned char *hdr;
-
-	cbuf.command = LT_SENDLAP;
-	cbuf.dnode = skb->data[0];
-	cbuf.laptype = skb->data[2];
-	skb_pull(skb,3);	/* skip past LLAP header */
-	cbuf.length = skb->len;	/* this is host order */
-	skb_reset_transport_header(skb);
-
-	if(debug & DEBUG_UPPER) {
-		printk("command ");
-		for(i=0;i<6;i++)
-			printk("%02x ",((unsigned char *)&cbuf)[i]);
-		printk("\n");
-	}
-
-	hdr = skb_transport_header(skb);
-	do_write(dev, &cbuf, sizeof(cbuf), hdr, skb->len);
-
-	if(debug & DEBUG_UPPER) {
-		printk("sent %d ddp bytes\n",skb->len);
-		for (i = 0; i < skb->len; i++)
-			printk("%02x ", hdr[i]);
-		printk("\n");
-	}
-
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
-
-	dev_kfree_skb(skb);
-	return NETDEV_TX_OK;
-}
-
-/* initialization stuff */
-  
-static int __init ltpc_probe_dma(int base, int dma)
-{
-	int want = (dma == 3) ? 2 : (dma == 1) ? 1 : 3;
-  	unsigned long timeout;
-  	unsigned long f;
-  
-  	if (want & 1) {
-		if (request_dma(1,"ltpc")) {
-			want &= ~1;
-		} else {
-			f=claim_dma_lock();
-			disable_dma(1);
-			clear_dma_ff(1);
-			set_dma_mode(1,DMA_MODE_WRITE);
-			set_dma_addr(1,virt_to_bus(ltdmabuf));
-			set_dma_count(1,sizeof(struct lt_mem));
-			enable_dma(1);
-			release_dma_lock(f);
-		}
-	}
-	if (want & 2) {
-		if (request_dma(3,"ltpc")) {
-			want &= ~2;
-		} else {
-			f=claim_dma_lock();
-			disable_dma(3);
-			clear_dma_ff(3);
-			set_dma_mode(3,DMA_MODE_WRITE);
-			set_dma_addr(3,virt_to_bus(ltdmabuf));
-			set_dma_count(3,sizeof(struct lt_mem));
-			enable_dma(3);
-			release_dma_lock(f);
-		}
-	}
-	/* set up request */
-
-	/* FIXME -- do timings better! */
-
-	ltdmabuf[0] = LT_READMEM;
-	ltdmabuf[1] = 1;  /* mailbox */
-	ltdmabuf[2] = 0; ltdmabuf[3] = 0;  /* address */
-	ltdmabuf[4] = 0; ltdmabuf[5] = 1;  /* read 0x0100 bytes */
-	ltdmabuf[6] = 0; /* dunno if this is necessary */
-
-	inb_p(io+1);
-	inb_p(io+0);
-	timeout = jiffies+100*HZ/100;
-	while(time_before(jiffies, timeout)) {
-		if ( 0xfa == inb_p(io+6) ) break;
-	}
-
-	inb_p(io+3);
-	inb_p(io+2);
-	while(time_before(jiffies, timeout)) {
-		if ( 0xfb == inb_p(io+6) ) break;
-	}
-
-	/* release the other dma channel (if we opened both of them) */
-
-	if ((want & 2) && (get_dma_residue(3)==sizeof(struct lt_mem))) {
-		want &= ~2;
-		free_dma(3);
-	}
-
-	if ((want & 1) && (get_dma_residue(1)==sizeof(struct lt_mem))) {
-		want &= ~1;
-		free_dma(1);
-	}
-
-	if (!want)
-		return 0;
-
-	return (want & 2) ? 3 : 1;
-}
-
-static const struct net_device_ops ltpc_netdev = {
-	.ndo_start_xmit		= ltpc_xmit,
-	.ndo_do_ioctl		= ltpc_ioctl,
-	.ndo_set_rx_mode	= set_multicast_list,
-};
-
-struct net_device * __init ltpc_probe(void)
-{
-	struct net_device *dev;
-	int err = -ENOMEM;
-	int x=0,y=0;
-	int autoirq;
-	unsigned long f;
-	unsigned long timeout;
-
-	dev = alloc_ltalkdev(sizeof(struct ltpc_private));
-	if (!dev)
-		goto out;
-
-	/* probe for the I/O port address */
-	
-	if (io != 0x240 && request_region(0x220,8,"ltpc")) {
-		x = inb_p(0x220+6);
-		if ( (x!=0xff) && (x>=0xf0) ) {
-			io = 0x220;
-			goto got_port;
-		}
-		release_region(0x220,8);
-	}
-	if (io != 0x220 && request_region(0x240,8,"ltpc")) {
-		y = inb_p(0x240+6);
-		if ( (y!=0xff) && (y>=0xf0) ){ 
-			io = 0x240;
-			goto got_port;
-		}
-		release_region(0x240,8);
-	} 
-
-	/* give up in despair */
-	printk(KERN_ERR "LocalTalk card not found; 220 = %02x, 240 = %02x.\n", x,y);
-	err = -ENODEV;
-	goto out1;
-
- got_port:
-	/* probe for the IRQ line */
-	if (irq < 2) {
-		unsigned long irq_mask;
-
-		irq_mask = probe_irq_on();
-		/* reset the interrupt line */
-		inb_p(io+7);
-		inb_p(io+7);
-		/* trigger an interrupt (I hope) */
-		inb_p(io+6);
-		mdelay(2);
-		autoirq = probe_irq_off(irq_mask);
-
-		if (autoirq == 0) {
-			printk(KERN_ERR "ltpc: probe at %#x failed to detect IRQ line.\n", io);
-		} else {
-			irq = autoirq;
-		}
-	}
-
-	/* allocate a DMA buffer */
-	ltdmabuf = (unsigned char *) dma_mem_alloc(1000);
-	if (!ltdmabuf) {
-		printk(KERN_ERR "ltpc: mem alloc failed\n");
-		err = -ENOMEM;
-		goto out2;
-	}
-
-	ltdmacbuf = &ltdmabuf[800];
-
-	if(debug & DEBUG_VERBOSE) {
-		printk("ltdmabuf pointer %08lx\n",(unsigned long) ltdmabuf);
-	}
-
-	/* reset the card */
-
-	inb_p(io+1);
-	inb_p(io+3);
-
-	msleep(20);
-
-	inb_p(io+0);
-	inb_p(io+2);
-	inb_p(io+7); /* clear reset */
-	inb_p(io+4); 
-	inb_p(io+5);
-	inb_p(io+5); /* enable dma */
-	inb_p(io+6); /* tri-state interrupt line */
-
-	ssleep(1);
-	
-	/* now, figure out which dma channel we're using, unless it's
-	   already been specified */
-	/* well, 0 is a legal DMA channel, but the LTPC card doesn't
-	   use it... */
-	dma = ltpc_probe_dma(io, dma);
-	if (!dma) {  /* no dma channel */
-		printk(KERN_ERR "No DMA channel found on ltpc card.\n");
-		err = -ENODEV;
-		goto out3;
-	}
-
-	/* print out friendly message */
-	if(irq)
-		printk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, IR%d, DMA%d.\n",io,irq,dma);
-	else
-		printk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, DMA%d.  Using polled mode.\n",io,dma);
-
-	dev->netdev_ops = &ltpc_netdev;
-	dev->base_addr = io;
-	dev->irq = irq;
-	dev->dma = dma;
-
-	/* the card will want to send a result at this point */
-	/* (I think... leaving out this part makes the kernel crash,
-           so I put it back in...) */
-
-	f=claim_dma_lock();
-	disable_dma(dma);
-	clear_dma_ff(dma);
-	set_dma_mode(dma,DMA_MODE_READ);
-	set_dma_addr(dma,virt_to_bus(ltdmabuf));
-	set_dma_count(dma,0x100);
-	enable_dma(dma);
-	release_dma_lock(f);
-
-	(void) inb_p(io+3);
-	(void) inb_p(io+2);
-	timeout = jiffies+100*HZ/100;
-
-	while(time_before(jiffies, timeout)) {
-		if( 0xf9 == inb_p(io+6))
-			break;
-		schedule();
-	}
-
-	if(debug & DEBUG_VERBOSE) {
-		printk("setting up timer and irq\n");
-	}
-
-	/* grab it and don't let go :-) */
-	if (irq && request_irq( irq, ltpc_interrupt, 0, "ltpc", dev) >= 0)
-	{
-		(void) inb_p(io+7);  /* enable interrupts from board */
-		(void) inb_p(io+7);  /* and reset irq line */
-	} else {
-		if( irq )
-			printk(KERN_ERR "ltpc: IRQ already in use, using polled mode.\n");
-		dev->irq = 0;
-		/* polled mode -- 20 times per second */
-		/* this is really, really slow... should it poll more often? */
-		init_timer(&ltpc_timer);
-		ltpc_timer.function=ltpc_poll;
-		ltpc_timer.data = (unsigned long) dev;
-
-		ltpc_timer.expires = jiffies + HZ/20;
-		add_timer(&ltpc_timer);
-	}
-	err = register_netdev(dev);
-	if (err)
-		goto out4;
-
-	return NULL;
-out4:
-	del_timer_sync(&ltpc_timer);
-	if (dev->irq)
-		free_irq(dev->irq, dev);
-out3:
-	free_pages((unsigned long)ltdmabuf, get_order(1000));
-out2:
-	release_region(io, 8);
-out1:
-	free_netdev(dev);
-out:
-	return ERR_PTR(err);
-}
-
-#ifndef MODULE
-/* handles "ltpc=io,irq,dma" kernel command lines */
-static int __init ltpc_setup(char *str)
-{
-	int ints[5];
-
-	str = get_options(str, ARRAY_SIZE(ints), ints);
-
-	if (ints[0] == 0) {
-		if (str && !strncmp(str, "auto", 4)) {
-			/* do nothing :-) */
-		}
-		else {
-			/* usage message */
-			printk (KERN_ERR
-				"ltpc: usage: ltpc=auto|iobase[,irq[,dma]]\n");
-			return 0;
-		}
-	} else {
-		io = ints[1];
-		if (ints[0] > 1) {
-			irq = ints[2];
-		}
-		if (ints[0] > 2) {
-			dma = ints[3];
-		}
-		/* ignore any other parameters */
-	}
-	return 1;
-}
-
-__setup("ltpc=", ltpc_setup);
-#endif /* MODULE */
-
-static struct net_device *dev_ltpc;
-
-#ifdef MODULE
-
-MODULE_LICENSE("GPL");
-module_param(debug, int, 0);
-module_param(io, int, 0);
-module_param(irq, int, 0);
-module_param(dma, int, 0);
-
-
-static int __init ltpc_module_init(void)
-{
-        if(io == 0)
-		printk(KERN_NOTICE
-		       "ltpc: Autoprobing is not recommended for modules\n");
-
-	dev_ltpc = ltpc_probe();
-	return PTR_ERR_OR_ZERO(dev_ltpc);
-}
-module_init(ltpc_module_init);
-#endif
-
-static void __exit ltpc_cleanup(void)
-{
-
-	if(debug & DEBUG_VERBOSE) printk("unregister_netdev\n");
-	unregister_netdev(dev_ltpc);
-
-	ltpc_timer.data = 0;  /* signal the poll routine that we're done */
-
-	del_timer_sync(&ltpc_timer);
-
-	if(debug & DEBUG_VERBOSE) printk("freeing irq\n");
-
-	if (dev_ltpc->irq)
-		free_irq(dev_ltpc->irq, dev_ltpc);
-
-	if(debug & DEBUG_VERBOSE) printk("freeing dma\n");
-
-	if (dev_ltpc->dma)
-		free_dma(dev_ltpc->dma);
-
-	if(debug & DEBUG_VERBOSE) printk("freeing ioaddr\n");
-
-	if (dev_ltpc->base_addr)
-		release_region(dev_ltpc->base_addr,8);
-
-	free_netdev(dev_ltpc);
-
-	if(debug & DEBUG_VERBOSE) printk("free_pages\n");
-
-	free_pages( (unsigned long) ltdmabuf, get_order(1000));
-
-	if(debug & DEBUG_VERBOSE) printk("returning from cleanup_module\n");
-}
-
-module_exit(ltpc_cleanup);
diff -Naur a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
--- a/drivers/pci/host/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/pci/host/Kconfig	2015-02-11 08:27:03.000000000 -0800
@@ -91,4 +91,9 @@
 	  There are 5 internal PCIe ports available. Each port is GEN3 capable
 	  and have varied lanes from x1 to x8.
 
+config PCI_OXNAS
+	bool "PLX Oxnas PCIe controller"
+	depends on ARCH_OXNAS
+	select PCIEPORTBUS
+
 endmenu
diff -Naur a/drivers/pci/host/Makefile b/drivers/pci/host/Makefile
--- a/drivers/pci/host/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/pci/host/Makefile	2015-02-11 12:36:29.000000000 -0800
@@ -8,6 +8,7 @@
 obj-$(CONFIG_PCI_RCAR_GEN2_PCIE) += pcie-rcar.o
 obj-$(CONFIG_PCI_HOST_GENERIC) += pci-host-generic.o
 obj-$(CONFIG_PCIE_SPEAR13XX) += pcie-spear13xx.o
+obj-$(CONFIG_PCI_OXNAS) += pcie-oxnas.o
 obj-$(CONFIG_PCI_KEYSTONE) += pci-keystone-dw.o pci-keystone.o
 obj-$(CONFIG_PCIE_XILINX) += pcie-xilinx.o
 obj-$(CONFIG_PCI_XGENE) += pci-xgene.o
diff -Naur a/drivers/pci/host/pcie-oxnas.c b/drivers/pci/host/pcie-oxnas.c
--- a/drivers/pci/host/pcie-oxnas.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/pci/host/pcie-oxnas.c	2015-02-11 08:27:03.000000000 -0800
@@ -0,0 +1,681 @@
+/*
+ * PCIe driver for PLX NAS782X SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/mbus.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/of_pci.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <mach/iomap.h>
+#include <mach/hardware.h>
+#include <mach/utils.h>
+
+#define VERSION_ID_MAGIC		0x082510b5
+#define LINK_UP_TIMEOUT_SECONDS		1
+#define NUM_CONTROLLERS			1
+
+enum {
+	PCIE_DEVICE_TYPE_NASK = 0x0F,
+	PCIE_DEVICE_TYPE_ENDPOINT = 0,
+	PCIE_DEVICE_TYPE_LEGACY_ENDPOIN = 1,
+	PCIE_DEVICE_TYPE_ROOT = 4,
+
+	PCIE_LTSSM = BIT(4),
+	PCIE_READY_ENTR_L23 = BIT(9),
+	PCIE_LINK_UP = BIT(11),
+	PCIE_OBTRANS = BIT(12),
+};
+
+enum {
+	HCSL_BIAS_ON = BIT(0),
+	HCSL_PCIE_EN = BIT(1),
+	HCSL_PCIEA_EN = BIT(2),
+	HCSL_PCIEB_EN = BIT(3),
+};
+
+enum {
+	/* pcie phy reg offset */
+	PHY_ADDR = 0,
+	PHY_DATA = 4,
+	/* phy data reg bits */
+	READ_EN = BIT(16),
+	WRITE_EN = BIT(17),
+	CAP_DATA = BIT(18),
+};
+
+/* core config registers */
+enum {
+	PCI_CONFIG_VERSION_DEVICEID = 0,
+	PCI_CONFIG_COMMAND_STATUS = 4,
+};
+
+/* inbound config registers */
+enum {
+	IB_ADDR_XLATE_ENABLE = 0xFC,
+
+	/* bits */
+	ENABLE_IN_ADDR_TRANS = BIT(0),
+};
+
+/* outbound config registers, offset relative to PCIE_POM0_MEM_ADDR */
+enum {
+	PCIE_POM0_MEM_ADDR	= 0,
+	PCIE_POM1_MEM_ADDR	= 4,
+	PCIE_IN0_MEM_ADDR	= 8,
+	PCIE_IN1_MEM_ADDR	= 12,
+	PCIE_IN_IO_ADDR		= 16,
+	PCIE_IN_CFG0_ADDR	= 20,
+	PCIE_IN_CFG1_ADDR	= 24,
+	PCIE_IN_MSG_ADDR	= 28,
+	PCIE_IN0_MEM_LIMIT	= 32,
+	PCIE_IN1_MEM_LIMIT	= 36,
+	PCIE_IN_IO_LIMIT	= 40,
+	PCIE_IN_CFG0_LIMIT	= 44,
+	PCIE_IN_CFG1_LIMIT	= 48,
+	PCIE_IN_MSG_LIMIT	= 52,
+	PCIE_AHB_SLAVE_CTRL	= 56,
+
+	PCIE_SLAVE_BE_SHIFT	= 22,
+};
+
+#define ADDR_VAL(val)	((val) & 0xFFFF)
+#define DATA_VAL(val)	((val) & 0xFFFF)
+
+#define PCIE_SLAVE_BE(val)	((val) << PCIE_SLAVE_BE_SHIFT)
+#define PCIE_SLAVE_BE_MASK	PCIE_SLAVE_BE(0xF)
+
+struct oxnas_pcie_shared
+{
+	/* seems all access are serialized, no lock required */
+	int refcount;
+};
+
+/* Structure representing one PCIe interfaces */
+struct oxnas_pcie {
+	void __iomem *cfgbase;
+	void __iomem *base;
+	void __iomem *inbound;
+	void __iomem *outbound;
+	void __iomem *pcie_ctrl;
+
+	int haslink;
+	struct platform_device *pdev;
+	struct resource io;
+	struct resource cfg;
+	struct resource pre_mem;	/* prefetchable */
+	struct resource non_mem;	/* non-prefetchable */
+	struct resource busn;		/* max available bus numbers */
+	int card_reset;			/* gpio pin, optional */
+	unsigned hcsl_en;		/* hcsl pci enable bit */
+	struct clk *clk;
+	struct clk *busclk;		/* for pcie bus, actually the PLLB */
+	void *private_data[1];
+	spinlock_t lock;
+};
+
+static struct oxnas_pcie_shared pcie_shared = {
+	.refcount = 0,
+};
+
+static inline struct oxnas_pcie *sys_to_pcie(struct pci_sys_data *sys)
+{
+	return sys->private_data;
+}
+
+
+static void inline set_out_lanes(struct oxnas_pcie *pcie, unsigned lanes)
+{
+	oxnas_register_value_mask(pcie->outbound + PCIE_AHB_SLAVE_CTRL,
+	                          PCIE_SLAVE_BE_MASK, PCIE_SLAVE_BE(lanes));
+	wmb();
+}
+
+static int oxnas_pcie_link_up(struct oxnas_pcie *pcie)
+{
+	unsigned long end;
+
+	/* Poll for PCIE link up */
+	end = jiffies + (LINK_UP_TIMEOUT_SECONDS * HZ);
+	while (!time_after(jiffies, end)) {
+		if (readl(pcie->pcie_ctrl) & PCIE_LINK_UP)
+			return 1;
+	}
+	return 0;
+}
+
+static void __init oxnas_pcie_setup_hw(struct oxnas_pcie *pcie)
+{
+
+	 /* We won't have any inbound address translation. This allows PCI devices
+	 * to access anywhere in the AHB address map. Might be regarded as a bit
+	 * dangerous, but let's get things working before we worry about that
+	 */
+	oxnas_register_clear_mask(pcie->inbound + IB_ADDR_XLATE_ENABLE,
+	                          ENABLE_IN_ADDR_TRANS);
+	wmb();
+
+	/*
+	 * Program outbound translation windows
+	 *
+	 * Outbound window is what is referred to as "PCI client" region in HRM
+	 *
+	 * Could use the larger alternative address space to get >>64M regions for
+	 * graphics cards etc., but will not bother at this point.
+	 *
+	 * IP bug means that AMBA window size must be a power of 2
+	 *
+	 * Set mem0 window for first 16MB of outbound window non-prefetchable
+	 * Set mem1 window for second 16MB of outbound window prefetchable
+	 * Set io window for next 16MB of outbound window
+	 * Set cfg0 for final 1MB of outbound window
+	 *
+	 * Ignore mem1, cfg1 and msg windows for now as no obvious use cases for
+	 * 820 that would need them
+	 *
+	 * Probably ideally want no offset between mem0 window start as seen by ARM
+	 * and as seen on PCI bus and get Linux to assign memory regions to PCI
+	 * devices using the same "PCI client" region start address as seen by ARM
+	 */
+
+	/* Set PCIeA mem0 region to be 1st 16MB of the 64MB PCIeA window */
+	writel_relaxed(pcie->non_mem.start,	pcie->outbound + PCIE_IN0_MEM_ADDR);
+	writel_relaxed(pcie->non_mem.end,	pcie->outbound + PCIE_IN0_MEM_LIMIT);
+	writel_relaxed(pcie->non_mem.start,	pcie->outbound + PCIE_POM0_MEM_ADDR);
+
+	/* Set PCIeA mem1 region to be 2nd 16MB of the 64MB PCIeA window */
+	writel_relaxed(pcie->pre_mem.start,	pcie->outbound + PCIE_IN1_MEM_ADDR);
+	writel_relaxed(pcie->pre_mem.end,	pcie->outbound + PCIE_IN1_MEM_LIMIT);
+	writel_relaxed(pcie->pre_mem.start,	pcie->outbound + PCIE_POM1_MEM_ADDR);
+
+	/* Set PCIeA io to be third 16M region of the 64MB PCIeA window*/
+	writel_relaxed(pcie->io.start,	pcie->outbound + PCIE_IN_IO_ADDR);
+	writel_relaxed(pcie->io.end,	pcie->outbound + PCIE_IN_IO_LIMIT);
+
+	/* Set PCIeA cgf0 to be last 16M region of the 64MB PCIeA window*/
+	writel_relaxed(pcie->cfg.start,	pcie->outbound + PCIE_IN_CFG0_ADDR);
+	writel_relaxed(pcie->cfg.end, pcie->outbound + PCIE_IN_CFG0_LIMIT);
+	wmb();
+
+	/* Enable outbound address translation */
+	oxnas_register_set_mask(pcie->pcie_ctrl, PCIE_OBTRANS);
+	wmb();
+
+	/*
+	 * Program PCIe command register for core to:
+	 *  enable memory space
+	 *  enable bus master
+	 *  enable io
+	 */
+	writel_relaxed(7, pcie->base + PCI_CONFIG_COMMAND_STATUS); /* which is which */
+	wmb();
+}
+
+static unsigned oxnas_pcie_cfg_to_offset(
+	struct pci_sys_data *sys,
+	unsigned char bus_number,
+	unsigned int devfn,
+	int where)
+{
+	unsigned int  function = PCI_FUNC(devfn);
+	unsigned int  slot = PCI_SLOT(devfn);
+	unsigned char bus_number_offset;
+
+	bus_number_offset = bus_number - sys->busnr;
+
+	/*
+	 * We'll assume for now that the offset, function, slot, bus encoding
+	 * should map onto linear, contiguous addresses in PCIe config space, albeit
+	 * that the majority will be unused as only slot 0 is valid for any PCIe
+	 * bus and most devices have only function 0
+	 *
+	 * Could be that PCIe in fact works by not encoding the slot number into the
+	 * config space address as it's known that only slot 0 is valid. We'll have
+	 * to experiment if/when we get a PCIe switch connected to the PCIe host
+	 */
+	return ((bus_number_offset << 20) | (slot << 15) | (function << 12) | (where &~3));
+}
+
+/* PCI configuration space write function */
+static int oxnas_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			      int where, int size, u32 val)
+{
+	unsigned long flags;
+	struct oxnas_pcie *pcie = sys_to_pcie(bus->sysdata);
+	unsigned offset;
+	u32 value;
+	u32 lanes;
+
+	/* Only a single device per bus for PCIe point-to-point links */
+	if (PCI_SLOT(devfn) > 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (!pcie->haslink)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	offset = oxnas_pcie_cfg_to_offset(bus->sysdata, bus->number, devfn, where);
+
+	value = val << (8 * (where & 3));
+	lanes =  (0xf >> (4-size)) << (where & 3);
+	/* it race with mem and io write, but the possibility is low, normally
+	 * all config writes happens at driver initialize stage, wont interleave with
+	 * others. * and many pcie cards use dword (4bytes) access mem/io access only,
+	 * so not bother to copy that ugly work-around now. */
+	spin_lock_irqsave(&pcie->lock, flags);
+	set_out_lanes(pcie, lanes);
+	writel_relaxed(value, pcie->cfgbase + offset);
+	set_out_lanes(pcie, 0xf);
+	spin_unlock_irqrestore(&pcie->lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/* PCI configuration space read function */
+static int oxnas_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			      int size, u32 *val)
+{
+	struct oxnas_pcie *pcie = sys_to_pcie(bus->sysdata);
+	unsigned offset;
+	u32 value;
+	u32 left_bytes, right_bytes;
+
+	/* Only a single device per bus for PCIe point-to-point links */
+	if (PCI_SLOT(devfn) > 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	if (!pcie->haslink) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	offset = oxnas_pcie_cfg_to_offset(bus->sysdata, bus->number, devfn, where);
+	value = readl_relaxed(pcie->cfgbase + offset);
+	left_bytes = where & 3;
+	right_bytes = 4 - left_bytes - size;
+	value <<= right_bytes * 8;
+	value >>= (left_bytes + right_bytes) * 8;
+	*val = value;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops oxnas_pcie_ops = {
+	.read = oxnas_pcie_rd_conf,
+	.write = oxnas_pcie_wr_conf,
+};
+
+static int __init oxnas_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct oxnas_pcie *pcie = sys_to_pcie(sys);
+
+	pci_add_resource_offset(&sys->resources, &pcie->non_mem, sys->mem_offset);
+	pci_add_resource_offset(&sys->resources, &pcie->pre_mem, sys->mem_offset);
+	pci_add_resource_offset(&sys->resources, &pcie->io, sys->io_offset);
+	pci_add_resource(&sys->resources, &pcie->busn);
+	if (sys->busnr == 0) { /* default one */
+		sys->busnr = pcie->busn.start;
+	}
+	/* do not use devm_ioremap_resource, it does not like cfg resource */
+	pcie->cfgbase = devm_ioremap(&pcie->pdev->dev, pcie->cfg.start,
+	                             resource_size(&pcie->cfg));
+	if(!pcie->cfgbase)
+		return -ENOMEM;
+
+	oxnas_pcie_setup_hw(pcie);
+
+	return 1;
+}
+
+static int __init oxnas_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct of_phandle_args oirq;
+	int ret;
+
+	ret = of_irq_parse_pci (dev, &oirq);
+	if (ret)
+		return ret;
+
+	return irq_create_of_mapping (&oirq);
+}
+
+static void __init oxnas_pcie_enable(struct device* dev, struct oxnas_pcie *pcie)
+{
+	struct hw_pci hw;
+	int i;
+
+	memset(&hw, 0, sizeof(hw));
+	for (i = 0; i < NUM_CONTROLLERS; i++) {
+		pcie->private_data[i] = pcie;
+	}
+
+	hw.nr_controllers = NUM_CONTROLLERS;
+	/* I think use stack pointer is a bad idea though it is valid in this case */
+	hw.private_data   = pcie->private_data;
+	hw.setup          = oxnas_pcie_setup;
+	hw.map_irq        = oxnas_pcie_map_irq;
+	hw.ops            = &oxnas_pcie_ops;
+
+	/* pass dev to maintain of tree, interrupt mapping rely on this */
+	pci_common_init_dev(dev, &hw);
+}
+
+void oxnas_pcie_init_shared_hw(struct platform_device *pdev, void __iomem *phybase)
+{
+	struct reset_control *rstc;
+	int ret;
+
+	/* generate clocks from HCSL buffers, shared parts */
+	writel(HCSL_BIAS_ON|HCSL_PCIE_EN, SYS_CTRL_HCSL_CTRL);
+
+	/* Ensure PCIe PHY is properly reset */
+	rstc = reset_control_get(&pdev->dev, "phy");
+	if (IS_ERR(rstc)) {
+		ret = PTR_ERR(rstc);
+	} else {
+		ret = reset_control_reset(rstc);
+		reset_control_put(rstc);
+	}
+
+	if (ret) {
+		dev_err(&pdev->dev, "phy reset failed %d\n", ret);
+		return;
+	}
+
+	/* Enable PCIe Pre-Emphasis: What these value means? */
+
+	writel(ADDR_VAL(0x0014), phybase + PHY_ADDR);
+	writel(DATA_VAL(0xce10) | CAP_DATA, phybase + PHY_DATA);
+	writel(DATA_VAL(0xce10) | WRITE_EN, phybase + PHY_DATA);
+
+	writel(ADDR_VAL(0x2004), phybase + PHY_ADDR);
+	writel(DATA_VAL(0x82c7) | CAP_DATA, phybase + PHY_DATA);
+	writel(DATA_VAL(0x82c7) | WRITE_EN, phybase + PHY_DATA);
+}
+
+static int oxnas_pcie_shared_init(struct platform_device *pdev)
+{
+	if (++pcie_shared.refcount == 1)
+	{
+		/* we are the first */
+		struct device_node *np = pdev->dev.of_node;
+		void __iomem *phy = of_iomap(np, 2);
+		if (!phy) {
+			--pcie_shared.refcount;
+			return -ENOMEM;
+		}
+		oxnas_pcie_init_shared_hw(pdev, phy);
+		iounmap(phy);
+		return 0;
+	} else {
+		return 0;
+	}
+}
+
+/* maybe we will call it when enter low power state */
+static void oxnas_pcie_shared_deinit(struct platform_device *pdev)
+{
+	if(--pcie_shared.refcount == 0) {
+		/* no cleanup needed */;
+	}
+}
+
+static int __init
+oxnas_pcie_map_registers(struct platform_device *pdev,
+			 struct device_node *np,
+			 struct oxnas_pcie *pcie)
+{
+	struct resource regs;
+	int ret = 0;
+	u32 outbound_ctrl_offset;
+	u32 pcie_ctrl_offset;
+
+	/* 2 is reserved for shared phy */
+	ret = of_address_to_resource(np, 0, &regs);
+	if (ret)
+		return -EINVAL;
+	pcie->base = devm_ioremap_resource(&pdev->dev, &regs);
+	if (!pcie->base)
+		return -ENOMEM;
+
+	ret = of_address_to_resource(np, 1, &regs);
+	if (ret)
+		return -EINVAL;
+	pcie->inbound = devm_ioremap_resource(&pdev->dev, &regs);
+	if (!pcie->inbound)
+		return -ENOMEM;
+
+
+	if (of_property_read_u32(np, "plxtech,pcie-outbound-offset", &outbound_ctrl_offset))
+		return -EINVAL;
+	/* SYSCRTL is shared by too many drivers, so is mapped by board file */
+	pcie->outbound = IOMEM(OXNAS_SYSCRTL_BASE_VA + outbound_ctrl_offset);
+
+	if (of_property_read_u32(np, "plxtech,pcie-ctrl-offset", &pcie_ctrl_offset))
+		return -EINVAL;
+	pcie->pcie_ctrl = IOMEM(OXNAS_SYSCRTL_BASE_VA + pcie_ctrl_offset);
+
+	return 0;
+}
+
+static int __init oxnas_pcie_init_res(struct platform_device *pdev,
+                                      struct oxnas_pcie *pcie,
+                                           struct device_node *np)
+{
+	struct of_pci_range range;
+	struct of_pci_range_parser parser;
+	int ret;
+
+	if (of_pci_range_parser_init(&parser, np))
+		return -EINVAL;
+
+	/* Get the I/O and memory ranges from DT */
+	for_each_of_pci_range(&parser, &range) {
+
+		unsigned long restype = range.flags & IORESOURCE_TYPE_BITS;
+		if (restype == IORESOURCE_IO) {
+			of_pci_range_to_resource(&range, np, &pcie->io);
+			pcie->io.name = "I/O";
+		}
+		if (restype == IORESOURCE_MEM) {
+			if (range.flags & IORESOURCE_PREFETCH) {
+				of_pci_range_to_resource(&range, np, &pcie->pre_mem);
+				pcie->pre_mem.name = "PRE MEM";
+			} else {
+				of_pci_range_to_resource(&range, np, &pcie->non_mem);
+				pcie->non_mem.name = "NON MEM";
+			}
+
+		}
+		if (restype == 0) {
+			of_pci_range_to_resource(&range, np, &pcie->cfg);
+		}
+	}
+
+	/* Get the bus range */
+	ret = of_pci_parse_bus_range(np, &pcie->busn);
+
+	if (ret) {
+		dev_err(&pdev->dev, "failed to parse bus-range property: %d\n",
+			ret);
+		return ret;
+	}
+
+	pcie->card_reset = of_get_gpio(np, 0);
+	if (pcie->card_reset < 0) {
+		dev_info(&pdev->dev, "card reset gpio pin not exists\n");
+	}
+
+	if (of_property_read_u32(np, "plxtech,pcie-hcsl-bit", &pcie->hcsl_en))
+		return -EINVAL;
+
+	pcie->clk = of_clk_get_by_name(np, "pcie");
+	if (IS_ERR(pcie->clk)) {
+		return PTR_ERR(pcie->clk);
+	}
+
+	pcie->busclk = of_clk_get_by_name(np, "busclk");
+	if (IS_ERR(pcie->busclk)) {
+		clk_put(pcie->clk);
+		return PTR_ERR(pcie->busclk);
+	}
+
+	return 0;
+}
+
+static void oxnas_pcie_init_hw(struct platform_device *pdev,
+                                     struct oxnas_pcie *pcie)
+{
+	u32 version_id;
+	int ret;
+
+	clk_prepare_enable(pcie->busclk);
+
+	/* reset PCIe cards use hard-wired gpio pin */
+	if(pcie->card_reset >=0 && !gpio_direction_output(pcie->card_reset, 0))
+	{
+		wmb();
+		mdelay(10);
+		/* must tri-state the pin to pull it up */
+		gpio_direction_input(pcie->card_reset);
+		wmb();
+		mdelay(100);
+	}
+
+	oxnas_register_set_mask(SYS_CTRL_HCSL_CTRL, BIT(pcie->hcsl_en));
+
+	/* core */
+	ret = device_reset(&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "core reset failed %d\n", ret);
+		return;
+	}
+
+	/* Start PCIe core clocks */
+	clk_prepare_enable(pcie->clk);
+
+	version_id = readl_relaxed(pcie->base + PCI_CONFIG_VERSION_DEVICEID);
+	dev_info(&pdev->dev, "PCIe version/deviceID 0x%x\n", version_id);
+
+	if (version_id != VERSION_ID_MAGIC) {
+		dev_info(&pdev->dev, "PCIe controller not found\n");
+		pcie->haslink = 0;
+		return;
+	}
+
+	/* allow entry to L23 state */
+	oxnas_register_set_mask(pcie->pcie_ctrl, PCIE_READY_ENTR_L23);
+
+	/* Set PCIe core into RootCore mode */
+	oxnas_register_value_mask(pcie->pcie_ctrl, PCIE_DEVICE_TYPE_NASK,
+	                          PCIE_DEVICE_TYPE_ROOT);
+	wmb();
+
+	/* Bring up the PCI core */
+	oxnas_register_set_mask(pcie->pcie_ctrl, PCIE_LTSSM);
+	wmb();
+}
+
+static int __init oxnas_pcie_probe(struct platform_device *pdev)
+{
+	struct oxnas_pcie *pcie;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	pcie = devm_kzalloc(&pdev->dev, sizeof(struct oxnas_pcie),
+			    GFP_KERNEL);
+	if (!pcie)
+		return -ENOMEM;
+
+	pcie->pdev = pdev;
+	pcie->haslink = 1;
+	spin_lock_init(&pcie->lock);
+
+	ret = oxnas_pcie_init_res(pdev, pcie, np);
+	if (ret)
+		return ret;
+	if (pcie->card_reset >= 0) {
+		ret = gpio_request_one(pcie->card_reset, GPIOF_DIR_IN,
+		                       dev_name(&pdev->dev));
+		if (ret) {
+			dev_err(&pdev->dev, "cannot request gpio pin %d\n",
+			        pcie->card_reset);
+			return ret;
+		}
+	}
+
+	ret = oxnas_pcie_map_registers(pdev, np, pcie);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot map registers\n");
+		goto err_free_gpio;
+	}
+
+	ret = oxnas_pcie_shared_init(pdev);
+	if (ret)
+		goto err_free_gpio;
+
+	/* if hw not found, haslink cleared */
+	oxnas_pcie_init_hw(pdev, pcie);
+
+	if (pcie->haslink && oxnas_pcie_link_up(pcie)) {
+		pcie->haslink = 1;
+		dev_info(&pdev->dev, "link up\n");
+	} else {
+		pcie->haslink = 0;
+		dev_info(&pdev->dev, "link down\n");
+	}
+	/* should we register our controller even when pcie->haslink is 0 ? */
+	/* register the controller with framework */
+	oxnas_pcie_enable(&pdev->dev, pcie);
+
+	return 0;
+
+err_free_gpio:
+	if (pcie->card_reset)
+		gpio_free(pcie->card_reset);
+
+	return ret;
+}
+
+static const struct of_device_id oxnas_pcie_of_match_table[] = {
+	{ .compatible = "plxtech,nas782x-pcie", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, oxnas_pcie_of_match_table);
+
+static struct platform_driver oxnas_pcie_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "oxnas-pcie",
+		.of_match_table =
+		   of_match_ptr(oxnas_pcie_of_match_table),
+	},
+};
+
+static int __init oxnas_pcie_init(void)
+{
+	return platform_driver_probe(&oxnas_pcie_driver,
+				     oxnas_pcie_probe);
+}
+
+subsys_initcall(oxnas_pcie_init);
+
+MODULE_AUTHOR("Ma Haijun <mahaijuns@gmail.com>");
+MODULE_DESCRIPTION("NAS782x PCIe driver");
+MODULE_LICENSE("GPLv2");
diff -Naur a/drivers/pci/hotplug/pciehp_hpc.c b/drivers/pci/hotplug/pciehp_hpc.c
--- a/drivers/pci/hotplug/pciehp_hpc.c	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/pci/hotplug/pciehp_hpc.c	2015-02-11 12:38:49.000000000 -0800
@@ -1,835 +0,0 @@
-/*
- * PCI Express PCI Hot Plug Driver
- *
- * Copyright (C) 1995,2001 Compaq Computer Corporation
- * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)
- * Copyright (C) 2001 IBM Corp.
- * Copyright (C) 2003-2004 Intel Corporation
- *
- * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Send feedback to <greg@kroah.com>,<kristen.c.accardi@intel.com>
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/signal.h>
-#include <linux/jiffies.h>
-#include <linux/timer.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/slab.h>
-
-#include "../pci.h"
-#include "pciehp.h"
-
-static inline struct pci_dev *ctrl_dev(struct controller *ctrl)
-{
-	return ctrl->pcie->port;
-}
-
-static irqreturn_t pcie_isr(int irq, void *dev_id);
-static void start_int_poll_timer(struct controller *ctrl, int sec);
-
-/* This is the interrupt polling timeout function. */
-static void int_poll_timeout(unsigned long data)
-{
-	struct controller *ctrl = (struct controller *)data;
-
-	/* Poll for interrupt events.  regs == NULL => polling */
-	pcie_isr(0, ctrl);
-
-	init_timer(&ctrl->poll_timer);
-	if (!pciehp_poll_time)
-		pciehp_poll_time = 2; /* default polling interval is 2 sec */
-
-	start_int_poll_timer(ctrl, pciehp_poll_time);
-}
-
-/* This function starts the interrupt polling timer. */
-static void start_int_poll_timer(struct controller *ctrl, int sec)
-{
-	/* Clamp to sane value */
-	if ((sec <= 0) || (sec > 60))
-		sec = 2;
-
-	ctrl->poll_timer.function = &int_poll_timeout;
-	ctrl->poll_timer.data = (unsigned long)ctrl;
-	ctrl->poll_timer.expires = jiffies + sec * HZ;
-	add_timer(&ctrl->poll_timer);
-}
-
-static inline int pciehp_request_irq(struct controller *ctrl)
-{
-	int retval, irq = ctrl->pcie->irq;
-
-	/* Install interrupt polling timer. Start with 10 sec delay */
-	if (pciehp_poll_mode) {
-		init_timer(&ctrl->poll_timer);
-		start_int_poll_timer(ctrl, 10);
-		return 0;
-	}
-
-	/* Installs the interrupt handler */
-	retval = request_irq(irq, pcie_isr, IRQF_SHARED, MY_NAME, ctrl);
-	if (retval)
-		ctrl_err(ctrl, "Cannot get irq %d for the hotplug controller\n",
-			 irq);
-	return retval;
-}
-
-static inline void pciehp_free_irq(struct controller *ctrl)
-{
-	if (pciehp_poll_mode)
-		del_timer_sync(&ctrl->poll_timer);
-	else
-		free_irq(ctrl->pcie->irq, ctrl);
-}
-
-static int pcie_poll_cmd(struct controller *ctrl, int timeout)
-{
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 slot_status;
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
-	if (slot_status & PCI_EXP_SLTSTA_CC) {
-		pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
-					   PCI_EXP_SLTSTA_CC);
-		return 1;
-	}
-	while (timeout > 0) {
-		msleep(10);
-		timeout -= 10;
-		pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
-		if (slot_status & PCI_EXP_SLTSTA_CC) {
-			pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
-						   PCI_EXP_SLTSTA_CC);
-			return 1;
-		}
-	}
-	return 0;	/* timeout */
-}
-
-static void pcie_wait_cmd(struct controller *ctrl)
-{
-	unsigned int msecs = pciehp_poll_mode ? 2500 : 1000;
-	unsigned long duration = msecs_to_jiffies(msecs);
-	unsigned long cmd_timeout = ctrl->cmd_started + duration;
-	unsigned long now, timeout;
-	int rc;
-
-	/*
-	 * If the controller does not generate notifications for command
-	 * completions, we never need to wait between writes.
-	 */
-	if (NO_CMD_CMPL(ctrl))
-		return;
-
-	if (!ctrl->cmd_busy)
-		return;
-
-	/*
-	 * Even if the command has already timed out, we want to call
-	 * pcie_poll_cmd() so it can clear PCI_EXP_SLTSTA_CC.
-	 */
-	now = jiffies;
-	if (time_before_eq(cmd_timeout, now))
-		timeout = 1;
-	else
-		timeout = cmd_timeout - now;
-
-	if (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&
-	    ctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)
-		rc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);
-	else
-		rc = pcie_poll_cmd(ctrl, jiffies_to_msecs(timeout));
-
-	/*
-	 * Controllers with errata like Intel CF118 don't generate
-	 * completion notifications unless the power/indicator/interlock
-	 * control bits are changed.  On such controllers, we'll emit this
-	 * timeout message when we wait for completion of commands that
-	 * don't change those bits, e.g., commands that merely enable
-	 * interrupts.
-	 */
-	if (!rc)
-		ctrl_info(ctrl, "Timeout on hotplug command %#06x (issued %u msec ago)\n",
-			  ctrl->slot_ctrl,
-			  jiffies_to_msecs(jiffies - ctrl->cmd_started));
-}
-
-/**
- * pcie_write_cmd - Issue controller command
- * @ctrl: controller to which the command is issued
- * @cmd:  command value written to slot control register
- * @mask: bitmask of slot control register to be modified
- */
-static void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)
-{
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 slot_ctrl;
-
-	mutex_lock(&ctrl->ctrl_lock);
-
-	/* Wait for any previous command that might still be in progress */
-	pcie_wait_cmd(ctrl);
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);
-	slot_ctrl &= ~mask;
-	slot_ctrl |= (cmd & mask);
-	ctrl->cmd_busy = 1;
-	smp_mb();
-	pcie_capability_write_word(pdev, PCI_EXP_SLTCTL, slot_ctrl);
-	ctrl->cmd_started = jiffies;
-	ctrl->slot_ctrl = slot_ctrl;
-
-	mutex_unlock(&ctrl->ctrl_lock);
-}
-
-bool pciehp_check_link_active(struct controller *ctrl)
-{
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 lnk_status;
-	bool ret;
-
-	pcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);
-	ret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);
-
-	if (ret)
-		ctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);
-
-	return ret;
-}
-
-static void __pcie_wait_link_active(struct controller *ctrl, bool active)
-{
-	int timeout = 1000;
-
-	if (pciehp_check_link_active(ctrl) == active)
-		return;
-	while (timeout > 0) {
-		msleep(10);
-		timeout -= 10;
-		if (pciehp_check_link_active(ctrl) == active)
-			return;
-	}
-	ctrl_dbg(ctrl, "Data Link Layer Link Active not %s in 1000 msec\n",
-			active ? "set" : "cleared");
-}
-
-static void pcie_wait_link_active(struct controller *ctrl)
-{
-	__pcie_wait_link_active(ctrl, true);
-}
-
-static bool pci_bus_check_dev(struct pci_bus *bus, int devfn)
-{
-	u32 l;
-	int count = 0;
-	int delay = 1000, step = 20;
-	bool found = false;
-
-	do {
-		found = pci_bus_read_dev_vendor_id(bus, devfn, &l, 0);
-		count++;
-
-		if (found)
-			break;
-
-		msleep(step);
-		delay -= step;
-	} while (delay > 0);
-
-	if (count > 1 && pciehp_debug)
-		printk(KERN_DEBUG "pci %04x:%02x:%02x.%d id reading try %d times with interval %d ms to get %08x\n",
-			pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
-			PCI_FUNC(devfn), count, step, l);
-
-	return found;
-}
-
-int pciehp_check_link_status(struct controller *ctrl)
-{
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	bool found;
-	u16 lnk_status;
-
-	/*
-	 * Data Link Layer Link Active Reporting must be capable for
-	 * hot-plug capable downstream port. But old controller might
-	 * not implement it. In this case, we wait for 1000 ms.
-	*/
-	if (ctrl->link_active_reporting)
-		pcie_wait_link_active(ctrl);
-	else
-		msleep(1000);
-
-	/* wait 100ms before read pci conf, and try in 1s */
-	msleep(100);
-	found = pci_bus_check_dev(ctrl->pcie->port->subordinate,
-					PCI_DEVFN(0, 0));
-
-	pcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);
-	ctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);
-	if ((lnk_status & PCI_EXP_LNKSTA_LT) ||
-	    !(lnk_status & PCI_EXP_LNKSTA_NLW)) {
-		ctrl_err(ctrl, "Link Training Error occurs\n");
-		return -1;
-	}
-
-	pcie_update_link_speed(ctrl->pcie->port->subordinate, lnk_status);
-
-	if (!found)
-		return -1;
-
-	return 0;
-}
-
-static int __pciehp_link_set(struct controller *ctrl, bool enable)
-{
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 lnk_ctrl;
-
-	pcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &lnk_ctrl);
-
-	if (enable)
-		lnk_ctrl &= ~PCI_EXP_LNKCTL_LD;
-	else
-		lnk_ctrl |= PCI_EXP_LNKCTL_LD;
-
-	pcie_capability_write_word(pdev, PCI_EXP_LNKCTL, lnk_ctrl);
-	ctrl_dbg(ctrl, "%s: lnk_ctrl = %x\n", __func__, lnk_ctrl);
-	return 0;
-}
-
-static int pciehp_link_enable(struct controller *ctrl)
-{
-	return __pciehp_link_set(ctrl, true);
-}
-
-void pciehp_get_attention_status(struct slot *slot, u8 *status)
-{
-	struct controller *ctrl = slot->ctrl;
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 slot_ctrl;
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x, value read %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);
-
-	switch (slot_ctrl & PCI_EXP_SLTCTL_AIC) {
-	case PCI_EXP_SLTCTL_ATTN_IND_ON:
-		*status = 1;	/* On */
-		break;
-	case PCI_EXP_SLTCTL_ATTN_IND_BLINK:
-		*status = 2;	/* Blink */
-		break;
-	case PCI_EXP_SLTCTL_ATTN_IND_OFF:
-		*status = 0;	/* Off */
-		break;
-	default:
-		*status = 0xFF;
-		break;
-	}
-}
-
-void pciehp_get_power_status(struct slot *slot, u8 *status)
-{
-	struct controller *ctrl = slot->ctrl;
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 slot_ctrl;
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x value read %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);
-
-	switch (slot_ctrl & PCI_EXP_SLTCTL_PCC) {
-	case PCI_EXP_SLTCTL_PWR_ON:
-		*status = 1;	/* On */
-		break;
-	case PCI_EXP_SLTCTL_PWR_OFF:
-		*status = 0;	/* Off */
-		break;
-	default:
-		*status = 0xFF;
-		break;
-	}
-}
-
-void pciehp_get_latch_status(struct slot *slot, u8 *status)
-{
-	struct pci_dev *pdev = ctrl_dev(slot->ctrl);
-	u16 slot_status;
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
-	*status = !!(slot_status & PCI_EXP_SLTSTA_MRLSS);
-}
-
-void pciehp_get_adapter_status(struct slot *slot, u8 *status)
-{
-	struct pci_dev *pdev = ctrl_dev(slot->ctrl);
-	u16 slot_status;
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
-	*status = !!(slot_status & PCI_EXP_SLTSTA_PDS);
-}
-
-int pciehp_query_power_fault(struct slot *slot)
-{
-	struct pci_dev *pdev = ctrl_dev(slot->ctrl);
-	u16 slot_status;
-
-	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
-	return !!(slot_status & PCI_EXP_SLTSTA_PFD);
-}
-
-void pciehp_set_attention_status(struct slot *slot, u8 value)
-{
-	struct controller *ctrl = slot->ctrl;
-	u16 slot_cmd;
-
-	if (!ATTN_LED(ctrl))
-		return;
-
-	switch (value) {
-	case 0:		/* turn off */
-		slot_cmd = PCI_EXP_SLTCTL_ATTN_IND_OFF;
-		break;
-	case 1:		/* turn on */
-		slot_cmd = PCI_EXP_SLTCTL_ATTN_IND_ON;
-		break;
-	case 2:		/* turn blink */
-		slot_cmd = PCI_EXP_SLTCTL_ATTN_IND_BLINK;
-		break;
-	default:
-		return;
-	}
-	pcie_write_cmd(ctrl, slot_cmd, PCI_EXP_SLTCTL_AIC);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);
-}
-
-void pciehp_green_led_on(struct slot *slot)
-{
-	struct controller *ctrl = slot->ctrl;
-
-	if (!PWR_LED(ctrl))
-		return;
-
-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON, PCI_EXP_SLTCTL_PIC);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,
-		 PCI_EXP_SLTCTL_PWR_IND_ON);
-}
-
-void pciehp_green_led_off(struct slot *slot)
-{
-	struct controller *ctrl = slot->ctrl;
-
-	if (!PWR_LED(ctrl))
-		return;
-
-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF, PCI_EXP_SLTCTL_PIC);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,
-		 PCI_EXP_SLTCTL_PWR_IND_OFF);
-}
-
-void pciehp_green_led_blink(struct slot *slot)
-{
-	struct controller *ctrl = slot->ctrl;
-
-	if (!PWR_LED(ctrl))
-		return;
-
-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK, PCI_EXP_SLTCTL_PIC);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,
-		 PCI_EXP_SLTCTL_PWR_IND_BLINK);
-}
-
-int pciehp_power_on_slot(struct slot *slot)
-{
-	struct controller *ctrl = slot->ctrl;
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 slot_status;
-	int retval;
-
-	/* Clear sticky power-fault bit from previous power failures */
-	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
-	if (slot_status & PCI_EXP_SLTSTA_PFD)
-		pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
-					   PCI_EXP_SLTSTA_PFD);
-	ctrl->power_fault_detected = 0;
-
-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_ON, PCI_EXP_SLTCTL_PCC);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,
-		 PCI_EXP_SLTCTL_PWR_ON);
-
-	retval = pciehp_link_enable(ctrl);
-	if (retval)
-		ctrl_err(ctrl, "%s: Can not enable the link!\n", __func__);
-
-	return retval;
-}
-
-void pciehp_power_off_slot(struct slot *slot)
-{
-	struct controller *ctrl = slot->ctrl;
-
-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_OFF, PCI_EXP_SLTCTL_PCC);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,
-		 PCI_EXP_SLTCTL_PWR_OFF);
-}
-
-static irqreturn_t pcie_isr(int irq, void *dev_id)
-{
-	struct controller *ctrl = (struct controller *)dev_id;
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	struct pci_bus *subordinate = pdev->subordinate;
-	struct pci_dev *dev;
-	struct slot *slot = ctrl->slot;
-	u16 detected, intr_loc;
-
-	/*
-	 * In order to guarantee that all interrupt events are
-	 * serviced, we need to re-inspect Slot Status register after
-	 * clearing what is presumed to be the last pending interrupt.
-	 */
-	intr_loc = 0;
-	do {
-		pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &detected);
-
-		detected &= (PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |
-			     PCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |
-			     PCI_EXP_SLTSTA_CC | PCI_EXP_SLTSTA_DLLSC);
-		detected &= ~intr_loc;
-		intr_loc |= detected;
-		if (!intr_loc)
-			return IRQ_NONE;
-		if (detected)
-			pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
-						   intr_loc);
-	} while (detected);
-
-	ctrl_dbg(ctrl, "%s: intr_loc %x\n", __func__, intr_loc);
-
-	/* Check Command Complete Interrupt Pending */
-	if (intr_loc & PCI_EXP_SLTSTA_CC) {
-		ctrl->cmd_busy = 0;
-		smp_mb();
-		wake_up(&ctrl->queue);
-	}
-
-	if (subordinate) {
-		list_for_each_entry(dev, &subordinate->devices, bus_list) {
-			if (dev->ignore_hotplug) {
-				ctrl_dbg(ctrl, "ignoring hotplug event %#06x (%s requested no hotplug)\n",
-					 intr_loc, pci_name(dev));
-				return IRQ_HANDLED;
-			}
-		}
-	}
-
-	if (!(intr_loc & ~PCI_EXP_SLTSTA_CC))
-		return IRQ_HANDLED;
-
-	/* Check MRL Sensor Changed */
-	if (intr_loc & PCI_EXP_SLTSTA_MRLSC)
-		pciehp_handle_switch_change(slot);
-
-	/* Check Attention Button Pressed */
-	if (intr_loc & PCI_EXP_SLTSTA_ABP)
-		pciehp_handle_attention_button(slot);
-
-	/* Check Presence Detect Changed */
-	if (intr_loc & PCI_EXP_SLTSTA_PDC)
-		pciehp_handle_presence_change(slot);
-
-	/* Check Power Fault Detected */
-	if ((intr_loc & PCI_EXP_SLTSTA_PFD) && !ctrl->power_fault_detected) {
-		ctrl->power_fault_detected = 1;
-		pciehp_handle_power_fault(slot);
-	}
-
-	if (intr_loc & PCI_EXP_SLTSTA_DLLSC)
-		pciehp_handle_linkstate_change(slot);
-
-	return IRQ_HANDLED;
-}
-
-void pcie_enable_notification(struct controller *ctrl)
-{
-	u16 cmd, mask;
-
-	/*
-	 * TBD: Power fault detected software notification support.
-	 *
-	 * Power fault detected software notification is not enabled
-	 * now, because it caused power fault detected interrupt storm
-	 * on some machines. On those machines, power fault detected
-	 * bit in the slot status register was set again immediately
-	 * when it is cleared in the interrupt service routine, and
-	 * next power fault detected interrupt was notified again.
-	 */
-
-	/*
-	 * Always enable link events: thus link-up and link-down shall
-	 * always be treated as hotplug and unplug respectively. Enable
-	 * presence detect only if Attention Button is not present.
-	 */
-	cmd = PCI_EXP_SLTCTL_DLLSCE;
-	if (ATTN_BUTTN(ctrl))
-		cmd |= PCI_EXP_SLTCTL_ABPE;
-	else
-		cmd |= PCI_EXP_SLTCTL_PDCE;
-	if (MRL_SENS(ctrl))
-		cmd |= PCI_EXP_SLTCTL_MRLSCE;
-	if (!pciehp_poll_mode)
-		cmd |= PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE;
-
-	mask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |
-		PCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |
-		PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |
-		PCI_EXP_SLTCTL_DLLSCE);
-
-	pcie_write_cmd(ctrl, cmd, mask);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, cmd);
-}
-
-static void pcie_disable_notification(struct controller *ctrl)
-{
-	u16 mask;
-
-	mask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |
-		PCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |
-		PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |
-		PCI_EXP_SLTCTL_DLLSCE);
-	pcie_write_cmd(ctrl, 0, mask);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);
-}
-
-/*
- * pciehp has a 1:1 bus:slot relationship so we ultimately want a secondary
- * bus reset of the bridge, but at the same time we want to ensure that it is
- * not seen as a hot-unplug, followed by the hot-plug of the device. Thus,
- * disable link state notification and presence detection change notification
- * momentarily, if we see that they could interfere. Also, clear any spurious
- * events after.
- */
-int pciehp_reset_slot(struct slot *slot, int probe)
-{
-	struct controller *ctrl = slot->ctrl;
-	struct pci_dev *pdev = ctrl_dev(ctrl);
-	u16 stat_mask = 0, ctrl_mask = 0;
-
-	if (probe)
-		return 0;
-
-	if (!ATTN_BUTTN(ctrl)) {
-		ctrl_mask |= PCI_EXP_SLTCTL_PDCE;
-		stat_mask |= PCI_EXP_SLTSTA_PDC;
-	}
-	ctrl_mask |= PCI_EXP_SLTCTL_DLLSCE;
-	stat_mask |= PCI_EXP_SLTSTA_DLLSC;
-
-	pcie_write_cmd(ctrl, 0, ctrl_mask);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);
-	if (pciehp_poll_mode)
-		del_timer_sync(&ctrl->poll_timer);
-
-	pci_reset_bridge_secondary_bus(ctrl->pcie->port);
-
-	pcie_capability_write_word(pdev, PCI_EXP_SLTSTA, stat_mask);
-	pcie_write_cmd(ctrl, ctrl_mask, ctrl_mask);
-	ctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,
-		 pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, ctrl_mask);
-	if (pciehp_poll_mode)
-		int_poll_timeout(ctrl->poll_timer.data);
-
-	return 0;
-}
-
-int pcie_init_notification(struct controller *ctrl)
-{
-	if (pciehp_request_irq(ctrl))
-		return -1;
-	pcie_enable_notification(ctrl);
-	ctrl->notification_enabled = 1;
-	return 0;
-}
-
-static void pcie_shutdown_notification(struct controller *ctrl)
-{
-	if (ctrl->notification_enabled) {
-		pcie_disable_notification(ctrl);
-		pciehp_free_irq(ctrl);
-		ctrl->notification_enabled = 0;
-	}
-}
-
-static int pcie_init_slot(struct controller *ctrl)
-{
-	struct slot *slot;
-
-	slot = kzalloc(sizeof(*slot), GFP_KERNEL);
-	if (!slot)
-		return -ENOMEM;
-
-	slot->wq = alloc_workqueue("pciehp-%u", 0, 0, PSN(ctrl));
-	if (!slot->wq)
-		goto abort;
-
-	slot->ctrl = ctrl;
-	mutex_init(&slot->lock);
-	mutex_init(&slot->hotplug_lock);
-	INIT_DELAYED_WORK(&slot->work, pciehp_queue_pushbutton_work);
-	ctrl->slot = slot;
-	return 0;
-abort:
-	kfree(slot);
-	return -ENOMEM;
-}
-
-static void pcie_cleanup_slot(struct controller *ctrl)
-{
-	struct slot *slot = ctrl->slot;
-	cancel_delayed_work(&slot->work);
-	destroy_workqueue(slot->wq);
-	kfree(slot);
-}
-
-static inline void dbg_ctrl(struct controller *ctrl)
-{
-	int i;
-	u16 reg16;
-	struct pci_dev *pdev = ctrl->pcie->port;
-
-	if (!pciehp_debug)
-		return;
-
-	ctrl_info(ctrl, "Hotplug Controller:\n");
-	ctrl_info(ctrl, "  Seg/Bus/Dev/Func/IRQ : %s IRQ %d\n",
-		  pci_name(pdev), pdev->irq);
-	ctrl_info(ctrl, "  Vendor ID            : 0x%04x\n", pdev->vendor);
-	ctrl_info(ctrl, "  Device ID            : 0x%04x\n", pdev->device);
-	ctrl_info(ctrl, "  Subsystem ID         : 0x%04x\n",
-		  pdev->subsystem_device);
-	ctrl_info(ctrl, "  Subsystem Vendor ID  : 0x%04x\n",
-		  pdev->subsystem_vendor);
-	ctrl_info(ctrl, "  PCIe Cap offset      : 0x%02x\n",
-		  pci_pcie_cap(pdev));
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
-		if (!pci_resource_len(pdev, i))
-			continue;
-		ctrl_info(ctrl, "  PCI resource [%d]     : %pR\n",
-			  i, &pdev->resource[i]);
-	}
-	ctrl_info(ctrl, "Slot Capabilities      : 0x%08x\n", ctrl->slot_cap);
-	ctrl_info(ctrl, "  Physical Slot Number : %d\n", PSN(ctrl));
-	ctrl_info(ctrl, "  Attention Button     : %3s\n",
-		  ATTN_BUTTN(ctrl) ? "yes" : "no");
-	ctrl_info(ctrl, "  Power Controller     : %3s\n",
-		  POWER_CTRL(ctrl) ? "yes" : "no");
-	ctrl_info(ctrl, "  MRL Sensor           : %3s\n",
-		  MRL_SENS(ctrl)   ? "yes" : "no");
-	ctrl_info(ctrl, "  Attention Indicator  : %3s\n",
-		  ATTN_LED(ctrl)   ? "yes" : "no");
-	ctrl_info(ctrl, "  Power Indicator      : %3s\n",
-		  PWR_LED(ctrl)    ? "yes" : "no");
-	ctrl_info(ctrl, "  Hot-Plug Surprise    : %3s\n",
-		  HP_SUPR_RM(ctrl) ? "yes" : "no");
-	ctrl_info(ctrl, "  EMI Present          : %3s\n",
-		  EMI(ctrl)        ? "yes" : "no");
-	ctrl_info(ctrl, "  Command Completed    : %3s\n",
-		  NO_CMD_CMPL(ctrl) ? "no" : "yes");
-	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &reg16);
-	ctrl_info(ctrl, "Slot Status            : 0x%04x\n", reg16);
-	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &reg16);
-	ctrl_info(ctrl, "Slot Control           : 0x%04x\n", reg16);
-}
-
-#define FLAG(x, y)	(((x) & (y)) ? '+' : '-')
-
-struct controller *pcie_init(struct pcie_device *dev)
-{
-	struct controller *ctrl;
-	u32 slot_cap, link_cap;
-	struct pci_dev *pdev = dev->port;
-
-	ctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);
-	if (!ctrl) {
-		dev_err(&dev->device, "%s: Out of memory\n", __func__);
-		goto abort;
-	}
-	ctrl->pcie = dev;
-	pcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &slot_cap);
-	ctrl->slot_cap = slot_cap;
-	mutex_init(&ctrl->ctrl_lock);
-	init_waitqueue_head(&ctrl->queue);
-	dbg_ctrl(ctrl);
-
-	/* Check if Data Link Layer Link Active Reporting is implemented */
-	pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);
-	if (link_cap & PCI_EXP_LNKCAP_DLLLARC) {
-		ctrl_dbg(ctrl, "Link Active Reporting supported\n");
-		ctrl->link_active_reporting = 1;
-	}
-
-	/* Clear all remaining event bits in Slot Status register */
-	pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
-		PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |
-		PCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |
-		PCI_EXP_SLTSTA_CC | PCI_EXP_SLTSTA_DLLSC);
-
-	ctrl_info(ctrl, "Slot #%d AttnBtn%c AttnInd%c PwrInd%c PwrCtrl%c MRL%c Interlock%c NoCompl%c LLActRep%c\n",
-		(slot_cap & PCI_EXP_SLTCAP_PSN) >> 19,
-		FLAG(slot_cap, PCI_EXP_SLTCAP_ABP),
-		FLAG(slot_cap, PCI_EXP_SLTCAP_AIP),
-		FLAG(slot_cap, PCI_EXP_SLTCAP_PIP),
-		FLAG(slot_cap, PCI_EXP_SLTCAP_PCP),
-		FLAG(slot_cap, PCI_EXP_SLTCAP_MRLSP),
-		FLAG(slot_cap, PCI_EXP_SLTCAP_EIP),
-		FLAG(slot_cap, PCI_EXP_SLTCAP_NCCS),
-		FLAG(link_cap, PCI_EXP_LNKCAP_DLLLARC));
-
-	if (pcie_init_slot(ctrl))
-		goto abort_ctrl;
-
-	return ctrl;
-
-abort_ctrl:
-	kfree(ctrl);
-abort:
-	return NULL;
-}
-
-void pciehp_release_ctrl(struct controller *ctrl)
-{
-	pcie_shutdown_notification(ctrl);
-	pcie_cleanup_slot(ctrl);
-	kfree(ctrl);
-}
diff -Naur a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
--- a/drivers/pinctrl/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/pinctrl/Kconfig	2015-02-11 08:27:08.000000000 -0800
@@ -67,6 +67,15 @@
 	help
 	  Say Y here to enable the at91 pinctrl driver
 
+config PINCTRL_OXNAS
+	bool "OXNAS pinctrl driver"
+	depends on OF
+	depends on ARCH_OXNAS
+	select PINMUX
+	select PINCONF
+	help
+	  Say Y here to enable the oxnas pinctrl driver
+
 config PINCTRL_BAYTRAIL
 	bool "Intel Baytrail GPIO pin control"
 	depends on GPIOLIB && ACPI && X86
diff -Naur a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
--- a/drivers/pinctrl/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/pinctrl/Makefile	2015-02-11 12:40:31.000000000 -0800
@@ -47,3 +47,5 @@
 obj-$(CONFIG_PLAT_SPEAR)	+= spear/
 obj-$(CONFIG_ARCH_SUNXI)	+= sunxi/
 obj-$(CONFIG_ARCH_VT8500)	+= vt8500/
+obj-$(CONFIG_PINCTRL_OXNAS)	+= pinctrl-oxnas.o
+
diff -Naur a/drivers/pinctrl/pinctrl-oxnas.c b/drivers/pinctrl/pinctrl-oxnas.c
--- a/drivers/pinctrl/pinctrl-oxnas.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/pinctrl/pinctrl-oxnas.c	2015-02-12 11:12:40.000000000 -0800
@@ -0,0 +1,1452 @@
+/*
+ * oxnas pinctrl driver based on at91 pinctrl driver
+ *
+ * Copyright (C) 2011-2012 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *
+ * Under GPLv2 only
+ */
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+/* Since we request GPIOs from ourself */
+#include <linux/pinctrl/consumer.h>
+
+#include "core.h"
+
+#include <mach/utils.h>
+
+#define MAX_NB_GPIO_PER_BANK	32
+#define MAX_GPIO_BANKS		2
+
+struct oxnas_gpio_chip {
+	struct gpio_chip	chip;
+	struct pinctrl_gpio_range range;
+	void __iomem		*regbase;	/* GPIOA/B virtual address */
+	void __iomem		*ctrlbase;	/* SYS/SEC_CTRL virtual address */
+	struct irq_domain	*domain;	/* associated irq domain */
+};
+
+#define to_oxnas_gpio_chip(c) container_of(c, struct oxnas_gpio_chip, chip)
+
+static struct oxnas_gpio_chip *gpio_chips[MAX_GPIO_BANKS];
+
+static int gpio_banks;
+
+#define PULL_UP		(1 << 0)
+#define PULL_DOWN	(1 << 1)
+#define DEBOUNCE	(1 << 2)
+
+/**
+ * struct oxnas_pmx_func - describes pinmux functions
+ * @name: the name of this specific function
+ * @groups: corresponding pin groups
+ * @ngroups: the number of groups
+ */
+struct oxnas_pmx_func {
+	const char	*name;
+	const char	**groups;
+	unsigned	ngroups;
+};
+
+enum oxnas_mux {
+	OXNAS_PINMUX_GPIO,
+	OXNAS_PINMUX_FUNC2,
+	OXNAS_PINMUX_FUNC3,
+	OXNAS_PINMUX_FUNC4,
+	OXNAS_PINMUX_DEBUG,
+	OXNAS_PINMUX_ALT,
+};
+
+enum {
+	INPUT_VALUE = 0,
+	OUTPUT_ENABLE = 4,
+	IRQ_PENDING = 0xC,
+	OUTPUT_VALUE = 0x10,
+	OUTPUT_SET = 0x14,
+	OUTPUT_CLEAR = 0x18,
+	OUTPUT_EN_SET = 0x1C,
+	OUTPUT_EN_CLEAR = 0x20,
+	DEBOUNCE_ENABLE = 0x24,
+	RE_IRQ_ENABLE = 0x28, /* rising edge */
+	FE_IRQ_ENABLE = 0x2C, /* falling edge */
+	RE_IRQ_PENDING = 0x30, /* rising edge */
+	FE_IRQ_PENDING = 0x34, /* falling edge */
+	CLOCK_DIV = 0x48,
+	PULL_ENABLE = 0x50,
+	PULL_SENSE = 0x54, /* 1 up, 0 down */
+
+
+	DEBOUNCE_MASK = 0x3FFF0000,
+	/* put hw debounce and soft config at same bit position*/
+	DEBOUNCE_SHIFT = 16
+};
+
+enum {
+	PINMUX_SECONDARY_SEL = 0x14,
+	PINMUX_TERTIARY_SEL = 0x8c,
+	PINMUX_QUATERNARY_SEL = 0x94,
+	PINMUX_DEBUG_SEL = 0x9c,
+	PINMUX_ALTERNATIVE_SEL = 0xa4,
+	PINMUX_PULLUP_SEL = 0xac,
+};
+
+/**
+ * struct oxnas_pmx_pin - describes an pin mux
+ * @bank: the bank of the pin
+ * @pin: the pin number in the @bank
+ * @mux: the mux mode : gpio or periph_x of the pin i.e. alternate function.
+ * @conf: the configuration of the pin: PULL_UP, MULTIDRIVE etc...
+ */
+struct oxnas_pmx_pin {
+	uint32_t	bank;
+	uint32_t	pin;
+	enum oxnas_mux	mux;
+	unsigned long	conf;
+};
+
+/**
+ * struct oxnas_pin_group - describes an pin group
+ * @name: the name of this specific pin group
+ * @pins_conf: the mux mode for each pin in this group. The size of this
+ *	array is the same as pins.
+ * @pins: an array of discrete physical pins used in this group, taken
+ *	from the driver-local pin enumeration space
+ * @npins: the number of pins in this group array, i.e. the number of
+ *	elements in .pins so we can iterate over that array
+ */
+struct oxnas_pin_group {
+	const char		*name;
+	struct oxnas_pmx_pin	*pins_conf;
+	unsigned int		*pins;
+	unsigned		npins;
+};
+
+struct oxnas_pinctrl {
+	struct device		*dev;
+	struct pinctrl_dev	*pctl;
+
+	int			nbanks;
+
+	uint32_t		*mux_mask;
+	int			nmux;
+
+	struct oxnas_pmx_func	*functions;
+	int			nfunctions;
+
+	struct oxnas_pin_group	*groups;
+	int			ngroups;
+};
+
+static const inline struct oxnas_pin_group *oxnas_pinctrl_find_group_by_name(
+				const struct oxnas_pinctrl *info,
+				const char *name)
+{
+	const struct oxnas_pin_group *grp = NULL;
+	int i;
+
+	for (i = 0; i < info->ngroups; i++) {
+		if (strcmp(info->groups[i].name, name))
+			continue;
+
+		grp = &info->groups[i];
+		dev_dbg(info->dev, "%s: %d 0:%d\n", name, grp->npins, grp->pins[0]);
+		break;
+	}
+
+	return grp;
+}
+
+static int oxnas_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->ngroups;
+}
+
+static const char *oxnas_get_group_name(struct pinctrl_dev *pctldev,
+				       unsigned selector)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->groups[selector].name;
+}
+
+static int oxnas_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,
+			       const unsigned **pins,
+			       unsigned *npins)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	if (selector >= info->ngroups)
+		return -EINVAL;
+
+	*pins = info->groups[selector].pins;
+	*npins = info->groups[selector].npins;
+
+	return 0;
+}
+
+static void oxnas_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,
+		   unsigned offset)
+{
+	seq_printf(s, "%s", dev_name(pctldev->dev));
+}
+
+static int oxnas_dt_node_to_map(struct pinctrl_dev *pctldev,
+			struct device_node *np,
+			struct pinctrl_map **map, unsigned *num_maps)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct oxnas_pin_group *grp;
+	struct pinctrl_map *new_map;
+	struct device_node *parent;
+	int map_num = 1;
+	int i;
+
+	/*
+	 * first find the group of this node and check if we need create
+	 * config maps for pins
+	 */
+	grp = oxnas_pinctrl_find_group_by_name(info, np->name);
+	if (!grp) {
+		dev_err(info->dev, "unable to find group for node %s\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	map_num += grp->npins;
+	new_map = devm_kzalloc(pctldev->dev, sizeof(*new_map) * map_num, GFP_KERNEL);
+	if (!new_map)
+		return -ENOMEM;
+
+	*map = new_map;
+	*num_maps = map_num;
+
+	/* create mux map */
+	parent = of_get_parent(np);
+	if (!parent) {
+		devm_kfree(pctldev->dev, new_map);
+		return -EINVAL;
+	}
+	new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
+	new_map[0].data.mux.function = parent->name;
+	new_map[0].data.mux.group = np->name;
+	of_node_put(parent);
+
+	/* create config map */
+	new_map++;
+	for (i = 0; i < grp->npins; i++) {
+		new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;
+		new_map[i].data.configs.group_or_pin =
+				pin_get_name(pctldev, grp->pins[i]);
+		new_map[i].data.configs.configs = &grp->pins_conf[i].conf;
+		new_map[i].data.configs.num_configs = 1;
+	}
+
+	dev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",
+		(*map)->data.mux.function, (*map)->data.mux.group, map_num);
+
+	return 0;
+}
+
+static void oxnas_dt_free_map(struct pinctrl_dev *pctldev,
+				struct pinctrl_map *map, unsigned num_maps)
+{
+}
+
+static const struct pinctrl_ops oxnas_pctrl_ops = {
+	.get_groups_count	= oxnas_get_groups_count,
+	.get_group_name		= oxnas_get_group_name,
+	.get_group_pins		= oxnas_get_group_pins,
+	.pin_dbg_show		= oxnas_pin_dbg_show,
+	.dt_node_to_map		= oxnas_dt_node_to_map,
+	.dt_free_map		= oxnas_dt_free_map,
+};
+
+static void __iomem *pin_to_gpioctrl(struct oxnas_pinctrl *info,
+				 unsigned int bank)
+{
+	return gpio_chips[bank]->regbase;
+}
+
+static void __iomem *pin_to_muxctrl(struct oxnas_pinctrl *info,
+				 unsigned int bank)
+{
+	return gpio_chips[bank]->ctrlbase;
+}
+
+
+static inline int pin_to_bank(unsigned pin)
+{
+	return pin / MAX_NB_GPIO_PER_BANK;
+}
+
+static unsigned pin_to_mask(unsigned int pin)
+{
+	return 1 << pin;
+}
+
+static void oxnas_mux_disable_interrupt(void __iomem *pio, unsigned mask)
+{
+	oxnas_register_clear_mask( pio + RE_IRQ_ENABLE, mask);
+	oxnas_register_clear_mask( pio + FE_IRQ_ENABLE, mask);
+}
+
+static unsigned oxnas_mux_get_pullup(void __iomem *pio, unsigned pin)
+{
+	return (readl_relaxed(pio + PULL_ENABLE) & BIT(pin)) &&
+		(readl_relaxed(pio + PULL_SENSE) & BIT(pin));
+}
+
+static void oxnas_mux_set_pullup(void __iomem *pio, unsigned mask, bool on)
+{
+	if (on) {
+		oxnas_register_set_mask(pio + PULL_SENSE, mask);
+		oxnas_register_set_mask(pio + PULL_ENABLE, mask);
+	} else {
+		oxnas_register_clear_mask(pio + PULL_ENABLE, mask);
+	}
+}
+
+static bool oxnas_mux_get_pulldown(void __iomem *pio, unsigned pin)
+{
+	return (readl_relaxed(pio + PULL_ENABLE) & BIT(pin)) &&
+			(!(readl_relaxed(pio + PULL_SENSE) & BIT(pin)));
+}
+
+static void oxnas_mux_set_pulldown(void __iomem *pio, unsigned mask, bool on)
+{
+	if (on) {
+		oxnas_register_clear_mask(pio + PULL_SENSE, mask);
+		oxnas_register_set_mask(pio + PULL_ENABLE, mask);
+	} else {
+		oxnas_register_clear_mask(pio + PULL_ENABLE, mask);
+	};
+}
+
+/* unfortunately debounce control are shared */
+static bool oxnas_mux_get_debounce(void __iomem *pio, unsigned pin, u32 *div)
+{
+	*div = __raw_readl(pio + CLOCK_DIV) & DEBOUNCE_MASK;
+	return __raw_readl(pio + DEBOUNCE_ENABLE) & BIT(pin);
+}
+
+static void oxnas_mux_set_debounce(void __iomem *pio, unsigned mask,
+				bool is_on, u32 div)
+{
+	if (is_on) {
+		oxnas_register_value_mask(pio + CLOCK_DIV, DEBOUNCE_MASK, div);
+		oxnas_register_set_mask(pio + DEBOUNCE_ENABLE, mask);
+	} else {
+		oxnas_register_clear_mask(pio + DEBOUNCE_ENABLE, mask);
+	}
+}
+
+
+static void oxnas_mux_set_func2(void __iomem *cio, unsigned mask)
+{
+	/* in fact, SECONDARY takes precedence, so clear others is not necessary */
+	oxnas_register_set_mask(cio + PINMUX_SECONDARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_TERTIARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_QUATERNARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_DEBUG_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_ALTERNATIVE_SEL, mask);
+}
+
+static void oxnas_mux_set_func3(void __iomem *cio, unsigned mask)
+{
+	oxnas_register_clear_mask(cio + PINMUX_SECONDARY_SEL, mask);
+	oxnas_register_set_mask(cio + PINMUX_TERTIARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_QUATERNARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_DEBUG_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_ALTERNATIVE_SEL, mask);
+}
+
+static void oxnas_mux_set_func4(void __iomem *cio, unsigned mask)
+{
+	oxnas_register_clear_mask(cio + PINMUX_SECONDARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_TERTIARY_SEL, mask);
+	oxnas_register_set_mask(cio + PINMUX_QUATERNARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_DEBUG_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_ALTERNATIVE_SEL, mask);
+}
+
+static void oxnas_mux_set_func_dbg(void __iomem *cio, unsigned mask)
+{
+	oxnas_register_clear_mask(cio + PINMUX_SECONDARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_TERTIARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_QUATERNARY_SEL, mask);
+	oxnas_register_set_mask(cio + PINMUX_DEBUG_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_ALTERNATIVE_SEL, mask);
+}
+
+static void oxnas_mux_set_func_alt(void __iomem *cio, unsigned mask)
+{
+	oxnas_register_clear_mask(cio + PINMUX_SECONDARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_TERTIARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_QUATERNARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_DEBUG_SEL, mask);
+	oxnas_register_set_mask(cio + PINMUX_ALTERNATIVE_SEL, mask);
+}
+
+static void oxnas_mux_set_gpio(void __iomem *cio, unsigned mask)
+{
+	oxnas_register_clear_mask(cio + PINMUX_SECONDARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_TERTIARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_QUATERNARY_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_DEBUG_SEL, mask);
+	oxnas_register_clear_mask(cio + PINMUX_ALTERNATIVE_SEL, mask);
+}
+
+static enum oxnas_mux oxnas_mux_get_func(void __iomem *cio, unsigned mask)
+{
+	if (readl_relaxed(cio + PINMUX_SECONDARY_SEL) & mask)
+		return OXNAS_PINMUX_FUNC2;
+	if (readl_relaxed(cio + PINMUX_TERTIARY_SEL) & mask)
+		return OXNAS_PINMUX_FUNC3;
+	if (readl_relaxed(cio + PINMUX_QUATERNARY_SEL) & mask)
+		return OXNAS_PINMUX_FUNC4;
+	if (readl_relaxed(cio + PINMUX_DEBUG_SEL) & mask)
+		return OXNAS_PINMUX_DEBUG;
+	if (readl_relaxed(cio + PINMUX_ALTERNATIVE_SEL) & mask)
+		return OXNAS_PINMUX_ALT;
+	return OXNAS_PINMUX_GPIO;
+}
+
+
+static void oxnas_pin_dbg(const struct device *dev, const struct oxnas_pmx_pin *pin)
+{
+	if (pin->mux) {
+		dev_dbg(dev, "MF_%c%d configured as periph%c with conf = 0x%lu\n",
+			pin->bank + 'A', pin->pin, pin->mux - 1 + 'A', pin->conf);
+	} else {
+		dev_dbg(dev, "MF_%c%d configured as gpio with conf = 0x%lu\n",
+			pin->bank + 'A', pin->pin, pin->conf);
+	}
+}
+
+static int pin_check_config(struct oxnas_pinctrl *info, const char *name,
+			    int index, const struct oxnas_pmx_pin *pin)
+{
+	int mux;
+
+	/* check if it's a valid config */
+	if (pin->bank >= info->nbanks) {
+		dev_err(info->dev, "%s: pin conf %d bank_id %d >= nbanks %d\n",
+			name, index, pin->bank, info->nbanks);
+		return -EINVAL;
+	}
+
+	if (pin->pin >= MAX_NB_GPIO_PER_BANK) {
+		dev_err(info->dev, "%s: pin conf %d pin_bank_id %d >= %d\n",
+			name, index, pin->pin, MAX_NB_GPIO_PER_BANK);
+		return -EINVAL;
+	}
+	/* gpio always allowed */
+	if (!pin->mux)
+		return 0;
+
+	mux = pin->mux - 1;
+
+	if (mux >= info->nmux) {
+		dev_err(info->dev, "%s: pin conf %d mux_id %d >= nmux %d\n",
+			name, index, mux, info->nmux);
+		return -EINVAL;
+	}
+
+	if (!(info->mux_mask[pin->bank * info->nmux + mux] & 1 << pin->pin)) {
+		dev_err(info->dev, "%s: pin conf %d mux_id %d not supported for MF_%c%d\n",
+			name, index, mux, pin->bank + 'A', pin->pin);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void oxnas_mux_gpio_enable(void __iomem *cio, void __iomem *pio, unsigned mask, bool input)
+{
+	oxnas_mux_set_gpio(cio, mask);
+	if (input)
+		writel_relaxed(mask, pio + OUTPUT_EN_CLEAR);
+	else
+		writel_relaxed(mask, pio + OUTPUT_EN_SET);
+}
+
+static void oxnas_mux_gpio_disable(void __iomem *cio, void __iomem *pio, unsigned mask)
+{
+	/* when switch to other function,  gpio is disabled automatically */
+	return;
+}
+
+static int oxnas_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,
+			   unsigned group)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct oxnas_pmx_pin *pins_conf = info->groups[group].pins_conf;
+	const struct oxnas_pmx_pin *pin;
+	uint32_t npins = info->groups[group].npins;
+	int i, ret;
+	unsigned mask;
+	void __iomem *pio;
+	void __iomem *cio;
+
+	dev_dbg(info->dev, "enable function %s group %s\n",
+		info->functions[selector].name, info->groups[group].name);
+
+	/* first check that all the pins of the group are valid with a valid
+	 * paramter */
+	for (i = 0; i < npins; i++) {
+		pin = &pins_conf[i];
+		ret = pin_check_config(info, info->groups[group].name, i, pin);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < npins; i++) {
+		pin = &pins_conf[i];
+		oxnas_pin_dbg(info->dev, pin);
+
+		pio = pin_to_gpioctrl(info, pin->bank);
+		cio = pin_to_muxctrl(info, pin->bank);
+
+		mask = pin_to_mask(pin->pin);
+		oxnas_mux_disable_interrupt(pio, mask);
+
+		switch (pin->mux) {
+		case OXNAS_PINMUX_GPIO:
+			oxnas_mux_gpio_enable(cio, pio, mask, 1);
+			break;
+		case OXNAS_PINMUX_FUNC2:
+			oxnas_mux_set_func2(cio, mask);
+			break;
+		case OXNAS_PINMUX_FUNC3:
+			oxnas_mux_set_func3(cio, mask);
+			break;
+		case OXNAS_PINMUX_FUNC4:
+			oxnas_mux_set_func4(cio, mask);
+			break;
+		case OXNAS_PINMUX_DEBUG:
+			oxnas_mux_set_func_dbg(cio, mask);
+			break;
+		case OXNAS_PINMUX_ALT:
+			oxnas_mux_set_func_alt(cio, mask);
+			break;
+		}
+		if (pin->mux)
+			oxnas_mux_gpio_disable(cio, pio, mask);
+	}
+
+	return 0;
+}
+
+static void oxnas_pmx_disable(struct pinctrl_dev *pctldev, unsigned selector,
+			   unsigned group)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct oxnas_pmx_pin *pins_conf = info->groups[group].pins_conf;
+	const struct oxnas_pmx_pin *pin;
+	uint32_t npins = info->groups[group].npins;
+	int i;
+	unsigned mask;
+	void __iomem *pio;
+	void __iomem *cio;
+
+	for (i = 0; i < npins; i++) {
+		pin = &pins_conf[i];
+		oxnas_pin_dbg(info->dev, pin);
+		pio = pin_to_gpioctrl(info, pin->bank);
+		cio = pin_to_muxctrl(info, pin->bank);
+		mask = pin_to_mask(pin->pin);
+		oxnas_mux_gpio_enable(cio, pio, mask, 1);
+	}
+}
+
+static int oxnas_pmx_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->nfunctions;
+}
+
+static const char *oxnas_pmx_get_func_name(struct pinctrl_dev *pctldev,
+					  unsigned selector)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->functions[selector].name;
+}
+
+static int oxnas_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,
+			       const char * const **groups,
+			       unsigned * const num_groups)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = info->functions[selector].groups;
+	*num_groups = info->functions[selector].ngroups;
+
+	return 0;
+}
+
+static int oxnas_gpio_request_enable(struct pinctrl_dev *pctldev,
+				    struct pinctrl_gpio_range *range,
+				    unsigned offset)
+{
+	struct oxnas_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);
+	struct oxnas_gpio_chip *oxnas_chip;
+	struct gpio_chip *chip;
+	unsigned mask;
+
+	if (!range) {
+		dev_err(npct->dev, "invalid range\n");
+		return -EINVAL;
+	}
+	if (!range->gc) {
+		dev_err(npct->dev, "missing GPIO chip in range\n");
+		return -EINVAL;
+	}
+	chip = range->gc;
+	oxnas_chip = container_of(chip, struct oxnas_gpio_chip, chip);
+
+	dev_dbg(npct->dev, "enable pin %u as GPIO\n", offset);
+
+	mask = 1 << (offset - chip->base);
+
+	dev_dbg(npct->dev, "enable pin %u as MF_%c%d 0x%x\n",
+		offset, 'A' + range->id, offset - chip->base, mask);
+
+	oxnas_mux_set_gpio(oxnas_chip->ctrlbase, mask);
+
+	return 0;
+}
+
+static void oxnas_gpio_disable_free(struct pinctrl_dev *pctldev,
+				   struct pinctrl_gpio_range *range,
+				   unsigned offset)
+{
+	struct oxnas_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);
+
+	dev_dbg(npct->dev, "disable pin %u as GPIO\n", offset);
+	/* Set the pin to some default state, GPIO is usually default */
+}
+
+static const struct pinmux_ops oxnas_pmx_ops = {
+	.get_functions_count	= oxnas_pmx_get_funcs_count,
+	.get_function_name	= oxnas_pmx_get_func_name,
+	.get_function_groups	= oxnas_pmx_get_groups,
+	.set_mux		= oxnas_pmx_enable,
+	.gpio_request_enable	= oxnas_gpio_request_enable,
+	.gpio_disable_free	= oxnas_gpio_disable_free,
+};
+
+static int oxnas_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned pin_id, unsigned long *config)
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	void __iomem *pio;
+	unsigned pin;
+	int div;
+
+	dev_dbg(info->dev, "%s:%d, pin_id=%d, config=0x%lx", __func__, __LINE__, pin_id, *config);
+	pio = pin_to_gpioctrl(info, pin_to_bank(pin_id));
+	pin = pin_id % MAX_NB_GPIO_PER_BANK;
+
+	if (oxnas_mux_get_pullup(pio, pin))
+		*config |= PULL_UP;
+
+	if (oxnas_mux_get_pulldown(pio, pin))
+		*config |= PULL_DOWN;
+
+	if (oxnas_mux_get_debounce(pio, pin, &div))
+		*config |= DEBOUNCE | div;
+	return 0;
+}
+
+static int oxnas_pinconf_set(struct pinctrl_dev *pctldev,
+                             unsigned pin_id, unsigned long *configs,
+                             unsigned num_configs)
+
+{
+	struct oxnas_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	unsigned mask;
+	void __iomem *pio;
+	int i;
+	unsigned long config;
+
+	pio = pin_to_gpioctrl(info, pin_to_bank(pin_id));
+	mask = pin_to_mask(pin_id % MAX_NB_GPIO_PER_BANK);
+
+	for (i = 0; i < num_configs; i++) {
+		config = configs[i];
+
+		dev_dbg(info->dev,
+		        "%s:%d, pin_id=%d, config=0x%lx",
+		        __func__, __LINE__, pin_id, config);
+
+		if ((config & PULL_UP) && (config & PULL_DOWN))
+			return -EINVAL;
+
+		oxnas_mux_set_pullup(pio, mask, config & PULL_UP);
+		oxnas_mux_set_pulldown(pio, mask, config & PULL_DOWN);
+		oxnas_mux_set_debounce(pio, mask, config & DEBOUNCE,
+				       config & DEBOUNCE_MASK);
+
+	} /* for each config */
+
+	return 0;
+}
+
+static void oxnas_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				   struct seq_file *s, unsigned pin_id)
+{
+
+}
+
+static void oxnas_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
+					 struct seq_file *s, unsigned group)
+{
+}
+
+static const struct pinconf_ops oxnas_pinconf_ops = {
+	.pin_config_get			= oxnas_pinconf_get,
+	.pin_config_set			= oxnas_pinconf_set,
+	.pin_config_dbg_show		= oxnas_pinconf_dbg_show,
+	.pin_config_group_dbg_show	= oxnas_pinconf_group_dbg_show,
+};
+
+static struct pinctrl_desc oxnas_pinctrl_desc = {
+	.pctlops	= &oxnas_pctrl_ops,
+	.pmxops		= &oxnas_pmx_ops,
+	.confops	= &oxnas_pinconf_ops,
+	.owner		= THIS_MODULE,
+};
+
+static const char *gpio_compat = "plxtech,nas782x-gpio";
+
+static void oxnas_pinctrl_child_count(struct oxnas_pinctrl *info,
+				     struct device_node *np)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(np, child) {
+		if (of_device_is_compatible(child, gpio_compat)) {
+			info->nbanks++;
+		} else {
+			info->nfunctions++;
+			info->ngroups += of_get_child_count(child);
+		}
+	}
+}
+
+static int oxnas_pinctrl_mux_mask(struct oxnas_pinctrl *info,
+				 struct device_node *np)
+{
+	int ret = 0;
+	int size;
+	const __be32 *list;
+
+	list = of_get_property(np, "plxtech,mux-mask", &size);
+	if (!list) {
+		dev_err(info->dev, "can not read the mux-mask of %d\n", size);
+		return -EINVAL;
+	}
+
+	size /= sizeof(*list);
+	if (!size || size % info->nbanks) {
+		dev_err(info->dev, "wrong mux mask array should be by %d\n", info->nbanks);
+		return -EINVAL;
+	}
+	info->nmux = size / info->nbanks;
+
+	info->mux_mask = devm_kzalloc(info->dev, sizeof(u32) * size, GFP_KERNEL);
+	if (!info->mux_mask) {
+		dev_err(info->dev, "could not alloc mux_mask\n");
+		return -ENOMEM;
+	}
+
+	ret = of_property_read_u32_array(np, "plxtech,mux-mask",
+					  info->mux_mask, size);
+	if (ret)
+		dev_err(info->dev, "can not read the mux-mask of %d\n", size);
+	return ret;
+}
+
+static int oxnas_pinctrl_parse_groups(struct device_node *np,
+				     struct oxnas_pin_group *grp,
+				     struct oxnas_pinctrl *info, u32 index)
+{
+	struct oxnas_pmx_pin *pin;
+	int size;
+	const __be32 *list;
+	int i, j;
+
+	dev_dbg(info->dev, "group(%d): %s\n", index, np->name);
+
+	/* Initialise group */
+	grp->name = np->name;
+
+	/*
+	 * the binding format is plxtech,pins = <bank pin mux CONFIG ...>,
+	 * do sanity check and calculate pins number
+	 */
+	list = of_get_property(np, "plxtech,pins", &size);
+	/* we do not check return since it's safe node passed down */
+	size /= sizeof(*list);
+	if (!size || size % 4) {
+		dev_err(info->dev, "wrong pins number or pins and configs should be by 4\n");
+		return -EINVAL;
+	}
+
+	grp->npins = size / 4;
+	pin = grp->pins_conf = devm_kzalloc(info->dev, grp->npins * sizeof(struct oxnas_pmx_pin),
+				GFP_KERNEL);
+	grp->pins = devm_kzalloc(info->dev, grp->npins * sizeof(unsigned int),
+				GFP_KERNEL);
+	if (!grp->pins_conf || !grp->pins)
+		return -ENOMEM;
+
+	for (i = 0, j = 0; i < size; i += 4, j++) {
+		pin->bank = be32_to_cpu(*list++);
+		pin->pin = be32_to_cpu(*list++);
+		grp->pins[j] = pin->bank * MAX_NB_GPIO_PER_BANK + pin->pin;
+		pin->mux = be32_to_cpu(*list++);
+		pin->conf = be32_to_cpu(*list++);
+
+		oxnas_pin_dbg(info->dev, pin);
+		pin++;
+	}
+
+	return 0;
+}
+
+static int oxnas_pinctrl_parse_functions(struct device_node *np,
+					struct oxnas_pinctrl *info, u32 index)
+{
+	struct device_node *child;
+	struct oxnas_pmx_func *func;
+	struct oxnas_pin_group *grp;
+	int ret;
+	static u32 grp_index;
+	u32 i = 0;
+
+	dev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);
+
+	func = &info->functions[index];
+
+	/* Initialise function */
+	func->name = np->name;
+	func->ngroups = of_get_child_count(np);
+	if (func->ngroups <= 0) {
+		dev_err(info->dev, "no groups defined\n");
+		return -EINVAL;
+	}
+	func->groups = devm_kzalloc(info->dev,
+			func->ngroups * sizeof(char *), GFP_KERNEL);
+	if (!func->groups)
+		return -ENOMEM;
+
+	for_each_child_of_node(np, child) {
+		func->groups[i] = child->name;
+		grp = &info->groups[grp_index++];
+		ret = oxnas_pinctrl_parse_groups(child, grp, info, i++);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static struct of_device_id oxnas_pinctrl_of_match[] = {
+	{ .compatible = "plxtech,nas782x-pinctrl"},
+	{ /* sentinel */ }
+};
+
+static int oxnas_pinctrl_probe_dt(struct platform_device *pdev,
+				 struct oxnas_pinctrl *info)
+{
+	int ret = 0;
+	int i, j;
+	uint32_t *tmp;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+
+	if (!np)
+		return -ENODEV;
+
+	info->dev = &pdev->dev;
+
+	oxnas_pinctrl_child_count(info, np);
+
+	if (info->nbanks < 1) {
+		dev_err(&pdev->dev, "you need to specify atleast one gpio-controller\n");
+		return -EINVAL;
+	}
+
+	ret = oxnas_pinctrl_mux_mask(info, np);
+	if (ret)
+		return ret;
+
+	dev_dbg(&pdev->dev, "nmux = %d\n", info->nmux);
+
+	dev_dbg(&pdev->dev, "mux-mask\n");
+	tmp = info->mux_mask;
+	for (i = 0; i < info->nbanks; i++) {
+		for (j = 0; j < info->nmux; j++, tmp++) {
+			dev_dbg(&pdev->dev, "%d:%d\t0x%x\n", i, j, tmp[0]);
+		}
+	}
+
+	dev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);
+	dev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);
+	info->functions = devm_kzalloc(&pdev->dev, info->nfunctions * sizeof(struct oxnas_pmx_func),
+					GFP_KERNEL);
+	if (!info->functions)
+		return -ENOMEM;
+
+	info->groups = devm_kzalloc(&pdev->dev, info->ngroups * sizeof(struct oxnas_pin_group),
+					GFP_KERNEL);
+	if (!info->groups)
+		return -ENOMEM;
+
+	dev_dbg(&pdev->dev, "nbanks = %d\n", info->nbanks);
+	dev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);
+	dev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);
+
+	i = 0;
+
+	for_each_child_of_node(np, child) {
+		if (of_device_is_compatible(child, gpio_compat))
+			continue;
+		ret = oxnas_pinctrl_parse_functions(child, info, i++);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to parse function\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int oxnas_pinctrl_probe(struct platform_device *pdev)
+{
+	struct oxnas_pinctrl *info;
+	struct pinctrl_pin_desc *pdesc;
+	int ret, i, j, k;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	ret = oxnas_pinctrl_probe_dt(pdev, info);
+	if (ret)
+		return ret;
+
+	/*
+	 * We need all the GPIO drivers to probe FIRST, or we will not be able
+	 * to obtain references to the struct gpio_chip * for them, and we
+	 * need this to proceed.
+	 */
+	for (i = 0; i < info->nbanks; i++) {
+		if (!gpio_chips[i]) {
+			dev_warn(&pdev->dev, "GPIO chip %d not registered yet\n", i);
+			devm_kfree(&pdev->dev, info);
+			return -EPROBE_DEFER;
+		}
+	}
+
+	oxnas_pinctrl_desc.name = dev_name(&pdev->dev);
+	oxnas_pinctrl_desc.npins = info->nbanks * MAX_NB_GPIO_PER_BANK;
+	oxnas_pinctrl_desc.pins = pdesc =
+		devm_kzalloc(&pdev->dev, sizeof(*pdesc) * oxnas_pinctrl_desc.npins, GFP_KERNEL);
+
+	if (!oxnas_pinctrl_desc.pins)
+		return -ENOMEM;
+
+	for (i = 0 , k = 0; i < info->nbanks; i++) {
+		for (j = 0; j < MAX_NB_GPIO_PER_BANK; j++, k++) {
+			pdesc->number = k;
+			pdesc->name = kasprintf(GFP_KERNEL, "MF_%c%d", i + 'A', j);
+			pdesc++;
+		}
+	}
+
+	platform_set_drvdata(pdev, info);
+	info->pctl = pinctrl_register(&oxnas_pinctrl_desc, &pdev->dev, info);
+
+	if (!info->pctl) {
+		dev_err(&pdev->dev, "could not register OX820 pinctrl driver\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* We will handle a range of GPIO pins */
+	for (i = 0; i < info->nbanks; i++)
+		pinctrl_add_gpio_range(info->pctl, &gpio_chips[i]->range);
+
+	dev_info(&pdev->dev, "initialized OX820 pinctrl driver\n");
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int oxnas_pinctrl_remove(struct platform_device *pdev)
+{
+	struct oxnas_pinctrl *info = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(info->pctl);
+
+	return 0;
+}
+
+static int oxnas_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	/*
+	 * Map back to global GPIO space and request muxing, the direction
+	 * parameter does not matter for this controller.
+	 */
+	int gpio = chip->base + offset;
+	int bank = chip->base / chip->ngpio;
+
+	dev_dbg(chip->dev, "%s:%d MF_%c%d(%d)\n", __func__, __LINE__,
+		 'A' + bank, offset, gpio);
+
+	return pinctrl_request_gpio(gpio);
+}
+
+static void oxnas_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	int gpio = chip->base + offset;
+
+	pinctrl_free_gpio(gpio);
+}
+
+static int oxnas_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = to_oxnas_gpio_chip(chip);
+	void __iomem *pio = oxnas_gpio->regbase;
+
+	writel_relaxed(BIT(offset), pio + OUTPUT_EN_CLEAR);
+	return 0;
+}
+
+static int oxnas_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = to_oxnas_gpio_chip(chip);
+	void __iomem *pio = oxnas_gpio->regbase;
+	unsigned mask = 1 << offset;
+	u32 pdsr;
+
+	pdsr = readl_relaxed(pio + INPUT_VALUE);
+	return (pdsr & mask) != 0;
+}
+
+static void oxnas_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int val)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = to_oxnas_gpio_chip(chip);
+	void __iomem *pio = oxnas_gpio->regbase;
+
+	if (val)
+		writel_relaxed(BIT(offset), pio + OUTPUT_SET);
+	else
+		writel_relaxed(BIT(offset), pio + OUTPUT_CLEAR);
+
+}
+
+static int oxnas_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
+				int val)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = to_oxnas_gpio_chip(chip);
+	void __iomem *pio = oxnas_gpio->regbase;
+
+	if (val)
+		writel_relaxed(BIT(offset), pio + OUTPUT_SET);
+	else
+		writel_relaxed(BIT(offset), pio + OUTPUT_CLEAR);
+
+	writel_relaxed(BIT(offset), pio + OUTPUT_EN_SET);
+
+	return 0;
+}
+
+static int oxnas_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = to_oxnas_gpio_chip(chip);
+	int virq;
+
+	if (offset < chip->ngpio)
+		virq = irq_create_mapping(oxnas_gpio->domain, offset);
+	else
+		virq = -ENXIO;
+
+	dev_dbg(chip->dev, "%s: request IRQ for GPIO %d, return %d\n",
+				chip->label, offset + chip->base, virq);
+	return virq;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static void oxnas_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+{
+	enum oxnas_mux mode;
+	int i;
+	struct oxnas_gpio_chip *oxnas_gpio = to_oxnas_gpio_chip(chip);
+	void __iomem *pio = oxnas_gpio->regbase;
+	void __iomem *cio = oxnas_gpio->ctrlbase;
+
+	for (i = 0; i < chip->ngpio; i++) {
+		unsigned pin = chip->base + i;
+		unsigned mask = pin_to_mask(pin);
+		const char *gpio_label;
+		u32 pdsr;
+
+		gpio_label = gpiochip_is_requested(chip, i);
+		if (!gpio_label)
+			continue;
+		/* FIXME */
+		mode = oxnas_mux_get_func(cio, mask);
+		seq_printf(s, "[%s] GPIO%s%d: ",
+			   gpio_label, chip->label, i);
+		if (mode == OXNAS_PINMUX_GPIO) {
+			pdsr = readl_relaxed(pio + INPUT_VALUE);
+
+			seq_printf(s, "[gpio] %s\n",
+				   pdsr & mask ?
+				   "set" : "clear");
+		} else {
+			seq_printf(s, "[periph %c]\n",
+				   mode + 'A' - 1);
+		}
+	}
+}
+#else
+#define oxnas_gpio_dbg_show	NULL
+#endif
+
+/* Several AIC controller irqs are dispatched through this GPIO handler.
+ * To use any AT91_PIN_* as an externally triggered IRQ, first call
+ * oxnas_set_gpio_input() then maybe enable its glitch filter.
+ * Then just request_irq() with the pin ID; it works like any ARM IRQ
+ * handler.
+ */
+
+static void gpio_irq_mask(struct irq_data *d)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = irq_data_get_irq_chip_data(d);
+	void __iomem	*pio = oxnas_gpio->regbase;
+	unsigned	mask = 1 << d->hwirq;
+	unsigned	type = irqd_get_trigger_type(d);
+
+	/* FIXME: need proper lock */
+	if (type & IRQ_TYPE_EDGE_RISING)
+		oxnas_register_clear_mask(pio + RE_IRQ_ENABLE, mask);
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		oxnas_register_clear_mask(pio + FE_IRQ_ENABLE, mask);
+}
+
+static void gpio_irq_unmask(struct irq_data *d)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = irq_data_get_irq_chip_data(d);
+	void __iomem	*pio = oxnas_gpio->regbase;
+	unsigned	mask = 1 << d->hwirq;
+	unsigned	type = irqd_get_trigger_type(d);
+
+	/* FIXME: need proper lock */
+	if (type & IRQ_TYPE_EDGE_RISING)
+		oxnas_register_set_mask(pio + RE_IRQ_ENABLE, mask);
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		oxnas_register_set_mask(pio + FE_IRQ_ENABLE, mask);
+}
+
+
+static int gpio_irq_type(struct irq_data *d, unsigned type)
+{
+	if ((type & IRQ_TYPE_EDGE_BOTH) == 0) {
+		pr_warn("OX820: Unsupported type for irq %d\n", gpio_to_irq(d->irq));
+		return -EINVAL;
+	}
+	/* seems no way to set trigger type without enable irq, so leave it to unmask time */
+
+	return 0;
+}
+
+static struct irq_chip gpio_irqchip = {
+	.name		= "GPIO",
+	.irq_disable	= gpio_irq_mask,
+	.irq_mask	= gpio_irq_mask,
+	.irq_unmask	= gpio_irq_unmask,
+	.irq_set_type	= gpio_irq_type,
+};
+
+static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct irq_data *idata = irq_desc_get_irq_data(desc);
+	struct oxnas_gpio_chip *oxnas_gpio = irq_data_get_irq_chip_data(idata);
+	void __iomem	*pio = oxnas_gpio->regbase;
+	unsigned long	isr;
+	int		n;
+
+	chained_irq_enter(chip, desc);
+	for (;;) {
+		/* TODO: see if it works */
+		isr = readl_relaxed(pio + IRQ_PENDING);
+		if (!isr)
+			break;
+		/* acks pending interrupts */
+		writel_relaxed(isr, pio + IRQ_PENDING);
+
+		for_each_set_bit(n, &isr, BITS_PER_LONG) {
+			generic_handle_irq(irq_find_mapping(oxnas_gpio->domain, n));
+		}
+	}
+	chained_irq_exit(chip, desc);
+	/* now it may re-trigger */
+}
+
+/*
+ * This lock class tells lockdep that GPIO irqs are in a different
+ * category than their parents, so it won't report false recursion.
+ */
+static struct lock_class_key gpio_lock_class;
+
+static int oxnas_gpio_irq_map(struct irq_domain *h, unsigned int virq,
+							irq_hw_number_t hw)
+{
+	struct oxnas_gpio_chip	*oxnas_gpio = h->host_data;
+
+	irq_set_lockdep_class(virq, &gpio_lock_class);
+
+	irq_set_chip_and_handler(virq, &gpio_irqchip, handle_edge_irq);
+	set_irq_flags(virq, IRQF_VALID);
+	irq_set_chip_data(virq, oxnas_gpio);
+
+	return 0;
+}
+
+static int oxnas_gpio_irq_domain_xlate(struct irq_domain *d,
+				      struct device_node *ctrlr,
+				      const u32 *intspec, unsigned int intsize,
+				      irq_hw_number_t *out_hwirq,
+				      unsigned int *out_type)
+{
+	struct oxnas_gpio_chip *oxnas_gpio = d->host_data;
+	int ret;
+	int pin = oxnas_gpio->chip.base + intspec[0];
+
+	if (WARN_ON(intsize < 2))
+		return -EINVAL;
+	*out_hwirq = intspec[0];
+	*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;
+
+	ret = gpio_request(pin, ctrlr->full_name);
+	if (ret)
+		return ret;
+
+	ret = gpio_direction_input(pin);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static struct irq_domain_ops oxnas_gpio_ops = {
+	.map	= oxnas_gpio_irq_map,
+	.xlate	= oxnas_gpio_irq_domain_xlate,
+};
+
+static int oxnas_gpio_of_irq_setup(struct device_node *node,
+				  struct oxnas_gpio_chip *oxnas_gpio, unsigned int irq)
+{
+	/* Disable irqs of this controller */
+	writel_relaxed(0, oxnas_gpio->regbase + RE_IRQ_ENABLE);
+	writel_relaxed(0, oxnas_gpio->regbase + FE_IRQ_ENABLE);
+
+	/* Setup irq domain */
+	oxnas_gpio->domain = irq_domain_add_linear(node, oxnas_gpio->chip.ngpio,
+						&oxnas_gpio_ops, oxnas_gpio);
+	if (!oxnas_gpio->domain)
+		panic("oxnas_gpio: couldn't allocate irq domain (DT).\n");
+
+	irq_set_chip_data(irq, oxnas_gpio);
+	irq_set_chained_handler(irq, gpio_irq_handler);
+
+	return 0;
+}
+
+/* This structure is replicated for each GPIO block allocated at probe time */
+static struct gpio_chip oxnas_gpio_template = {
+	.request		= oxnas_gpio_request,
+	.free			= oxnas_gpio_free,
+	.direction_input	= oxnas_gpio_direction_input,
+	.get			= oxnas_gpio_get,
+	.direction_output	= oxnas_gpio_direction_output,
+	.set			= oxnas_gpio_set,
+	.to_irq			= oxnas_gpio_to_irq,
+	.dbg_show		= oxnas_gpio_dbg_show,
+	.can_sleep		= 0,
+	.ngpio			= MAX_NB_GPIO_PER_BANK,
+};
+
+static struct of_device_id oxnas_gpio_of_match[] = {
+	{ .compatible = "plxtech,nas782x-gpio"},
+	{ /* sentinel */ }
+};
+
+static int oxnas_gpio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+	struct oxnas_gpio_chip *oxnas_chip = NULL;
+	struct gpio_chip *chip;
+	struct pinctrl_gpio_range *range;
+	int ret = 0;
+	int irq, i;
+	int alias_idx = of_alias_get_id(np, "gpio");
+	uint32_t ngpio;
+	char **names;
+
+	BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));
+	if (gpio_chips[alias_idx]) {
+		ret = -EBUSY;
+		goto err;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ret = irq;
+		goto err;
+	}
+
+	oxnas_chip = devm_kzalloc(&pdev->dev, sizeof(*oxnas_chip), GFP_KERNEL);
+	if (!oxnas_chip) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	oxnas_chip->regbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(oxnas_chip->regbase)) {
+		ret = PTR_ERR(oxnas_chip->regbase);
+		goto err;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	oxnas_chip->ctrlbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(oxnas_chip->ctrlbase)) {
+		ret = PTR_ERR(oxnas_chip->ctrlbase);
+		goto err;
+	}
+
+	oxnas_chip->chip = oxnas_gpio_template;
+
+	chip = &oxnas_chip->chip;
+	chip->of_node = np;
+	chip->label = dev_name(&pdev->dev);
+	chip->dev = &pdev->dev;
+	chip->owner = THIS_MODULE;
+	chip->base = alias_idx * MAX_NB_GPIO_PER_BANK;
+
+	if (!of_property_read_u32(np, "#gpio-lines", &ngpio)) {
+		if (ngpio > MAX_NB_GPIO_PER_BANK)
+			pr_err("oxnas_gpio.%d, gpio-nb >= %d failback to %d\n",
+			       alias_idx, MAX_NB_GPIO_PER_BANK, MAX_NB_GPIO_PER_BANK);
+		else
+			chip->ngpio = ngpio;
+	}
+
+	names = devm_kzalloc(&pdev->dev, sizeof(char *) * chip->ngpio,
+			     GFP_KERNEL);
+
+	if (!names) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < chip->ngpio; i++)
+		names[i] = kasprintf(GFP_KERNEL, "MF_%c%d", alias_idx + 'A', i);
+
+	chip->names = (const char *const *)names;
+
+	range = &oxnas_chip->range;
+	range->name = chip->label;
+	range->id = alias_idx;
+	range->pin_base = range->base = range->id * MAX_NB_GPIO_PER_BANK;
+
+	range->npins = chip->ngpio;
+	range->gc = chip;
+
+	ret = gpiochip_add(chip);
+	if (ret)
+		goto err;
+
+	gpio_chips[alias_idx] = oxnas_chip;
+	gpio_banks = max(gpio_banks, alias_idx + 1);
+
+	oxnas_gpio_of_irq_setup(np, oxnas_chip, irq);
+
+	dev_info(&pdev->dev, "at address %p\n", oxnas_chip->regbase);
+
+	return 0;
+err:
+	dev_err(&pdev->dev, "Failure %i for GPIO %i\n", ret, alias_idx);
+
+	return ret;
+}
+
+static struct platform_driver oxnas_gpio_driver = {
+	.driver = {
+		.name = "gpio-oxnas",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(oxnas_gpio_of_match),
+	},
+	.probe = oxnas_gpio_probe,
+};
+
+static struct platform_driver oxnas_pinctrl_driver = {
+	.driver = {
+		.name = "pinctrl-oxnas",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(oxnas_pinctrl_of_match),
+	},
+	.probe = oxnas_pinctrl_probe,
+	.remove = oxnas_pinctrl_remove,
+};
+
+static int __init oxnas_pinctrl_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&oxnas_gpio_driver);
+	if (ret)
+		return ret;
+	return platform_driver_register(&oxnas_pinctrl_driver);
+}
+arch_initcall(oxnas_pinctrl_init);
+
+static void __exit oxnas_pinctrl_exit(void)
+{
+	platform_driver_unregister(&oxnas_pinctrl_driver);
+}
+
+module_exit(oxnas_pinctrl_exit);
+MODULE_AUTHOR("Ma Hajun <mahaijuns@gmail.com>");
+MODULE_DESCRIPTION("Plxtech Nas782x pinctrl driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/reset/core.c b/drivers/reset/core.c
--- a/drivers/reset/core.c	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/reset/core.c	2015-02-11 08:27:08.000000000 -0800
@@ -43,7 +43,7 @@
  * This simple translation function should be used for reset controllers
  * with 1:1 mapping, where reset lines can be indexed by number without gaps.
  */
-static int of_reset_simple_xlate(struct reset_controller_dev *rcdev,
+int of_reset_simple_xlate(struct reset_controller_dev *rcdev,
 			  const struct of_phandle_args *reset_spec)
 {
 	if (WARN_ON(reset_spec->args_count != rcdev->of_reset_n_cells))
@@ -54,6 +54,7 @@
 
 	return reset_spec->args[0];
 }
+EXPORT_SYMBOL_GPL(of_reset_simple_xlate);
 
 /**
  * reset_controller_register - register a reset controller device
@@ -164,7 +165,7 @@
 
 	if (!rcdev) {
 		mutex_unlock(&reset_controller_list_mutex);
-		return ERR_PTR(-EPROBE_DEFER);
+		return ERR_PTR(-ENODEV);
 	}
 
 	rstc_id = rcdev->of_xlate(rcdev, &args);
@@ -263,6 +264,33 @@
 }
 EXPORT_SYMBOL_GPL(devm_reset_control_get);
 
+static int devm_reset_control_match(struct device *dev, void *res, void *data)
+{
+	struct reset_control **rstc = res;
+	if (WARN_ON(!rstc || !*rstc))
+		return 0;
+	return *rstc == data;
+}
+
+/**
+ * devm_reset_control_put - resource managed reset_control_put()
+ * @rstc: reset controller to free
+ *
+ * Deallocate a reset control allocated withd devm_reset_control_get().
+ * This function will not need to be called normally, as devres will take
+ * care of freeing the resource.
+ */
+void devm_reset_control_put(struct reset_control *rstc)
+{
+	int ret;
+
+	ret = devres_release(rstc->dev, devm_reset_control_release,
+			     devm_reset_control_match, rstc);
+	if (ret)
+		WARN_ON(ret);
+}
+EXPORT_SYMBOL_GPL(devm_reset_control_put);
+
 /**
  * device_reset - find reset controller associated with the device
  *                and perform reset
diff -Naur a/drivers/reset/Kconfig b/drivers/reset/Kconfig
--- a/drivers/reset/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/reset/Kconfig	2015-02-11 08:27:08.000000000 -0800
@@ -12,4 +12,8 @@
 
 	  If unsure, say no.
 
+config RESET_CONTROLLER_OXNAS
+	bool
+	select RESET_CONTROLLER
+
 source "drivers/reset/sti/Kconfig"
diff -Naur a/drivers/reset/Makefile b/drivers/reset/Makefile
--- a/drivers/reset/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/reset/Makefile	2015-02-11 08:27:08.000000000 -0800
@@ -1,4 +1,5 @@
 obj-$(CONFIG_RESET_CONTROLLER) += core.o
+obj-$(CONFIG_RESET_CONTROLLER_OXNAS) += reset-ox820.o
 obj-$(CONFIG_ARCH_SOCFPGA) += reset-socfpga.o
 obj-$(CONFIG_ARCH_SUNXI) += reset-sunxi.o
 obj-$(CONFIG_ARCH_STI) += sti/
diff -Naur a/drivers/reset/reset-ox820.c b/drivers/reset/reset-ox820.c
--- a/drivers/reset/reset-ox820.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/reset/reset-ox820.c	2015-02-11 08:27:08.000000000 -0800
@@ -0,0 +1,107 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <mach/hardware.h>
+
+static int ox820_reset_reset(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	writel(BIT(id), SYS_CTRL_RST_SET_CTRL);
+	writel(BIT(id), SYS_CTRL_RST_CLR_CTRL);
+	return 0;
+}
+
+static int ox820_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	writel(BIT(id), SYS_CTRL_RST_SET_CTRL);
+
+	return 0;
+}
+
+static int ox820_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	writel(BIT(id), SYS_CTRL_RST_CLR_CTRL);
+
+	return 0;
+}
+
+static struct reset_control_ops ox820_reset_ops = {
+	.reset		= ox820_reset_reset,
+	.assert		= ox820_reset_assert,
+	.deassert	= ox820_reset_deassert,
+};
+
+static const struct of_device_id ox820_reset_dt_ids[] = {
+	 { .compatible = "plxtech,nas782x-reset", },
+	 { /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, ox820_reset_dt_ids);
+
+struct reset_controller_dev rcdev;
+
+static int ox820_reset_probe(struct platform_device *pdev)
+{
+	struct reset_controller_dev *rcdev;
+
+	rcdev = devm_kzalloc(&pdev->dev, sizeof(*rcdev), GFP_KERNEL);
+	if (!rcdev)
+		return -ENOMEM;
+
+	/* note: reset controller is statically mapped */
+
+	rcdev->owner = THIS_MODULE;
+	rcdev->nr_resets = 32;
+	rcdev->ops = &ox820_reset_ops;
+	rcdev->of_node = pdev->dev.of_node;
+	reset_controller_register(rcdev);
+	platform_set_drvdata(pdev, rcdev);
+
+	return 0;
+}
+
+static int ox820_reset_remove(struct platform_device *pdev)
+{
+	struct reset_controller_dev *rcdev = platform_get_drvdata(pdev);
+
+	reset_controller_unregister(rcdev);
+
+	return 0;
+}
+
+static struct platform_driver ox820_reset_driver = {
+	.probe	= ox820_reset_probe,
+	.remove	= ox820_reset_remove,
+	.driver = {
+		.name		= "ox820-reset",
+		.owner		= THIS_MODULE,
+		.of_match_table	= ox820_reset_dt_ids,
+	},
+};
+
+static int __init ox820_reset_init(void)
+{
+	return platform_driver_probe(&ox820_reset_driver,
+				     ox820_reset_probe);
+}
+/*
+ * reset controller does not support probe deferral, so it has to be 
+ * initialized before any user, in particular, PCIE uses subsys_initcall.
+ */
+arch_initcall(ox820_reset_init);
+
+MODULE_AUTHOR("Ma Haijun");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/usb/host/ehci-oxnas.c b/drivers/usb/host/ehci-oxnas.c
--- a/drivers/usb/host/ehci-oxnas.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/usb/host/ehci-oxnas.c	2015-02-11 08:27:08.000000000 -0800
@@ -0,0 +1,311 @@
+/*
+ * drivers/usb/host/ehci-oxnas.c
+ *
+ * Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <mach/hardware.h>
+#include <mach/utils.h>
+
+#include "ehci.h"
+
+struct oxnas_hcd {
+	struct clk *clk;
+	struct clk *refsrc;
+	struct clk *phyref;
+	int use_pllb;
+	int use_phya;
+	struct reset_control *rst_host;
+	struct reset_control *rst_phya;
+	struct reset_control *rst_phyb;
+};
+
+#define DRIVER_DESC "Oxnas On-Chip EHCI Host Controller"
+
+static struct hc_driver __read_mostly oxnas_hc_driver;
+
+static void start_oxnas_usb_ehci(struct oxnas_hcd *oxnas)
+{
+	u32 reg;
+
+	if (oxnas->use_pllb) {
+		/* enable pllb */
+		clk_prepare_enable(oxnas->refsrc);
+		/* enable ref600 */
+		clk_prepare_enable(oxnas->phyref);
+		/* 600MHz pllb divider for 12MHz */
+		writel(PLLB_DIV_INT(50) | PLLB_DIV_FRAC(0), SEC_CTRL_PLLB_DIV_CTRL);
+
+	} else {
+		/* ref 300 divider for 12MHz */
+		writel(REF300_DIV_INT(25) | REF300_DIV_FRAC(0), SYS_CTRL_REF300_DIV);
+	}
+
+	/* Ensure the USB block is properly reset */
+	reset_control_reset(oxnas->rst_host);
+	reset_control_reset(oxnas->rst_phya);
+	reset_control_reset(oxnas->rst_phyb);
+
+	/* Force the high speed clock to be generated all the time, via serial
+	 programming of the USB HS PHY */
+	writel((2UL << USBHSPHY_TEST_ADD) |
+		   (0xe0UL << USBHSPHY_TEST_DIN), SYS_CTRL_USBHSPHY_CTRL);
+
+	writel((1UL << USBHSPHY_TEST_CLK) |
+		   (2UL << USBHSPHY_TEST_ADD) |
+		   (0xe0UL << USBHSPHY_TEST_DIN), SYS_CTRL_USBHSPHY_CTRL);
+
+	writel((0xfUL << USBHSPHY_TEST_ADD) |
+		   (0xaaUL << USBHSPHY_TEST_DIN), SYS_CTRL_USBHSPHY_CTRL);
+
+	writel((1UL << USBHSPHY_TEST_CLK) |
+		   (0xfUL << USBHSPHY_TEST_ADD) |
+		   (0xaaUL << USBHSPHY_TEST_DIN), SYS_CTRL_USBHSPHY_CTRL);
+
+	if (oxnas->use_pllb) /* use pllb clock */
+		writel(USB_CLK_INTERNAL | USB_INT_CLK_PLLB, SYS_CTRL_USB_CTRL);
+	else /* use ref300 derived clock */
+		writel(USB_CLK_INTERNAL | USB_INT_CLK_REF300, SYS_CTRL_USB_CTRL);
+
+	if (oxnas->use_phya) {
+		/* Configure USB PHYA as a host */
+		reg = readl(SYS_CTRL_USB_CTRL);
+		reg &= ~USBAMUX_DEVICE;
+		writel(reg, SYS_CTRL_USB_CTRL);
+	}
+
+	/* Enable the clock to the USB block */
+	clk_prepare_enable(oxnas->clk);
+}
+
+static void stop_oxnas_usb_ehci(struct oxnas_hcd *oxnas)
+{
+	reset_control_assert(oxnas->rst_host);
+	reset_control_assert(oxnas->rst_phya);
+	reset_control_assert(oxnas->rst_phyb);
+
+	if (oxnas->use_pllb) {
+		clk_disable_unprepare(oxnas->phyref);
+		clk_disable_unprepare(oxnas->refsrc);
+	}
+	clk_disable_unprepare(oxnas->clk);
+}
+
+static int ehci_oxnas_reset(struct usb_hcd *hcd)
+{
+	#define  txttfill_tuning	reserved2[0]
+
+	struct ehci_hcd	*ehci;
+	u32 tmp;
+	int retval = ehci_setup(hcd);
+	if (retval)
+		return retval;
+
+	ehci = hcd_to_ehci(hcd);
+	tmp = ehci_readl(ehci, &ehci->regs->txfill_tuning);
+	tmp &= ~0x00ff0000;
+	tmp |= 0x003f0000; /* set burst pre load count to 0x40 (63 * 4 bytes)  */
+	tmp |= 0x16; /* set sheduler overhead to 22 * 1.267us (HS) or 22 * 6.33us (FS/LS)*/
+	ehci_writel(ehci, tmp,  &ehci->regs->txfill_tuning);
+
+	tmp = ehci_readl(ehci, &ehci->regs->txttfill_tuning);
+	tmp |= 0x2; /* set sheduler overhead to 2 * 6.333us */
+	ehci_writel(ehci, tmp,  &ehci->regs->txttfill_tuning);
+
+	return retval;
+}
+
+static int ehci_oxnas_drv_probe(struct platform_device *ofdev)
+{
+	struct device_node *np = ofdev->dev.of_node;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+	struct resource res;
+	struct oxnas_hcd *oxnas;
+	int irq, err;
+	struct reset_control *rstc;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	if (!ofdev->dev.dma_mask)
+		ofdev->dev.dma_mask = &ofdev->dev.coherent_dma_mask;
+	if (!ofdev->dev.coherent_dma_mask)
+		ofdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+	hcd = usb_create_hcd(&oxnas_hc_driver,	&ofdev->dev,
+					dev_name(&ofdev->dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	err = of_address_to_resource(np, 0, &res);
+	if (err)
+		goto err_res;
+
+	hcd->rsrc_start = res.start;
+	hcd->rsrc_len = resource_size(&res);
+
+	hcd->regs = devm_ioremap_resource(&ofdev->dev, &res);
+	if (IS_ERR(hcd->regs)) {
+		dev_err(&ofdev->dev, "devm_ioremap_resource failed\n");
+		err = PTR_ERR(hcd->regs);
+		goto err_ioremap;
+	}
+
+	oxnas = (struct oxnas_hcd *)hcd_to_ehci(hcd)->priv;
+
+	oxnas->use_pllb = of_property_read_bool(np, "plxtch,ehci_use_pllb");
+	oxnas->use_phya = of_property_read_bool(np, "plxtch,ehci_use_phya");
+
+	oxnas->clk = of_clk_get_by_name(np, "usb");
+	if (IS_ERR(oxnas->clk)) {
+		err = PTR_ERR(oxnas->clk);
+		goto err_clk;
+	}
+
+	if (oxnas->use_pllb) {
+		oxnas->refsrc = of_clk_get_by_name(np, "refsrc");
+		if (IS_ERR(oxnas->refsrc)) {
+			err = PTR_ERR(oxnas->refsrc);
+			goto err_refsrc;
+		}
+		oxnas->phyref = of_clk_get_by_name(np, "phyref");
+		if (IS_ERR(oxnas->refsrc)) {
+			err = PTR_ERR(oxnas->refsrc);
+			goto err_phyref;
+		}
+
+	} else {
+		oxnas->refsrc = NULL;
+		oxnas->phyref = NULL;
+	}
+
+	rstc = devm_reset_control_get(&ofdev->dev, "host");
+	if (IS_ERR(rstc)) {
+		err = PTR_ERR(rstc);
+		goto err_rst;
+	}
+	oxnas->rst_host = rstc;
+
+	rstc = devm_reset_control_get(&ofdev->dev, "phya");
+	if (IS_ERR(rstc)) {
+		err = PTR_ERR(rstc);
+		goto err_rst;
+	}
+	oxnas->rst_phya = rstc;
+
+	rstc = devm_reset_control_get(&ofdev->dev, "phyb");
+	if (IS_ERR(rstc)) {
+		err = PTR_ERR(rstc);
+		goto err_rst;
+	}
+	oxnas->rst_phyb = rstc;
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (!irq) {
+		dev_err(&ofdev->dev, "irq_of_parse_and_map failed\n");
+		err = -EBUSY;
+		goto err_irq;
+	}
+
+	hcd->has_tt = 1;
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+
+	start_oxnas_usb_ehci(oxnas);
+
+	err = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
+	if (err)
+		goto err_hcd;
+
+	return 0;
+
+err_hcd:
+	stop_oxnas_usb_ehci(oxnas);
+err_irq:
+err_rst:
+	if (oxnas->phyref) clk_put(oxnas->phyref);
+err_phyref:
+	if (oxnas->refsrc) clk_put(oxnas->refsrc);
+err_refsrc:
+	clk_put(oxnas->clk);
+err_clk:
+err_ioremap:
+err_res:
+	usb_put_hcd(hcd);
+
+	return err;
+}
+
+static int ehci_oxnas_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct oxnas_hcd *oxnas = (struct oxnas_hcd *)hcd_to_ehci(hcd)->priv;
+
+	usb_remove_hcd(hcd);
+	if (oxnas->use_pllb) {
+		clk_disable_unprepare(oxnas->phyref);
+		clk_put(oxnas->phyref);
+		clk_disable_unprepare(oxnas->refsrc);
+		clk_put(oxnas->refsrc);
+	}
+	clk_disable_unprepare(oxnas->clk);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static const struct of_device_id oxnas_ehci_dt_ids[] = {
+	{ .compatible = "plxtch,nas782x-ehci" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, oxnas_ehci_dt_ids);
+
+static struct platform_driver ehci_oxnas_driver = {
+	.probe		= ehci_oxnas_drv_probe,
+	.remove		= ehci_oxnas_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver.name	= "oxnas-ehci",
+	.driver.of_match_table	= oxnas_ehci_dt_ids,
+};
+
+static const struct ehci_driver_overrides oxnas_overrides __initdata = {
+	.reset = ehci_oxnas_reset,
+	.extra_priv_size = sizeof(struct oxnas_hcd),
+};
+
+static int __init ehci_oxnas_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	ehci_init_driver(&oxnas_hc_driver, &oxnas_overrides);
+	return platform_driver_register(&ehci_oxnas_driver);
+}
+module_init(ehci_oxnas_init);
+
+static void __exit ehci_oxnas_cleanup(void)
+{
+	platform_driver_unregister(&ehci_oxnas_driver);
+}
+module_exit(ehci_oxnas_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_ALIAS("platform:oxnas-ehci");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
--- a/drivers/usb/host/Kconfig	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/usb/host/Kconfig	2015-02-11 08:27:08.000000000 -0800
@@ -302,6 +302,13 @@
 	  USB 2.0 device support.  All CN6XXX based chips with USB are
 	  supported.
 
+config USB_EHCI_OXNAS
+	tristate "OXNAS EHCI Module"
+	depends on USB_EHCI_HCD && ARCH_OXNAS
+	select USB_EHCI_ROOT_HUB_TT
+	---help---
+	  Enable support for the OX820 SOC's on-chip EHCI controller.
+
 endif # USB_EHCI_HCD
 
 config USB_OXU210HP_HCD
diff -Naur a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
--- a/drivers/usb/host/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/usb/host/Makefile	2015-02-11 08:27:08.000000000 -0800
@@ -78,4 +78,5 @@
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FUSBH200_HCD)	+= fusbh200-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
+obj-$(CONFIG_USB_EHCI_OXNAS)	+= ehci-oxnas.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
diff -Naur a/drivers/watchdog/intel_scu_watchdog.c b/drivers/watchdog/intel_scu_watchdog.c
--- a/drivers/watchdog/intel_scu_watchdog.c	2015-01-29 17:41:03.000000000 -0800
+++ b/drivers/watchdog/intel_scu_watchdog.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,565 +0,0 @@
-/*
- *      Intel_SCU 0.2:  An Intel SCU IOH Based Watchdog Device
- *			for Intel part #(s):
- *				- AF82MP20 PCH
- *
- *      Copyright (C) 2009-2010 Intel Corporation. All rights reserved.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of version 2 of the GNU General
- *      Public License as published by the Free Software Foundation.
- *
- *      This program is distributed in the hope that it will be
- *      useful, but WITHOUT ANY WARRANTY; without even the implied
- *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- *      PURPOSE.  See the GNU General Public License for more details.
- *      You should have received a copy of the GNU General Public
- *      License along with this program; if not, write to the Free
- *      Software Foundation, Inc., 59 Temple Place - Suite 330,
- *      Boston, MA  02111-1307, USA.
- *      The full GNU General Public License is included in this
- *      distribution in the file called COPYING.
- *
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/compiler.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/moduleparam.h>
-#include <linux/types.h>
-#include <linux/miscdevice.h>
-#include <linux/watchdog.h>
-#include <linux/fs.h>
-#include <linux/notifier.h>
-#include <linux/reboot.h>
-#include <linux/init.h>
-#include <linux/jiffies.h>
-#include <linux/uaccess.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
-#include <linux/sfi.h>
-#include <asm/irq.h>
-#include <linux/atomic.h>
-#include <asm/intel_scu_ipc.h>
-#include <asm/apb_timer.h>
-#include <asm/intel-mid.h>
-
-#include "intel_scu_watchdog.h"
-
-/* Bounds number of times we will retry loading time count */
-/* This retry is a work around for a silicon bug.	   */
-#define MAX_RETRY 16
-
-#define IPC_SET_WATCHDOG_TIMER	0xF8
-
-static int timer_margin = DEFAULT_SOFT_TO_HARD_MARGIN;
-module_param(timer_margin, int, 0);
-MODULE_PARM_DESC(timer_margin,
-		"Watchdog timer margin"
-		"Time between interrupt and resetting the system"
-		"The range is from 1 to 160"
-		"This is the time for all keep alives to arrive");
-
-static int timer_set = DEFAULT_TIME;
-module_param(timer_set, int, 0);
-MODULE_PARM_DESC(timer_set,
-		"Default Watchdog timer setting"
-		"Complete cycle time"
-		"The range is from 1 to 170"
-		"This is the time for all keep alives to arrive");
-
-/* After watchdog device is closed, check force_boot. If:
- * force_boot == 0, then force boot on next watchdog interrupt after close,
- * force_boot == 1, then force boot immediately when device is closed.
- */
-static int force_boot;
-module_param(force_boot, int, 0);
-MODULE_PARM_DESC(force_boot,
-		"A value of 1 means that the driver will reboot"
-		"the system immediately if the /dev/watchdog device is closed"
-		"A value of 0 means that when /dev/watchdog device is closed"
-		"the watchdog timer will be refreshed for one more interval"
-		"of length: timer_set. At the end of this interval, the"
-		"watchdog timer will reset the system."
-		);
-
-/* there is only one device in the system now; this can be made into
- * an array in the future if we have more than one device */
-
-static struct intel_scu_watchdog_dev watchdog_device;
-
-/* Forces restart, if force_reboot is set */
-static void watchdog_fire(void)
-{
-	if (force_boot) {
-		pr_crit("Initiating system reboot\n");
-		emergency_restart();
-		pr_crit("Reboot didn't ?????\n");
-	}
-
-	else {
-		pr_crit("Immediate Reboot Disabled\n");
-		pr_crit("System will reset when watchdog timer times out!\n");
-	}
-}
-
-static int check_timer_margin(int new_margin)
-{
-	if ((new_margin < MIN_TIME_CYCLE) ||
-	    (new_margin > MAX_TIME - timer_set)) {
-		pr_debug("value of new_margin %d is out of the range %d to %d\n",
-			 new_margin, MIN_TIME_CYCLE, MAX_TIME - timer_set);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/*
- * IPC operations
- */
-static int watchdog_set_ipc(int soft_threshold, int threshold)
-{
-	u32	*ipc_wbuf;
-	u8	 cbuf[16] = { '\0' };
-	int	 ipc_ret = 0;
-
-	ipc_wbuf = (u32 *)&cbuf;
-	ipc_wbuf[0] = soft_threshold;
-	ipc_wbuf[1] = threshold;
-
-	ipc_ret = intel_scu_ipc_command(
-			IPC_SET_WATCHDOG_TIMER,
-			0,
-			ipc_wbuf,
-			2,
-			NULL,
-			0);
-
-	if (ipc_ret != 0)
-		pr_err("Error setting SCU watchdog timer: %x\n", ipc_ret);
-
-	return ipc_ret;
-};
-
-/*
- *      Intel_SCU operations
- */
-
-/* timer interrupt handler */
-static irqreturn_t watchdog_timer_interrupt(int irq, void *dev_id)
-{
-	int int_status;
-	int_status = ioread32(watchdog_device.timer_interrupt_status_addr);
-
-	pr_debug("irq, int_status: %x\n", int_status);
-
-	if (int_status != 0)
-		return IRQ_NONE;
-
-	/* has the timer been started? If not, then this is spurious */
-	if (watchdog_device.timer_started == 0) {
-		pr_debug("spurious interrupt received\n");
-		return IRQ_HANDLED;
-	}
-
-	/* temporarily disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-
-	/* set the timer to the threshold */
-	iowrite32(watchdog_device.threshold,
-		  watchdog_device.timer_load_count_addr);
-
-	/* allow the timer to run */
-	iowrite32(0x00000003, watchdog_device.timer_control_addr);
-
-	return IRQ_HANDLED;
-}
-
-static int intel_scu_keepalive(void)
-{
-
-	/* read eoi register - clears interrupt */
-	ioread32(watchdog_device.timer_clear_interrupt_addr);
-
-	/* temporarily disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-
-	/* set the timer to the soft_threshold */
-	iowrite32(watchdog_device.soft_threshold,
-		  watchdog_device.timer_load_count_addr);
-
-	/* allow the timer to run */
-	iowrite32(0x00000003, watchdog_device.timer_control_addr);
-
-	return 0;
-}
-
-static int intel_scu_stop(void)
-{
-	iowrite32(0, watchdog_device.timer_control_addr);
-	return 0;
-}
-
-static int intel_scu_set_heartbeat(u32 t)
-{
-	int			 ipc_ret;
-	int			 retry_count;
-	u32			 soft_value;
-	u32			 hw_value;
-
-	watchdog_device.timer_set = t;
-	watchdog_device.threshold =
-		timer_margin * watchdog_device.timer_tbl_ptr->freq_hz;
-	watchdog_device.soft_threshold =
-		(watchdog_device.timer_set - timer_margin)
-		* watchdog_device.timer_tbl_ptr->freq_hz;
-
-	pr_debug("set_heartbeat: timer freq is %d\n",
-		 watchdog_device.timer_tbl_ptr->freq_hz);
-	pr_debug("set_heartbeat: timer_set is %x (hex)\n",
-		 watchdog_device.timer_set);
-	pr_debug("set_hearbeat: timer_margin is %x (hex)\n", timer_margin);
-	pr_debug("set_heartbeat: threshold is %x (hex)\n",
-		 watchdog_device.threshold);
-	pr_debug("set_heartbeat: soft_threshold is %x (hex)\n",
-		 watchdog_device.soft_threshold);
-
-	/* Adjust thresholds by FREQ_ADJUSTMENT factor, to make the */
-	/* watchdog timing come out right. */
-	watchdog_device.threshold =
-		watchdog_device.threshold / FREQ_ADJUSTMENT;
-	watchdog_device.soft_threshold =
-		watchdog_device.soft_threshold / FREQ_ADJUSTMENT;
-
-	/* temporarily disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-
-	/* send the threshold and soft_threshold via IPC to the processor */
-	ipc_ret = watchdog_set_ipc(watchdog_device.soft_threshold,
-				   watchdog_device.threshold);
-
-	if (ipc_ret != 0) {
-		/* Make sure the watchdog timer is stopped */
-		intel_scu_stop();
-		return ipc_ret;
-	}
-
-	/* Soft Threshold set loop. Early versions of silicon did */
-	/* not always set this count correctly.  This loop checks */
-	/* the value and retries if it was not set correctly.     */
-
-	retry_count = 0;
-	soft_value = watchdog_device.soft_threshold & 0xFFFF0000;
-	do {
-
-		/* Make sure timer is stopped */
-		intel_scu_stop();
-
-		if (MAX_RETRY < retry_count++) {
-			/* Unable to set timer value */
-			pr_err("Unable to set timer\n");
-			return -ENODEV;
-		}
-
-		/* set the timer to the soft threshold */
-		iowrite32(watchdog_device.soft_threshold,
-			watchdog_device.timer_load_count_addr);
-
-		/* read count value before starting timer */
-		ioread32(watchdog_device.timer_load_count_addr);
-
-		/* Start the timer */
-		iowrite32(0x00000003, watchdog_device.timer_control_addr);
-
-		/* read the value the time loaded into its count reg */
-		hw_value = ioread32(watchdog_device.timer_load_count_addr);
-		hw_value = hw_value & 0xFFFF0000;
-
-
-	} while (soft_value != hw_value);
-
-	watchdog_device.timer_started = 1;
-
-	return 0;
-}
-
-/*
- * /dev/watchdog handling
- */
-
-static int intel_scu_open(struct inode *inode, struct file *file)
-{
-
-	/* Set flag to indicate that watchdog device is open */
-	if (test_and_set_bit(0, &watchdog_device.driver_open))
-		return -EBUSY;
-
-	/* Check for reopen of driver. Reopens are not allowed */
-	if (watchdog_device.driver_closed)
-		return -EPERM;
-
-	return nonseekable_open(inode, file);
-}
-
-static int intel_scu_release(struct inode *inode, struct file *file)
-{
-	/*
-	 * This watchdog should not be closed, after the timer
-	 * is started with the WDIPC_SETTIMEOUT ioctl
-	 * If force_boot is set watchdog_fire() will cause an
-	 * immediate reset. If force_boot is not set, the watchdog
-	 * timer is refreshed for one more interval. At the end
-	 * of that interval, the watchdog timer will reset the system.
-	 */
-
-	if (!test_and_clear_bit(0, &watchdog_device.driver_open)) {
-		pr_debug("intel_scu_release, without open\n");
-		return -ENOTTY;
-	}
-
-	if (!watchdog_device.timer_started) {
-		/* Just close, since timer has not been started */
-		pr_debug("closed, without starting timer\n");
-		return 0;
-	}
-
-	pr_crit("Unexpected close of /dev/watchdog!\n");
-
-	/* Since the timer was started, prevent future reopens */
-	watchdog_device.driver_closed = 1;
-
-	/* Refresh the timer for one more interval */
-	intel_scu_keepalive();
-
-	/* Reboot system (if force_boot is set) */
-	watchdog_fire();
-
-	/* We should only reach this point if force_boot is not set */
-	return 0;
-}
-
-static ssize_t intel_scu_write(struct file *file,
-			      char const *data,
-			      size_t len,
-			      loff_t *ppos)
-{
-
-	if (watchdog_device.timer_started)
-		/* Watchdog already started, keep it alive */
-		intel_scu_keepalive();
-	else
-		/* Start watchdog with timer value set by init */
-		intel_scu_set_heartbeat(watchdog_device.timer_set);
-
-	return len;
-}
-
-static long intel_scu_ioctl(struct file *file,
-			   unsigned int cmd,
-			   unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	u32 __user *p = argp;
-	u32 new_margin;
-
-
-	static const struct watchdog_info ident = {
-		.options =          WDIOF_SETTIMEOUT
-				    | WDIOF_KEEPALIVEPING,
-		.firmware_version = 0,  /* @todo Get from SCU via
-						 ipc_get_scu_fw_version()? */
-		.identity =         "Intel_SCU IOH Watchdog"  /* len < 32 */
-	};
-
-	switch (cmd) {
-	case WDIOC_GETSUPPORT:
-		return copy_to_user(argp,
-				    &ident,
-				    sizeof(ident)) ? -EFAULT : 0;
-	case WDIOC_GETSTATUS:
-	case WDIOC_GETBOOTSTATUS:
-		return put_user(0, p);
-	case WDIOC_KEEPALIVE:
-		intel_scu_keepalive();
-
-		return 0;
-	case WDIOC_SETTIMEOUT:
-		if (get_user(new_margin, p))
-			return -EFAULT;
-
-		if (check_timer_margin(new_margin))
-			return -EINVAL;
-
-		if (intel_scu_set_heartbeat(new_margin))
-			return -EINVAL;
-		return 0;
-	case WDIOC_GETTIMEOUT:
-		return put_user(watchdog_device.soft_threshold, p);
-
-	default:
-		return -ENOTTY;
-	}
-}
-
-/*
- *      Notifier for system down
- */
-static int intel_scu_notify_sys(struct notifier_block *this,
-			       unsigned long code,
-			       void *another_unused)
-{
-	if (code == SYS_DOWN || code == SYS_HALT)
-		/* Turn off the watchdog timer. */
-		intel_scu_stop();
-	return NOTIFY_DONE;
-}
-
-/*
- *      Kernel Interfaces
- */
-static const struct file_operations intel_scu_fops = {
-	.owner          = THIS_MODULE,
-	.llseek         = no_llseek,
-	.write          = intel_scu_write,
-	.unlocked_ioctl = intel_scu_ioctl,
-	.open           = intel_scu_open,
-	.release        = intel_scu_release,
-};
-
-static int __init intel_scu_watchdog_init(void)
-{
-	int ret;
-	u32 __iomem *tmp_addr;
-
-	/*
-	 * We don't really need to check this as the SFI timer get will fail
-	 * but if we do so we can exit with a clearer reason and no noise.
-	 *
-	 * If it isn't an intel MID device then it doesn't have this watchdog
-	 */
-	if (!intel_mid_identify_cpu())
-		return -ENODEV;
-
-	/* Check boot parameters to verify that their initial values */
-	/* are in range. */
-	/* Check value of timer_set boot parameter */
-	if ((timer_set < MIN_TIME_CYCLE) ||
-	    (timer_set > MAX_TIME - MIN_TIME_CYCLE)) {
-		pr_err("value of timer_set %x (hex) is out of range from %x to %x (hex)\n",
-		       timer_set, MIN_TIME_CYCLE, MAX_TIME - MIN_TIME_CYCLE);
-		return -EINVAL;
-	}
-
-	/* Check value of timer_margin boot parameter */
-	if (check_timer_margin(timer_margin))
-		return -EINVAL;
-
-	watchdog_device.timer_tbl_ptr = sfi_get_mtmr(sfi_mtimer_num-1);
-
-	if (watchdog_device.timer_tbl_ptr == NULL) {
-		pr_debug("timer is not available\n");
-		return -ENODEV;
-	}
-	/* make sure the timer exists */
-	if (watchdog_device.timer_tbl_ptr->phys_addr == 0) {
-		pr_debug("timer %d does not have valid physical memory\n",
-			 sfi_mtimer_num);
-		return -ENODEV;
-	}
-
-	if (watchdog_device.timer_tbl_ptr->irq == 0) {
-		pr_debug("timer %d invalid irq\n", sfi_mtimer_num);
-		return -ENODEV;
-	}
-
-	tmp_addr = ioremap_nocache(watchdog_device.timer_tbl_ptr->phys_addr,
-			20);
-
-	if (tmp_addr == NULL) {
-		pr_debug("timer unable to ioremap\n");
-		return -ENOMEM;
-	}
-
-	watchdog_device.timer_load_count_addr = tmp_addr++;
-	watchdog_device.timer_current_value_addr = tmp_addr++;
-	watchdog_device.timer_control_addr = tmp_addr++;
-	watchdog_device.timer_clear_interrupt_addr = tmp_addr++;
-	watchdog_device.timer_interrupt_status_addr = tmp_addr++;
-
-	/* Set the default time values in device structure */
-
-	watchdog_device.timer_set = timer_set;
-	watchdog_device.threshold =
-		timer_margin * watchdog_device.timer_tbl_ptr->freq_hz;
-	watchdog_device.soft_threshold =
-		(watchdog_device.timer_set - timer_margin)
-		* watchdog_device.timer_tbl_ptr->freq_hz;
-
-
-	watchdog_device.intel_scu_notifier.notifier_call =
-		intel_scu_notify_sys;
-
-	ret = register_reboot_notifier(&watchdog_device.intel_scu_notifier);
-	if (ret) {
-		pr_err("cannot register notifier %d)\n", ret);
-		goto register_reboot_error;
-	}
-
-	watchdog_device.miscdev.minor = WATCHDOG_MINOR;
-	watchdog_device.miscdev.name = "watchdog";
-	watchdog_device.miscdev.fops = &intel_scu_fops;
-
-	ret = misc_register(&watchdog_device.miscdev);
-	if (ret) {
-		pr_err("cannot register miscdev %d err =%d\n",
-		       WATCHDOG_MINOR, ret);
-		goto misc_register_error;
-	}
-
-	ret = request_irq((unsigned int)watchdog_device.timer_tbl_ptr->irq,
-		watchdog_timer_interrupt,
-		IRQF_SHARED, "watchdog",
-		&watchdog_device.timer_load_count_addr);
-	if (ret) {
-		pr_err("error requesting irq %d\n", ret);
-		goto request_irq_error;
-	}
-	/* Make sure timer is disabled before returning */
-	intel_scu_stop();
-	return 0;
-
-/* error cleanup */
-
-request_irq_error:
-	misc_deregister(&watchdog_device.miscdev);
-misc_register_error:
-	unregister_reboot_notifier(&watchdog_device.intel_scu_notifier);
-register_reboot_error:
-	intel_scu_stop();
-	iounmap(watchdog_device.timer_load_count_addr);
-	return ret;
-}
-
-static void __exit intel_scu_watchdog_exit(void)
-{
-
-	misc_deregister(&watchdog_device.miscdev);
-	unregister_reboot_notifier(&watchdog_device.intel_scu_notifier);
-	/* disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-	iounmap(watchdog_device.timer_load_count_addr);
-}
-
-late_initcall(intel_scu_watchdog_init);
-module_exit(intel_scu_watchdog_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("Intel SCU Watchdog Device Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(WDT_VER);
diff -Naur a/include/linux/reset.h b/include/linux/reset.h
--- a/include/linux/reset.h	2015-01-29 17:41:03.000000000 -0800
+++ b/include/linux/reset.h	2015-02-11 08:27:08.000000000 -0800
@@ -1,6 +1,8 @@
 #ifndef _LINUX_RESET_H_
 #define _LINUX_RESET_H_
 
+#include <linux/of.h>
+
 struct device;
 struct device_node;
 struct reset_control;
@@ -11,6 +13,8 @@
 int reset_control_assert(struct reset_control *rstc);
 int reset_control_deassert(struct reset_control *rstc);
 
+struct reset_control *of_reset_control_get(struct device_node *node,
+					   const char *id);
 struct reset_control *reset_control_get(struct device *dev, const char *id);
 void reset_control_put(struct reset_control *rstc);
 struct reset_control *devm_reset_control_get(struct device *dev, const char *id);
diff -Naur a/net/key/af_key.c b/net/key/af_key.c
--- a/net/key/af_key.c	2015-01-29 17:41:03.000000000 -0800
+++ b/net/key/af_key.c	2015-02-11 08:27:14.000000000 -0800
@@ -1,3873 +0,0 @@
-/*
- * net/key/af_key.c	An implementation of PF_KEYv2 sockets.
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- * Authors:	Maxim Giryaev	<gem@asplinux.ru>
- *		David S. Miller	<davem@redhat.com>
- *		Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
- *		Kunihiro Ishiguro <kunihiro@ipinfusion.com>
- *		Kazunori MIYAZAWA / USAGI Project <miyazawa@linux-ipv6.org>
- *		Derek Atkins <derek@ihtfp.com>
- */
-
-#include <linux/capability.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/socket.h>
-#include <linux/pfkeyv2.h>
-#include <linux/ipsec.h>
-#include <linux/skbuff.h>
-#include <linux/rtnetlink.h>
-#include <linux/in.h>
-#include <linux/in6.h>
-#include <linux/proc_fs.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <net/net_namespace.h>
-#include <net/netns/generic.h>
-#include <net/xfrm.h>
-
-#include <net/sock.h>
-
-#define _X2KEY(x) ((x) == XFRM_INF ? 0 : (x))
-#define _KEY2X(x) ((x) == 0 ? XFRM_INF : (x))
-
-static int pfkey_net_id __read_mostly;
-struct netns_pfkey {
-	/* List of all pfkey sockets. */
-	struct hlist_head table;
-	atomic_t socks_nr;
-};
-static DEFINE_MUTEX(pfkey_mutex);
-
-#define DUMMY_MARK 0
-static const struct xfrm_mark dummy_mark = {0, 0};
-struct pfkey_sock {
-	/* struct sock must be the first member of struct pfkey_sock */
-	struct sock	sk;
-	int		registered;
-	int		promisc;
-
-	struct {
-		uint8_t		msg_version;
-		uint32_t	msg_portid;
-		int		(*dump)(struct pfkey_sock *sk);
-		void		(*done)(struct pfkey_sock *sk);
-		union {
-			struct xfrm_policy_walk	policy;
-			struct xfrm_state_walk	state;
-		} u;
-		struct sk_buff	*skb;
-	} dump;
-};
-
-static inline struct pfkey_sock *pfkey_sk(struct sock *sk)
-{
-	return (struct pfkey_sock *)sk;
-}
-
-static int pfkey_can_dump(const struct sock *sk)
-{
-	if (3 * atomic_read(&sk->sk_rmem_alloc) <= 2 * sk->sk_rcvbuf)
-		return 1;
-	return 0;
-}
-
-static void pfkey_terminate_dump(struct pfkey_sock *pfk)
-{
-	if (pfk->dump.dump) {
-		if (pfk->dump.skb) {
-			kfree_skb(pfk->dump.skb);
-			pfk->dump.skb = NULL;
-		}
-		pfk->dump.done(pfk);
-		pfk->dump.dump = NULL;
-		pfk->dump.done = NULL;
-	}
-}
-
-static void pfkey_sock_destruct(struct sock *sk)
-{
-	struct net *net = sock_net(sk);
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-
-	pfkey_terminate_dump(pfkey_sk(sk));
-	skb_queue_purge(&sk->sk_receive_queue);
-
-	if (!sock_flag(sk, SOCK_DEAD)) {
-		pr_err("Attempt to release alive pfkey socket: %p\n", sk);
-		return;
-	}
-
-	WARN_ON(atomic_read(&sk->sk_rmem_alloc));
-	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
-
-	atomic_dec(&net_pfkey->socks_nr);
-}
-
-static const struct proto_ops pfkey_ops;
-
-static void pfkey_insert(struct sock *sk)
-{
-	struct net *net = sock_net(sk);
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-
-	mutex_lock(&pfkey_mutex);
-	sk_add_node_rcu(sk, &net_pfkey->table);
-	mutex_unlock(&pfkey_mutex);
-}
-
-static void pfkey_remove(struct sock *sk)
-{
-	mutex_lock(&pfkey_mutex);
-	sk_del_node_init_rcu(sk);
-	mutex_unlock(&pfkey_mutex);
-}
-
-static struct proto key_proto = {
-	.name	  = "KEY",
-	.owner	  = THIS_MODULE,
-	.obj_size = sizeof(struct pfkey_sock),
-};
-
-static int pfkey_create(struct net *net, struct socket *sock, int protocol,
-			int kern)
-{
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-	struct sock *sk;
-	int err;
-
-	if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
-		return -EPERM;
-	if (sock->type != SOCK_RAW)
-		return -ESOCKTNOSUPPORT;
-	if (protocol != PF_KEY_V2)
-		return -EPROTONOSUPPORT;
-
-	err = -ENOMEM;
-	sk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto);
-	if (sk == NULL)
-		goto out;
-
-	sock->ops = &pfkey_ops;
-	sock_init_data(sock, sk);
-
-	sk->sk_family = PF_KEY;
-	sk->sk_destruct = pfkey_sock_destruct;
-
-	atomic_inc(&net_pfkey->socks_nr);
-
-	pfkey_insert(sk);
-
-	return 0;
-out:
-	return err;
-}
-
-static int pfkey_release(struct socket *sock)
-{
-	struct sock *sk = sock->sk;
-
-	if (!sk)
-		return 0;
-
-	pfkey_remove(sk);
-
-	sock_orphan(sk);
-	sock->sk = NULL;
-	skb_queue_purge(&sk->sk_write_queue);
-
-	synchronize_rcu();
-	sock_put(sk);
-
-	return 0;
-}
-
-static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,
-			       gfp_t allocation, struct sock *sk)
-{
-	int err = -ENOBUFS;
-
-	sock_hold(sk);
-	if (*skb2 == NULL) {
-		if (atomic_read(&skb->users) != 1) {
-			*skb2 = skb_clone(skb, allocation);
-		} else {
-			*skb2 = skb;
-			atomic_inc(&skb->users);
-		}
-	}
-	if (*skb2 != NULL) {
-		if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf) {
-			skb_set_owner_r(*skb2, sk);
-			skb_queue_tail(&sk->sk_receive_queue, *skb2);
-			sk->sk_data_ready(sk);
-			*skb2 = NULL;
-			err = 0;
-		}
-	}
-	sock_put(sk);
-	return err;
-}
-
-/* Send SKB to all pfkey sockets matching selected criteria.  */
-#define BROADCAST_ALL		0
-#define BROADCAST_ONE		1
-#define BROADCAST_REGISTERED	2
-#define BROADCAST_PROMISC_ONLY	4
-static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,
-			   int broadcast_flags, struct sock *one_sk,
-			   struct net *net)
-{
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-	struct sock *sk;
-	struct sk_buff *skb2 = NULL;
-	int err = -ESRCH;
-
-	/* XXX Do we need something like netlink_overrun?  I think
-	 * XXX PF_KEY socket apps will not mind current behavior.
-	 */
-	if (!skb)
-		return -ENOMEM;
-
-	rcu_read_lock();
-	sk_for_each_rcu(sk, &net_pfkey->table) {
-		struct pfkey_sock *pfk = pfkey_sk(sk);
-		int err2;
-
-		/* Yes, it means that if you are meant to receive this
-		 * pfkey message you receive it twice as promiscuous
-		 * socket.
-		 */
-		if (pfk->promisc)
-			pfkey_broadcast_one(skb, &skb2, allocation, sk);
-
-		/* the exact target will be processed later */
-		if (sk == one_sk)
-			continue;
-		if (broadcast_flags != BROADCAST_ALL) {
-			if (broadcast_flags & BROADCAST_PROMISC_ONLY)
-				continue;
-			if ((broadcast_flags & BROADCAST_REGISTERED) &&
-			    !pfk->registered)
-				continue;
-			if (broadcast_flags & BROADCAST_ONE)
-				continue;
-		}
-
-		err2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);
-
-		/* Error is cleare after succecful sending to at least one
-		 * registered KM */
-		if ((broadcast_flags & BROADCAST_REGISTERED) && err)
-			err = err2;
-	}
-	rcu_read_unlock();
-
-	if (one_sk != NULL)
-		err = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);
-
-	kfree_skb(skb2);
-	kfree_skb(skb);
-	return err;
-}
-
-static int pfkey_do_dump(struct pfkey_sock *pfk)
-{
-	struct sadb_msg *hdr;
-	int rc;
-
-	rc = pfk->dump.dump(pfk);
-	if (rc == -ENOBUFS)
-		return 0;
-
-	if (pfk->dump.skb) {
-		if (!pfkey_can_dump(&pfk->sk))
-			return 0;
-
-		hdr = (struct sadb_msg *) pfk->dump.skb->data;
-		hdr->sadb_msg_seq = 0;
-		hdr->sadb_msg_errno = rc;
-		pfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,
-				&pfk->sk, sock_net(&pfk->sk));
-		pfk->dump.skb = NULL;
-	}
-
-	pfkey_terminate_dump(pfk);
-	return rc;
-}
-
-static inline void pfkey_hdr_dup(struct sadb_msg *new,
-				 const struct sadb_msg *orig)
-{
-	*new = *orig;
-}
-
-static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)
-{
-	struct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);
-	struct sadb_msg *hdr;
-
-	if (!skb)
-		return -ENOBUFS;
-
-	/* Woe be to the platform trying to support PFKEY yet
-	 * having normal errnos outside the 1-255 range, inclusive.
-	 */
-	err = -err;
-	if (err == ERESTARTSYS ||
-	    err == ERESTARTNOHAND ||
-	    err == ERESTARTNOINTR)
-		err = EINTR;
-	if (err >= 512)
-		err = EINVAL;
-	BUG_ON(err <= 0 || err >= 256);
-
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	pfkey_hdr_dup(hdr, orig);
-	hdr->sadb_msg_errno = (uint8_t) err;
-	hdr->sadb_msg_len = (sizeof(struct sadb_msg) /
-			     sizeof(uint64_t));
-
-	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));
-
-	return 0;
-}
-
-static const u8 sadb_ext_min_len[] = {
-	[SADB_EXT_RESERVED]		= (u8) 0,
-	[SADB_EXT_SA]			= (u8) sizeof(struct sadb_sa),
-	[SADB_EXT_LIFETIME_CURRENT]	= (u8) sizeof(struct sadb_lifetime),
-	[SADB_EXT_LIFETIME_HARD]	= (u8) sizeof(struct sadb_lifetime),
-	[SADB_EXT_LIFETIME_SOFT]	= (u8) sizeof(struct sadb_lifetime),
-	[SADB_EXT_ADDRESS_SRC]		= (u8) sizeof(struct sadb_address),
-	[SADB_EXT_ADDRESS_DST]		= (u8) sizeof(struct sadb_address),
-	[SADB_EXT_ADDRESS_PROXY]	= (u8) sizeof(struct sadb_address),
-	[SADB_EXT_KEY_AUTH]		= (u8) sizeof(struct sadb_key),
-	[SADB_EXT_KEY_ENCRYPT]		= (u8) sizeof(struct sadb_key),
-	[SADB_EXT_IDENTITY_SRC]		= (u8) sizeof(struct sadb_ident),
-	[SADB_EXT_IDENTITY_DST]		= (u8) sizeof(struct sadb_ident),
-	[SADB_EXT_SENSITIVITY]		= (u8) sizeof(struct sadb_sens),
-	[SADB_EXT_PROPOSAL]		= (u8) sizeof(struct sadb_prop),
-	[SADB_EXT_SUPPORTED_AUTH]	= (u8) sizeof(struct sadb_supported),
-	[SADB_EXT_SUPPORTED_ENCRYPT]	= (u8) sizeof(struct sadb_supported),
-	[SADB_EXT_SPIRANGE]		= (u8) sizeof(struct sadb_spirange),
-	[SADB_X_EXT_KMPRIVATE]		= (u8) sizeof(struct sadb_x_kmprivate),
-	[SADB_X_EXT_POLICY]		= (u8) sizeof(struct sadb_x_policy),
-	[SADB_X_EXT_SA2]		= (u8) sizeof(struct sadb_x_sa2),
-	[SADB_X_EXT_NAT_T_TYPE]		= (u8) sizeof(struct sadb_x_nat_t_type),
-	[SADB_X_EXT_NAT_T_SPORT]	= (u8) sizeof(struct sadb_x_nat_t_port),
-	[SADB_X_EXT_NAT_T_DPORT]	= (u8) sizeof(struct sadb_x_nat_t_port),
-	[SADB_X_EXT_NAT_T_OA]		= (u8) sizeof(struct sadb_address),
-	[SADB_X_EXT_SEC_CTX]		= (u8) sizeof(struct sadb_x_sec_ctx),
-	[SADB_X_EXT_KMADDRESS]		= (u8) sizeof(struct sadb_x_kmaddress),
-	[SADB_X_EXT_FILTER]		= (u8) sizeof(struct sadb_x_filter),
-};
-
-/* Verify sadb_address_{len,prefixlen} against sa_family.  */
-static int verify_address_len(const void *p)
-{
-	const struct sadb_address *sp = p;
-	const struct sockaddr *addr = (const struct sockaddr *)(sp + 1);
-	const struct sockaddr_in *sin;
-#if IS_ENABLED(CONFIG_IPV6)
-	const struct sockaddr_in6 *sin6;
-#endif
-	int len;
-
-	switch (addr->sa_family) {
-	case AF_INET:
-		len = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin), sizeof(uint64_t));
-		if (sp->sadb_address_len != len ||
-		    sp->sadb_address_prefixlen > 32)
-			return -EINVAL;
-		break;
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-		len = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin6), sizeof(uint64_t));
-		if (sp->sadb_address_len != len ||
-		    sp->sadb_address_prefixlen > 128)
-			return -EINVAL;
-		break;
-#endif
-	default:
-		/* It is user using kernel to keep track of security
-		 * associations for another protocol, such as
-		 * OSPF/RSVP/RIPV2/MIP.  It is user's job to verify
-		 * lengths.
-		 *
-		 * XXX Actually, association/policy database is not yet
-		 * XXX able to cope with arbitrary sockaddr families.
-		 * XXX When it can, remove this -EINVAL.  -DaveM
-		 */
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static inline int pfkey_sec_ctx_len(const struct sadb_x_sec_ctx *sec_ctx)
-{
-	return DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +
-			    sec_ctx->sadb_x_ctx_len,
-			    sizeof(uint64_t));
-}
-
-static inline int verify_sec_ctx_len(const void *p)
-{
-	const struct sadb_x_sec_ctx *sec_ctx = p;
-	int len = sec_ctx->sadb_x_ctx_len;
-
-	if (len > PAGE_SIZE)
-		return -EINVAL;
-
-	len = pfkey_sec_ctx_len(sec_ctx);
-
-	if (sec_ctx->sadb_x_sec_len != len)
-		return -EINVAL;
-
-	return 0;
-}
-
-static inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx,
-								     gfp_t gfp)
-{
-	struct xfrm_user_sec_ctx *uctx = NULL;
-	int ctx_size = sec_ctx->sadb_x_ctx_len;
-
-	uctx = kmalloc((sizeof(*uctx)+ctx_size), gfp);
-
-	if (!uctx)
-		return NULL;
-
-	uctx->len = pfkey_sec_ctx_len(sec_ctx);
-	uctx->exttype = sec_ctx->sadb_x_sec_exttype;
-	uctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;
-	uctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;
-	uctx->ctx_len = sec_ctx->sadb_x_ctx_len;
-	memcpy(uctx + 1, sec_ctx + 1,
-	       uctx->ctx_len);
-
-	return uctx;
-}
-
-static int present_and_same_family(const struct sadb_address *src,
-				   const struct sadb_address *dst)
-{
-	const struct sockaddr *s_addr, *d_addr;
-
-	if (!src || !dst)
-		return 0;
-
-	s_addr = (const struct sockaddr *)(src + 1);
-	d_addr = (const struct sockaddr *)(dst + 1);
-	if (s_addr->sa_family != d_addr->sa_family)
-		return 0;
-	if (s_addr->sa_family != AF_INET
-#if IS_ENABLED(CONFIG_IPV6)
-	    && s_addr->sa_family != AF_INET6
-#endif
-		)
-		return 0;
-
-	return 1;
-}
-
-static int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)
-{
-	const char *p = (char *) hdr;
-	int len = skb->len;
-
-	len -= sizeof(*hdr);
-	p += sizeof(*hdr);
-	while (len > 0) {
-		const struct sadb_ext *ehdr = (const struct sadb_ext *) p;
-		uint16_t ext_type;
-		int ext_len;
-
-		ext_len  = ehdr->sadb_ext_len;
-		ext_len *= sizeof(uint64_t);
-		ext_type = ehdr->sadb_ext_type;
-		if (ext_len < sizeof(uint64_t) ||
-		    ext_len > len ||
-		    ext_type == SADB_EXT_RESERVED)
-			return -EINVAL;
-
-		if (ext_type <= SADB_EXT_MAX) {
-			int min = (int) sadb_ext_min_len[ext_type];
-			if (ext_len < min)
-				return -EINVAL;
-			if (ext_hdrs[ext_type-1] != NULL)
-				return -EINVAL;
-			if (ext_type == SADB_EXT_ADDRESS_SRC ||
-			    ext_type == SADB_EXT_ADDRESS_DST ||
-			    ext_type == SADB_EXT_ADDRESS_PROXY ||
-			    ext_type == SADB_X_EXT_NAT_T_OA) {
-				if (verify_address_len(p))
-					return -EINVAL;
-			}
-			if (ext_type == SADB_X_EXT_SEC_CTX) {
-				if (verify_sec_ctx_len(p))
-					return -EINVAL;
-			}
-			ext_hdrs[ext_type-1] = (void *) p;
-		}
-		p   += ext_len;
-		len -= ext_len;
-	}
-
-	return 0;
-}
-
-static uint16_t
-pfkey_satype2proto(uint8_t satype)
-{
-	switch (satype) {
-	case SADB_SATYPE_UNSPEC:
-		return IPSEC_PROTO_ANY;
-	case SADB_SATYPE_AH:
-		return IPPROTO_AH;
-	case SADB_SATYPE_ESP:
-		return IPPROTO_ESP;
-	case SADB_X_SATYPE_IPCOMP:
-		return IPPROTO_COMP;
-	default:
-		return 0;
-	}
-	/* NOTREACHED */
-}
-
-static uint8_t
-pfkey_proto2satype(uint16_t proto)
-{
-	switch (proto) {
-	case IPPROTO_AH:
-		return SADB_SATYPE_AH;
-	case IPPROTO_ESP:
-		return SADB_SATYPE_ESP;
-	case IPPROTO_COMP:
-		return SADB_X_SATYPE_IPCOMP;
-	default:
-		return 0;
-	}
-	/* NOTREACHED */
-}
-
-/* BTW, this scheme means that there is no way with PFKEY2 sockets to
- * say specifically 'just raw sockets' as we encode them as 255.
- */
-
-static uint8_t pfkey_proto_to_xfrm(uint8_t proto)
-{
-	return proto == IPSEC_PROTO_ANY ? 0 : proto;
-}
-
-static uint8_t pfkey_proto_from_xfrm(uint8_t proto)
-{
-	return proto ? proto : IPSEC_PROTO_ANY;
-}
-
-static inline int pfkey_sockaddr_len(sa_family_t family)
-{
-	switch (family) {
-	case AF_INET:
-		return sizeof(struct sockaddr_in);
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-		return sizeof(struct sockaddr_in6);
-#endif
-	}
-	return 0;
-}
-
-static
-int pfkey_sockaddr_extract(const struct sockaddr *sa, xfrm_address_t *xaddr)
-{
-	switch (sa->sa_family) {
-	case AF_INET:
-		xaddr->a4 =
-			((struct sockaddr_in *)sa)->sin_addr.s_addr;
-		return AF_INET;
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-		memcpy(xaddr->a6,
-		       &((struct sockaddr_in6 *)sa)->sin6_addr,
-		       sizeof(struct in6_addr));
-		return AF_INET6;
-#endif
-	}
-	return 0;
-}
-
-static
-int pfkey_sadb_addr2xfrm_addr(const struct sadb_address *addr, xfrm_address_t *xaddr)
-{
-	return pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),
-				      xaddr);
-}
-
-static struct  xfrm_state *pfkey_xfrm_state_lookup(struct net *net, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	const struct sadb_sa *sa;
-	const struct sadb_address *addr;
-	uint16_t proto;
-	unsigned short family;
-	xfrm_address_t *xaddr;
-
-	sa = ext_hdrs[SADB_EXT_SA - 1];
-	if (sa == NULL)
-		return NULL;
-
-	proto = pfkey_satype2proto(hdr->sadb_msg_satype);
-	if (proto == 0)
-		return NULL;
-
-	/* sadb_address_len should be checked by caller */
-	addr = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];
-	if (addr == NULL)
-		return NULL;
-
-	family = ((const struct sockaddr *)(addr + 1))->sa_family;
-	switch (family) {
-	case AF_INET:
-		xaddr = (xfrm_address_t *)&((const struct sockaddr_in *)(addr + 1))->sin_addr;
-		break;
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-		xaddr = (xfrm_address_t *)&((const struct sockaddr_in6 *)(addr + 1))->sin6_addr;
-		break;
-#endif
-	default:
-		xaddr = NULL;
-	}
-
-	if (!xaddr)
-		return NULL;
-
-	return xfrm_state_lookup(net, DUMMY_MARK, xaddr, sa->sadb_sa_spi, proto, family);
-}
-
-#define PFKEY_ALIGN8(a) (1 + (((a) - 1) | (8 - 1)))
-
-static int
-pfkey_sockaddr_size(sa_family_t family)
-{
-	return PFKEY_ALIGN8(pfkey_sockaddr_len(family));
-}
-
-static inline int pfkey_mode_from_xfrm(int mode)
-{
-	switch(mode) {
-	case XFRM_MODE_TRANSPORT:
-		return IPSEC_MODE_TRANSPORT;
-	case XFRM_MODE_TUNNEL:
-		return IPSEC_MODE_TUNNEL;
-	case XFRM_MODE_BEET:
-		return IPSEC_MODE_BEET;
-	default:
-		return -1;
-	}
-}
-
-static inline int pfkey_mode_to_xfrm(int mode)
-{
-	switch(mode) {
-	case IPSEC_MODE_ANY:	/*XXX*/
-	case IPSEC_MODE_TRANSPORT:
-		return XFRM_MODE_TRANSPORT;
-	case IPSEC_MODE_TUNNEL:
-		return XFRM_MODE_TUNNEL;
-	case IPSEC_MODE_BEET:
-		return XFRM_MODE_BEET;
-	default:
-		return -1;
-	}
-}
-
-static unsigned int pfkey_sockaddr_fill(const xfrm_address_t *xaddr, __be16 port,
-					struct sockaddr *sa,
-					unsigned short family)
-{
-	switch (family) {
-	case AF_INET:
-	    {
-		struct sockaddr_in *sin = (struct sockaddr_in *)sa;
-		sin->sin_family = AF_INET;
-		sin->sin_port = port;
-		sin->sin_addr.s_addr = xaddr->a4;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
-		return 32;
-	    }
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-	    {
-		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;
-		sin6->sin6_family = AF_INET6;
-		sin6->sin6_port = port;
-		sin6->sin6_flowinfo = 0;
-		sin6->sin6_addr = *(struct in6_addr *)xaddr->a6;
-		sin6->sin6_scope_id = 0;
-		return 128;
-	    }
-#endif
-	}
-	return 0;
-}
-
-static struct sk_buff *__pfkey_xfrm_state2msg(const struct xfrm_state *x,
-					      int add_keys, int hsc)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-	struct sadb_sa *sa;
-	struct sadb_lifetime *lifetime;
-	struct sadb_address *addr;
-	struct sadb_key *key;
-	struct sadb_x_sa2 *sa2;
-	struct sadb_x_sec_ctx *sec_ctx;
-	struct xfrm_sec_ctx *xfrm_ctx;
-	int ctx_size = 0;
-	int size;
-	int auth_key_size = 0;
-	int encrypt_key_size = 0;
-	int sockaddr_size;
-	struct xfrm_encap_tmpl *natt = NULL;
-	int mode;
-
-	/* address family check */
-	sockaddr_size = pfkey_sockaddr_size(x->props.family);
-	if (!sockaddr_size)
-		return ERR_PTR(-EINVAL);
-
-	/* base, SA, (lifetime (HSC),) address(SD), (address(P),)
-	   key(AE), (identity(SD),) (sensitivity)> */
-	size = sizeof(struct sadb_msg) +sizeof(struct sadb_sa) +
-		sizeof(struct sadb_lifetime) +
-		((hsc & 1) ? sizeof(struct sadb_lifetime) : 0) +
-		((hsc & 2) ? sizeof(struct sadb_lifetime) : 0) +
-			sizeof(struct sadb_address)*2 +
-				sockaddr_size*2 +
-					sizeof(struct sadb_x_sa2);
-
-	if ((xfrm_ctx = x->security)) {
-		ctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);
-		size += sizeof(struct sadb_x_sec_ctx) + ctx_size;
-	}
-
-	/* identity & sensitivity */
-	if (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr, x->props.family))
-		size += sizeof(struct sadb_address) + sockaddr_size;
-
-	if (add_keys) {
-		if (x->aalg && x->aalg->alg_key_len) {
-			auth_key_size =
-				PFKEY_ALIGN8((x->aalg->alg_key_len + 7) / 8);
-			size += sizeof(struct sadb_key) + auth_key_size;
-		}
-		if (x->ealg && x->ealg->alg_key_len) {
-			encrypt_key_size =
-				PFKEY_ALIGN8((x->ealg->alg_key_len+7) / 8);
-			size += sizeof(struct sadb_key) + encrypt_key_size;
-		}
-	}
-	if (x->encap)
-		natt = x->encap;
-
-	if (natt && natt->encap_type) {
-		size += sizeof(struct sadb_x_nat_t_type);
-		size += sizeof(struct sadb_x_nat_t_port);
-		size += sizeof(struct sadb_x_nat_t_port);
-	}
-
-	skb =  alloc_skb(size + 16, GFP_ATOMIC);
-	if (skb == NULL)
-		return ERR_PTR(-ENOBUFS);
-
-	/* call should fill header later */
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	memset(hdr, 0, size);	/* XXX do we need this ? */
-	hdr->sadb_msg_len = size / sizeof(uint64_t);
-
-	/* sa */
-	sa = (struct sadb_sa *)  skb_put(skb, sizeof(struct sadb_sa));
-	sa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);
-	sa->sadb_sa_exttype = SADB_EXT_SA;
-	sa->sadb_sa_spi = x->id.spi;
-	sa->sadb_sa_replay = x->props.replay_window;
-	switch (x->km.state) {
-	case XFRM_STATE_VALID:
-		sa->sadb_sa_state = x->km.dying ?
-			SADB_SASTATE_DYING : SADB_SASTATE_MATURE;
-		break;
-	case XFRM_STATE_ACQ:
-		sa->sadb_sa_state = SADB_SASTATE_LARVAL;
-		break;
-	default:
-		sa->sadb_sa_state = SADB_SASTATE_DEAD;
-		break;
-	}
-	sa->sadb_sa_auth = 0;
-	if (x->aalg) {
-		struct xfrm_algo_desc *a = xfrm_aalg_get_byname(x->aalg->alg_name, 0);
-		sa->sadb_sa_auth = (a && a->pfkey_supported) ?
-					a->desc.sadb_alg_id : 0;
-	}
-	sa->sadb_sa_encrypt = 0;
-	BUG_ON(x->ealg && x->calg);
-	if (x->ealg) {
-		struct xfrm_algo_desc *a = xfrm_ealg_get_byname(x->ealg->alg_name, 0);
-		sa->sadb_sa_encrypt = (a && a->pfkey_supported) ?
-					a->desc.sadb_alg_id : 0;
-	}
-	/* KAME compatible: sadb_sa_encrypt is overloaded with calg id */
-	if (x->calg) {
-		struct xfrm_algo_desc *a = xfrm_calg_get_byname(x->calg->alg_name, 0);
-		sa->sadb_sa_encrypt = (a && a->pfkey_supported) ?
-					a->desc.sadb_alg_id : 0;
-	}
-
-	sa->sadb_sa_flags = 0;
-	if (x->props.flags & XFRM_STATE_NOECN)
-		sa->sadb_sa_flags |= SADB_SAFLAGS_NOECN;
-	if (x->props.flags & XFRM_STATE_DECAP_DSCP)
-		sa->sadb_sa_flags |= SADB_SAFLAGS_DECAP_DSCP;
-	if (x->props.flags & XFRM_STATE_NOPMTUDISC)
-		sa->sadb_sa_flags |= SADB_SAFLAGS_NOPMTUDISC;
-
-	/* hard time */
-	if (hsc & 2) {
-		lifetime = (struct sadb_lifetime *)  skb_put(skb,
-							     sizeof(struct sadb_lifetime));
-		lifetime->sadb_lifetime_len =
-			sizeof(struct sadb_lifetime)/sizeof(uint64_t);
-		lifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
-		lifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.hard_packet_limit);
-		lifetime->sadb_lifetime_bytes = _X2KEY(x->lft.hard_byte_limit);
-		lifetime->sadb_lifetime_addtime = x->lft.hard_add_expires_seconds;
-		lifetime->sadb_lifetime_usetime = x->lft.hard_use_expires_seconds;
-	}
-	/* soft time */
-	if (hsc & 1) {
-		lifetime = (struct sadb_lifetime *)  skb_put(skb,
-							     sizeof(struct sadb_lifetime));
-		lifetime->sadb_lifetime_len =
-			sizeof(struct sadb_lifetime)/sizeof(uint64_t);
-		lifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
-		lifetime->sadb_lifetime_allocations =  _X2KEY(x->lft.soft_packet_limit);
-		lifetime->sadb_lifetime_bytes = _X2KEY(x->lft.soft_byte_limit);
-		lifetime->sadb_lifetime_addtime = x->lft.soft_add_expires_seconds;
-		lifetime->sadb_lifetime_usetime = x->lft.soft_use_expires_seconds;
-	}
-	/* current time */
-	lifetime = (struct sadb_lifetime *)  skb_put(skb,
-						     sizeof(struct sadb_lifetime));
-	lifetime->sadb_lifetime_len =
-		sizeof(struct sadb_lifetime)/sizeof(uint64_t);
-	lifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
-	lifetime->sadb_lifetime_allocations = x->curlft.packets;
-	lifetime->sadb_lifetime_bytes = x->curlft.bytes;
-	lifetime->sadb_lifetime_addtime = x->curlft.add_time;
-	lifetime->sadb_lifetime_usetime = x->curlft.use_time;
-	/* src address */
-	addr = (struct sadb_address*) skb_put(skb,
-					      sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
-	/* "if the ports are non-zero, then the sadb_address_proto field,
-	   normally zero, MUST be filled in with the transport
-	   protocol's number." - RFC2367 */
-	addr->sadb_address_proto = 0;
-	addr->sadb_address_reserved = 0;
-
-	addr->sadb_address_prefixlen =
-		pfkey_sockaddr_fill(&x->props.saddr, 0,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	if (!addr->sadb_address_prefixlen)
-		BUG();
-
-	/* dst address */
-	addr = (struct sadb_address*) skb_put(skb,
-					      sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
-	addr->sadb_address_proto = 0;
-	addr->sadb_address_reserved = 0;
-
-	addr->sadb_address_prefixlen =
-		pfkey_sockaddr_fill(&x->id.daddr, 0,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	if (!addr->sadb_address_prefixlen)
-		BUG();
-
-	if (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr,
-			     x->props.family)) {
-		addr = (struct sadb_address*) skb_put(skb,
-			sizeof(struct sadb_address)+sockaddr_size);
-		addr->sadb_address_len =
-			(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-		addr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;
-		addr->sadb_address_proto =
-			pfkey_proto_from_xfrm(x->sel.proto);
-		addr->sadb_address_prefixlen = x->sel.prefixlen_s;
-		addr->sadb_address_reserved = 0;
-
-		pfkey_sockaddr_fill(&x->sel.saddr, x->sel.sport,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	}
-
-	/* auth key */
-	if (add_keys && auth_key_size) {
-		key = (struct sadb_key *) skb_put(skb,
-						  sizeof(struct sadb_key)+auth_key_size);
-		key->sadb_key_len = (sizeof(struct sadb_key) + auth_key_size) /
-			sizeof(uint64_t);
-		key->sadb_key_exttype = SADB_EXT_KEY_AUTH;
-		key->sadb_key_bits = x->aalg->alg_key_len;
-		key->sadb_key_reserved = 0;
-		memcpy(key + 1, x->aalg->alg_key, (x->aalg->alg_key_len+7)/8);
-	}
-	/* encrypt key */
-	if (add_keys && encrypt_key_size) {
-		key = (struct sadb_key *) skb_put(skb,
-						  sizeof(struct sadb_key)+encrypt_key_size);
-		key->sadb_key_len = (sizeof(struct sadb_key) +
-				     encrypt_key_size) / sizeof(uint64_t);
-		key->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
-		key->sadb_key_bits = x->ealg->alg_key_len;
-		key->sadb_key_reserved = 0;
-		memcpy(key + 1, x->ealg->alg_key,
-		       (x->ealg->alg_key_len+7)/8);
-	}
-
-	/* sa */
-	sa2 = (struct sadb_x_sa2 *)  skb_put(skb, sizeof(struct sadb_x_sa2));
-	sa2->sadb_x_sa2_len = sizeof(struct sadb_x_sa2)/sizeof(uint64_t);
-	sa2->sadb_x_sa2_exttype = SADB_X_EXT_SA2;
-	if ((mode = pfkey_mode_from_xfrm(x->props.mode)) < 0) {
-		kfree_skb(skb);
-		return ERR_PTR(-EINVAL);
-	}
-	sa2->sadb_x_sa2_mode = mode;
-	sa2->sadb_x_sa2_reserved1 = 0;
-	sa2->sadb_x_sa2_reserved2 = 0;
-	sa2->sadb_x_sa2_sequence = 0;
-	sa2->sadb_x_sa2_reqid = x->props.reqid;
-
-	if (natt && natt->encap_type) {
-		struct sadb_x_nat_t_type *n_type;
-		struct sadb_x_nat_t_port *n_port;
-
-		/* type */
-		n_type = (struct sadb_x_nat_t_type*) skb_put(skb, sizeof(*n_type));
-		n_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);
-		n_type->sadb_x_nat_t_type_exttype = SADB_X_EXT_NAT_T_TYPE;
-		n_type->sadb_x_nat_t_type_type = natt->encap_type;
-		n_type->sadb_x_nat_t_type_reserved[0] = 0;
-		n_type->sadb_x_nat_t_type_reserved[1] = 0;
-		n_type->sadb_x_nat_t_type_reserved[2] = 0;
-
-		/* source port */
-		n_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));
-		n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
-		n_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;
-		n_port->sadb_x_nat_t_port_port = natt->encap_sport;
-		n_port->sadb_x_nat_t_port_reserved = 0;
-
-		/* dest port */
-		n_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));
-		n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
-		n_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;
-		n_port->sadb_x_nat_t_port_port = natt->encap_dport;
-		n_port->sadb_x_nat_t_port_reserved = 0;
-	}
-
-	/* security context */
-	if (xfrm_ctx) {
-		sec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,
-				sizeof(struct sadb_x_sec_ctx) + ctx_size);
-		sec_ctx->sadb_x_sec_len =
-		  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);
-		sec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;
-		sec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;
-		sec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;
-		sec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;
-		memcpy(sec_ctx + 1, xfrm_ctx->ctx_str,
-		       xfrm_ctx->ctx_len);
-	}
-
-	return skb;
-}
-
-
-static inline struct sk_buff *pfkey_xfrm_state2msg(const struct xfrm_state *x)
-{
-	struct sk_buff *skb;
-
-	skb = __pfkey_xfrm_state2msg(x, 1, 3);
-
-	return skb;
-}
-
-static inline struct sk_buff *pfkey_xfrm_state2msg_expire(const struct xfrm_state *x,
-							  int hsc)
-{
-	return __pfkey_xfrm_state2msg(x, 0, hsc);
-}
-
-static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,
-						const struct sadb_msg *hdr,
-						void * const *ext_hdrs)
-{
-	struct xfrm_state *x;
-	const struct sadb_lifetime *lifetime;
-	const struct sadb_sa *sa;
-	const struct sadb_key *key;
-	const struct sadb_x_sec_ctx *sec_ctx;
-	uint16_t proto;
-	int err;
-
-
-	sa = ext_hdrs[SADB_EXT_SA - 1];
-	if (!sa ||
-	    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))
-		return ERR_PTR(-EINVAL);
-	if (hdr->sadb_msg_satype == SADB_SATYPE_ESP &&
-	    !ext_hdrs[SADB_EXT_KEY_ENCRYPT-1])
-		return ERR_PTR(-EINVAL);
-	if (hdr->sadb_msg_satype == SADB_SATYPE_AH &&
-	    !ext_hdrs[SADB_EXT_KEY_AUTH-1])
-		return ERR_PTR(-EINVAL);
-	if (!!ext_hdrs[SADB_EXT_LIFETIME_HARD-1] !=
-	    !!ext_hdrs[SADB_EXT_LIFETIME_SOFT-1])
-		return ERR_PTR(-EINVAL);
-
-	proto = pfkey_satype2proto(hdr->sadb_msg_satype);
-	if (proto == 0)
-		return ERR_PTR(-EINVAL);
-
-	/* default error is no buffer space */
-	err = -ENOBUFS;
-
-	/* RFC2367:
-
-   Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_ADD message.
-   SADB_SASTATE_LARVAL SAs are created by SADB_GETSPI and it is not
-   sensible to add a new SA in the DYING or SADB_SASTATE_DEAD state.
-   Therefore, the sadb_sa_state field of all submitted SAs MUST be
-   SADB_SASTATE_MATURE and the kernel MUST return an error if this is
-   not true.
-
-	   However, KAME setkey always uses SADB_SASTATE_LARVAL.
-	   Hence, we have to _ignore_ sadb_sa_state, which is also reasonable.
-	 */
-	if (sa->sadb_sa_auth > SADB_AALG_MAX ||
-	    (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP &&
-	     sa->sadb_sa_encrypt > SADB_X_CALG_MAX) ||
-	    sa->sadb_sa_encrypt > SADB_EALG_MAX)
-		return ERR_PTR(-EINVAL);
-	key = ext_hdrs[SADB_EXT_KEY_AUTH - 1];
-	if (key != NULL &&
-	    sa->sadb_sa_auth != SADB_X_AALG_NULL &&
-	    ((key->sadb_key_bits+7) / 8 == 0 ||
-	     (key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))
-		return ERR_PTR(-EINVAL);
-	key = ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];
-	if (key != NULL &&
-	    sa->sadb_sa_encrypt != SADB_EALG_NULL &&
-	    ((key->sadb_key_bits+7) / 8 == 0 ||
-	     (key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))
-		return ERR_PTR(-EINVAL);
-
-	x = xfrm_state_alloc(net);
-	if (x == NULL)
-		return ERR_PTR(-ENOBUFS);
-
-	x->id.proto = proto;
-	x->id.spi = sa->sadb_sa_spi;
-	x->props.replay_window = min_t(unsigned int, sa->sadb_sa_replay,
-					(sizeof(x->replay.bitmap) * 8));
-	if (sa->sadb_sa_flags & SADB_SAFLAGS_NOECN)
-		x->props.flags |= XFRM_STATE_NOECN;
-	if (sa->sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP)
-		x->props.flags |= XFRM_STATE_DECAP_DSCP;
-	if (sa->sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC)
-		x->props.flags |= XFRM_STATE_NOPMTUDISC;
-
-	lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD - 1];
-	if (lifetime != NULL) {
-		x->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);
-		x->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);
-		x->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;
-		x->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;
-	}
-	lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT - 1];
-	if (lifetime != NULL) {
-		x->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);
-		x->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);
-		x->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;
-		x->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;
-	}
-
-	sec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];
-	if (sec_ctx != NULL) {
-		struct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);
-
-		if (!uctx)
-			goto out;
-
-		err = security_xfrm_state_alloc(x, uctx);
-		kfree(uctx);
-
-		if (err)
-			goto out;
-	}
-
-	key = ext_hdrs[SADB_EXT_KEY_AUTH - 1];
-	if (sa->sadb_sa_auth) {
-		int keysize = 0;
-		struct xfrm_algo_desc *a = xfrm_aalg_get_byid(sa->sadb_sa_auth);
-		if (!a || !a->pfkey_supported) {
-			err = -ENOSYS;
-			goto out;
-		}
-		if (key)
-			keysize = (key->sadb_key_bits + 7) / 8;
-		x->aalg = kmalloc(sizeof(*x->aalg) + keysize, GFP_KERNEL);
-		if (!x->aalg)
-			goto out;
-		strcpy(x->aalg->alg_name, a->name);
-		x->aalg->alg_key_len = 0;
-		if (key) {
-			x->aalg->alg_key_len = key->sadb_key_bits;
-			memcpy(x->aalg->alg_key, key+1, keysize);
-		}
-		x->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits;
-		x->props.aalgo = sa->sadb_sa_auth;
-		/* x->algo.flags = sa->sadb_sa_flags; */
-	}
-	if (sa->sadb_sa_encrypt) {
-		if (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {
-			struct xfrm_algo_desc *a = xfrm_calg_get_byid(sa->sadb_sa_encrypt);
-			if (!a || !a->pfkey_supported) {
-				err = -ENOSYS;
-				goto out;
-			}
-			x->calg = kmalloc(sizeof(*x->calg), GFP_KERNEL);
-			if (!x->calg)
-				goto out;
-			strcpy(x->calg->alg_name, a->name);
-			x->props.calgo = sa->sadb_sa_encrypt;
-		} else {
-			int keysize = 0;
-			struct xfrm_algo_desc *a = xfrm_ealg_get_byid(sa->sadb_sa_encrypt);
-			if (!a || !a->pfkey_supported) {
-				err = -ENOSYS;
-				goto out;
-			}
-			key = (struct sadb_key*) ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];
-			if (key)
-				keysize = (key->sadb_key_bits + 7) / 8;
-			x->ealg = kmalloc(sizeof(*x->ealg) + keysize, GFP_KERNEL);
-			if (!x->ealg)
-				goto out;
-			strcpy(x->ealg->alg_name, a->name);
-			x->ealg->alg_key_len = 0;
-			if (key) {
-				x->ealg->alg_key_len = key->sadb_key_bits;
-				memcpy(x->ealg->alg_key, key+1, keysize);
-			}
-			x->props.ealgo = sa->sadb_sa_encrypt;
-		}
-	}
-	/* x->algo.flags = sa->sadb_sa_flags; */
-
-	x->props.family = pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-						    &x->props.saddr);
-	pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_DST-1],
-				  &x->id.daddr);
-
-	if (ext_hdrs[SADB_X_EXT_SA2-1]) {
-		const struct sadb_x_sa2 *sa2 = ext_hdrs[SADB_X_EXT_SA2-1];
-		int mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);
-		if (mode < 0) {
-			err = -EINVAL;
-			goto out;
-		}
-		x->props.mode = mode;
-		x->props.reqid = sa2->sadb_x_sa2_reqid;
-	}
-
-	if (ext_hdrs[SADB_EXT_ADDRESS_PROXY-1]) {
-		const struct sadb_address *addr = ext_hdrs[SADB_EXT_ADDRESS_PROXY-1];
-
-		/* Nobody uses this, but we try. */
-		x->sel.family = pfkey_sadb_addr2xfrm_addr(addr, &x->sel.saddr);
-		x->sel.prefixlen_s = addr->sadb_address_prefixlen;
-	}
-
-	if (!x->sel.family)
-		x->sel.family = x->props.family;
-
-	if (ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1]) {
-		const struct sadb_x_nat_t_type* n_type;
-		struct xfrm_encap_tmpl *natt;
-
-		x->encap = kmalloc(sizeof(*x->encap), GFP_KERNEL);
-		if (!x->encap)
-			goto out;
-
-		natt = x->encap;
-		n_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];
-		natt->encap_type = n_type->sadb_x_nat_t_type_type;
-
-		if (ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1]) {
-			const struct sadb_x_nat_t_port *n_port =
-				ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1];
-			natt->encap_sport = n_port->sadb_x_nat_t_port_port;
-		}
-		if (ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]) {
-			const struct sadb_x_nat_t_port *n_port =
-				ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1];
-			natt->encap_dport = n_port->sadb_x_nat_t_port_port;
-		}
-		memset(&natt->encap_oa, 0, sizeof(natt->encap_oa));
-	}
-
-	err = xfrm_init_state(x);
-	if (err)
-		goto out;
-
-	x->km.seq = hdr->sadb_msg_seq;
-	return x;
-
-out:
-	x->km.state = XFRM_STATE_DEAD;
-	xfrm_state_put(x);
-	return ERR_PTR(err);
-}
-
-static int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	return -EOPNOTSUPP;
-}
-
-static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	struct sk_buff *resp_skb;
-	struct sadb_x_sa2 *sa2;
-	struct sadb_address *saddr, *daddr;
-	struct sadb_msg *out_hdr;
-	struct sadb_spirange *range;
-	struct xfrm_state *x = NULL;
-	int mode;
-	int err;
-	u32 min_spi, max_spi;
-	u32 reqid;
-	u8 proto;
-	unsigned short family;
-	xfrm_address_t *xsaddr = NULL, *xdaddr = NULL;
-
-	if (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))
-		return -EINVAL;
-
-	proto = pfkey_satype2proto(hdr->sadb_msg_satype);
-	if (proto == 0)
-		return -EINVAL;
-
-	if ((sa2 = ext_hdrs[SADB_X_EXT_SA2-1]) != NULL) {
-		mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);
-		if (mode < 0)
-			return -EINVAL;
-		reqid = sa2->sadb_x_sa2_reqid;
-	} else {
-		mode = 0;
-		reqid = 0;
-	}
-
-	saddr = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];
-	daddr = ext_hdrs[SADB_EXT_ADDRESS_DST-1];
-
-	family = ((struct sockaddr *)(saddr + 1))->sa_family;
-	switch (family) {
-	case AF_INET:
-		xdaddr = (xfrm_address_t *)&((struct sockaddr_in *)(daddr + 1))->sin_addr.s_addr;
-		xsaddr = (xfrm_address_t *)&((struct sockaddr_in *)(saddr + 1))->sin_addr.s_addr;
-		break;
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-		xdaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(daddr + 1))->sin6_addr;
-		xsaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(saddr + 1))->sin6_addr;
-		break;
-#endif
-	}
-
-	if (hdr->sadb_msg_seq) {
-		x = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);
-		if (x && !xfrm_addr_equal(&x->id.daddr, xdaddr, family)) {
-			xfrm_state_put(x);
-			x = NULL;
-		}
-	}
-
-	if (!x)
-		x = xfrm_find_acq(net, &dummy_mark, mode, reqid, proto, xdaddr, xsaddr, 1, family);
-
-	if (x == NULL)
-		return -ENOENT;
-
-	min_spi = 0x100;
-	max_spi = 0x0fffffff;
-
-	range = ext_hdrs[SADB_EXT_SPIRANGE-1];
-	if (range) {
-		min_spi = range->sadb_spirange_min;
-		max_spi = range->sadb_spirange_max;
-	}
-
-	err = verify_spi_info(x->id.proto, min_spi, max_spi);
-	if (err) {
-		xfrm_state_put(x);
-		return err;
-	}
-
-	err = xfrm_alloc_spi(x, min_spi, max_spi);
-	resp_skb = err ? ERR_PTR(err) : pfkey_xfrm_state2msg(x);
-
-	if (IS_ERR(resp_skb)) {
-		xfrm_state_put(x);
-		return  PTR_ERR(resp_skb);
-	}
-
-	out_hdr = (struct sadb_msg *) resp_skb->data;
-	out_hdr->sadb_msg_version = hdr->sadb_msg_version;
-	out_hdr->sadb_msg_type = SADB_GETSPI;
-	out_hdr->sadb_msg_satype = pfkey_proto2satype(proto);
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_reserved = 0;
-	out_hdr->sadb_msg_seq = hdr->sadb_msg_seq;
-	out_hdr->sadb_msg_pid = hdr->sadb_msg_pid;
-
-	xfrm_state_put(x);
-
-	pfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);
-
-	return 0;
-}
-
-static int pfkey_acquire(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	struct xfrm_state *x;
-
-	if (hdr->sadb_msg_len != sizeof(struct sadb_msg)/8)
-		return -EOPNOTSUPP;
-
-	if (hdr->sadb_msg_seq == 0 || hdr->sadb_msg_errno == 0)
-		return 0;
-
-	x = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);
-	if (x == NULL)
-		return 0;
-
-	spin_lock_bh(&x->lock);
-	if (x->km.state == XFRM_STATE_ACQ)
-		x->km.state = XFRM_STATE_ERROR;
-
-	spin_unlock_bh(&x->lock);
-	xfrm_state_put(x);
-	return 0;
-}
-
-static inline int event2poltype(int event)
-{
-	switch (event) {
-	case XFRM_MSG_DELPOLICY:
-		return SADB_X_SPDDELETE;
-	case XFRM_MSG_NEWPOLICY:
-		return SADB_X_SPDADD;
-	case XFRM_MSG_UPDPOLICY:
-		return SADB_X_SPDUPDATE;
-	case XFRM_MSG_POLEXPIRE:
-	//	return SADB_X_SPDEXPIRE;
-	default:
-		pr_err("pfkey: Unknown policy event %d\n", event);
-		break;
-	}
-
-	return 0;
-}
-
-static inline int event2keytype(int event)
-{
-	switch (event) {
-	case XFRM_MSG_DELSA:
-		return SADB_DELETE;
-	case XFRM_MSG_NEWSA:
-		return SADB_ADD;
-	case XFRM_MSG_UPDSA:
-		return SADB_UPDATE;
-	case XFRM_MSG_EXPIRE:
-		return SADB_EXPIRE;
-	default:
-		pr_err("pfkey: Unknown SA event %d\n", event);
-		break;
-	}
-
-	return 0;
-}
-
-/* ADD/UPD/DEL */
-static int key_notify_sa(struct xfrm_state *x, const struct km_event *c)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-
-	skb = pfkey_xfrm_state2msg(x);
-
-	if (IS_ERR(skb))
-		return PTR_ERR(skb);
-
-	hdr = (struct sadb_msg *) skb->data;
-	hdr->sadb_msg_version = PF_KEY_V2;
-	hdr->sadb_msg_type = event2keytype(c->event);
-	hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);
-	hdr->sadb_msg_errno = 0;
-	hdr->sadb_msg_reserved = 0;
-	hdr->sadb_msg_seq = c->seq;
-	hdr->sadb_msg_pid = c->portid;
-
-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));
-
-	return 0;
-}
-
-static int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	struct xfrm_state *x;
-	int err;
-	struct km_event c;
-
-	x = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);
-	if (IS_ERR(x))
-		return PTR_ERR(x);
-
-	xfrm_state_hold(x);
-	if (hdr->sadb_msg_type == SADB_ADD)
-		err = xfrm_state_add(x);
-	else
-		err = xfrm_state_update(x);
-
-	xfrm_audit_state_add(x, err ? 0 : 1, true);
-
-	if (err < 0) {
-		x->km.state = XFRM_STATE_DEAD;
-		__xfrm_state_put(x);
-		goto out;
-	}
-
-	if (hdr->sadb_msg_type == SADB_ADD)
-		c.event = XFRM_MSG_NEWSA;
-	else
-		c.event = XFRM_MSG_UPDSA;
-	c.seq = hdr->sadb_msg_seq;
-	c.portid = hdr->sadb_msg_pid;
-	km_state_notify(x, &c);
-out:
-	xfrm_state_put(x);
-	return err;
-}
-
-static int pfkey_delete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	struct xfrm_state *x;
-	struct km_event c;
-	int err;
-
-	if (!ext_hdrs[SADB_EXT_SA-1] ||
-	    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))
-		return -EINVAL;
-
-	x = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);
-	if (x == NULL)
-		return -ESRCH;
-
-	if ((err = security_xfrm_state_delete(x)))
-		goto out;
-
-	if (xfrm_state_kern(x)) {
-		err = -EPERM;
-		goto out;
-	}
-
-	err = xfrm_state_delete(x);
-
-	if (err < 0)
-		goto out;
-
-	c.seq = hdr->sadb_msg_seq;
-	c.portid = hdr->sadb_msg_pid;
-	c.event = XFRM_MSG_DELSA;
-	km_state_notify(x, &c);
-out:
-	xfrm_audit_state_delete(x, err ? 0 : 1, true);
-	xfrm_state_put(x);
-
-	return err;
-}
-
-static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	__u8 proto;
-	struct sk_buff *out_skb;
-	struct sadb_msg *out_hdr;
-	struct xfrm_state *x;
-
-	if (!ext_hdrs[SADB_EXT_SA-1] ||
-	    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))
-		return -EINVAL;
-
-	x = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);
-	if (x == NULL)
-		return -ESRCH;
-
-	out_skb = pfkey_xfrm_state2msg(x);
-	proto = x->id.proto;
-	xfrm_state_put(x);
-	if (IS_ERR(out_skb))
-		return  PTR_ERR(out_skb);
-
-	out_hdr = (struct sadb_msg *) out_skb->data;
-	out_hdr->sadb_msg_version = hdr->sadb_msg_version;
-	out_hdr->sadb_msg_type = SADB_GET;
-	out_hdr->sadb_msg_satype = pfkey_proto2satype(proto);
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_reserved = 0;
-	out_hdr->sadb_msg_seq = hdr->sadb_msg_seq;
-	out_hdr->sadb_msg_pid = hdr->sadb_msg_pid;
-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));
-
-	return 0;
-}
-
-static struct sk_buff *compose_sadb_supported(const struct sadb_msg *orig,
-					      gfp_t allocation)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-	int len, auth_len, enc_len, i;
-
-	auth_len = xfrm_count_pfkey_auth_supported();
-	if (auth_len) {
-		auth_len *= sizeof(struct sadb_alg);
-		auth_len += sizeof(struct sadb_supported);
-	}
-
-	enc_len = xfrm_count_pfkey_enc_supported();
-	if (enc_len) {
-		enc_len *= sizeof(struct sadb_alg);
-		enc_len += sizeof(struct sadb_supported);
-	}
-
-	len = enc_len + auth_len + sizeof(struct sadb_msg);
-
-	skb = alloc_skb(len + 16, allocation);
-	if (!skb)
-		goto out_put_algs;
-
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(*hdr));
-	pfkey_hdr_dup(hdr, orig);
-	hdr->sadb_msg_errno = 0;
-	hdr->sadb_msg_len = len / sizeof(uint64_t);
-
-	if (auth_len) {
-		struct sadb_supported *sp;
-		struct sadb_alg *ap;
-
-		sp = (struct sadb_supported *) skb_put(skb, auth_len);
-		ap = (struct sadb_alg *) (sp + 1);
-
-		sp->sadb_supported_len = auth_len / sizeof(uint64_t);
-		sp->sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;
-
-		for (i = 0; ; i++) {
-			struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);
-			if (!aalg)
-				break;
-			if (!aalg->pfkey_supported)
-				continue;
-			if (aalg->available)
-				*ap++ = aalg->desc;
-		}
-	}
-
-	if (enc_len) {
-		struct sadb_supported *sp;
-		struct sadb_alg *ap;
-
-		sp = (struct sadb_supported *) skb_put(skb, enc_len);
-		ap = (struct sadb_alg *) (sp + 1);
-
-		sp->sadb_supported_len = enc_len / sizeof(uint64_t);
-		sp->sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;
-
-		for (i = 0; ; i++) {
-			struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);
-			if (!ealg)
-				break;
-			if (!ealg->pfkey_supported)
-				continue;
-			if (ealg->available)
-				*ap++ = ealg->desc;
-		}
-	}
-
-out_put_algs:
-	return skb;
-}
-
-static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct pfkey_sock *pfk = pfkey_sk(sk);
-	struct sk_buff *supp_skb;
-
-	if (hdr->sadb_msg_satype > SADB_SATYPE_MAX)
-		return -EINVAL;
-
-	if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {
-		if (pfk->registered&(1<<hdr->sadb_msg_satype))
-			return -EEXIST;
-		pfk->registered |= (1<<hdr->sadb_msg_satype);
-	}
-
-	xfrm_probe_algs();
-
-	supp_skb = compose_sadb_supported(hdr, GFP_KERNEL);
-	if (!supp_skb) {
-		if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)
-			pfk->registered &= ~(1<<hdr->sadb_msg_satype);
-
-		return -ENOBUFS;
-	}
-
-	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk));
-
-	return 0;
-}
-
-static int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-
-	skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
-	if (!skb)
-		return -ENOBUFS;
-
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	memcpy(hdr, ihdr, sizeof(struct sadb_msg));
-	hdr->sadb_msg_errno = (uint8_t) 0;
-	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
-
-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));
-}
-
-static int key_notify_sa_flush(const struct km_event *c)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-
-	skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
-	if (!skb)
-		return -ENOBUFS;
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	hdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);
-	hdr->sadb_msg_type = SADB_FLUSH;
-	hdr->sadb_msg_seq = c->seq;
-	hdr->sadb_msg_pid = c->portid;
-	hdr->sadb_msg_version = PF_KEY_V2;
-	hdr->sadb_msg_errno = (uint8_t) 0;
-	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
-	hdr->sadb_msg_reserved = 0;
-
-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
-
-	return 0;
-}
-
-static int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	unsigned int proto;
-	struct km_event c;
-	int err, err2;
-
-	proto = pfkey_satype2proto(hdr->sadb_msg_satype);
-	if (proto == 0)
-		return -EINVAL;
-
-	err = xfrm_state_flush(net, proto, true);
-	err2 = unicast_flush_resp(sk, hdr);
-	if (err || err2) {
-		if (err == -ESRCH) /* empty table - go quietly */
-			err = 0;
-		return err ? err : err2;
-	}
-
-	c.data.proto = proto;
-	c.seq = hdr->sadb_msg_seq;
-	c.portid = hdr->sadb_msg_pid;
-	c.event = XFRM_MSG_FLUSHSA;
-	c.net = net;
-	km_state_notify(NULL, &c);
-
-	return 0;
-}
-
-static int dump_sa(struct xfrm_state *x, int count, void *ptr)
-{
-	struct pfkey_sock *pfk = ptr;
-	struct sk_buff *out_skb;
-	struct sadb_msg *out_hdr;
-
-	if (!pfkey_can_dump(&pfk->sk))
-		return -ENOBUFS;
-
-	out_skb = pfkey_xfrm_state2msg(x);
-	if (IS_ERR(out_skb))
-		return PTR_ERR(out_skb);
-
-	out_hdr = (struct sadb_msg *) out_skb->data;
-	out_hdr->sadb_msg_version = pfk->dump.msg_version;
-	out_hdr->sadb_msg_type = SADB_DUMP;
-	out_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_reserved = 0;
-	out_hdr->sadb_msg_seq = count + 1;
-	out_hdr->sadb_msg_pid = pfk->dump.msg_portid;
-
-	if (pfk->dump.skb)
-		pfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,
-				&pfk->sk, sock_net(&pfk->sk));
-	pfk->dump.skb = out_skb;
-
-	return 0;
-}
-
-static int pfkey_dump_sa(struct pfkey_sock *pfk)
-{
-	struct net *net = sock_net(&pfk->sk);
-	return xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);
-}
-
-static void pfkey_dump_sa_done(struct pfkey_sock *pfk)
-{
-	struct net *net = sock_net(&pfk->sk);
-
-	xfrm_state_walk_done(&pfk->dump.u.state, net);
-}
-
-static int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	u8 proto;
-	struct xfrm_address_filter *filter = NULL;
-	struct pfkey_sock *pfk = pfkey_sk(sk);
-
-	if (pfk->dump.dump != NULL)
-		return -EBUSY;
-
-	proto = pfkey_satype2proto(hdr->sadb_msg_satype);
-	if (proto == 0)
-		return -EINVAL;
-
-	if (ext_hdrs[SADB_X_EXT_FILTER - 1]) {
-		struct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];
-
-		filter = kmalloc(sizeof(*filter), GFP_KERNEL);
-		if (filter == NULL)
-			return -ENOMEM;
-
-		memcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,
-		       sizeof(xfrm_address_t));
-		memcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,
-		       sizeof(xfrm_address_t));
-		filter->family = xfilter->sadb_x_filter_family;
-		filter->splen = xfilter->sadb_x_filter_splen;
-		filter->dplen = xfilter->sadb_x_filter_dplen;
-	}
-
-	pfk->dump.msg_version = hdr->sadb_msg_version;
-	pfk->dump.msg_portid = hdr->sadb_msg_pid;
-	pfk->dump.dump = pfkey_dump_sa;
-	pfk->dump.done = pfkey_dump_sa_done;
-	xfrm_state_walk_init(&pfk->dump.u.state, proto, filter);
-
-	return pfkey_do_dump(pfk);
-}
-
-static int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct pfkey_sock *pfk = pfkey_sk(sk);
-	int satype = hdr->sadb_msg_satype;
-	bool reset_errno = false;
-
-	if (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {
-		reset_errno = true;
-		if (satype != 0 && satype != 1)
-			return -EINVAL;
-		pfk->promisc = satype;
-	}
-	if (reset_errno && skb_cloned(skb))
-		skb = skb_copy(skb, GFP_KERNEL);
-	else
-		skb = skb_clone(skb, GFP_KERNEL);
-
-	if (reset_errno && skb) {
-		struct sadb_msg *new_hdr = (struct sadb_msg *) skb->data;
-		new_hdr->sadb_msg_errno = 0;
-	}
-
-	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));
-	return 0;
-}
-
-static int check_reqid(struct xfrm_policy *xp, int dir, int count, void *ptr)
-{
-	int i;
-	u32 reqid = *(u32*)ptr;
-
-	for (i=0; i<xp->xfrm_nr; i++) {
-		if (xp->xfrm_vec[i].reqid == reqid)
-			return -EEXIST;
-	}
-	return 0;
-}
-
-static u32 gen_reqid(struct net *net)
-{
-	struct xfrm_policy_walk walk;
-	u32 start;
-	int rc;
-	static u32 reqid = IPSEC_MANUAL_REQID_MAX;
-
-	start = reqid;
-	do {
-		++reqid;
-		if (reqid == 0)
-			reqid = IPSEC_MANUAL_REQID_MAX+1;
-		xfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_MAIN);
-		rc = xfrm_policy_walk(net, &walk, check_reqid, (void*)&reqid);
-		xfrm_policy_walk_done(&walk, net);
-		if (rc != -EEXIST)
-			return reqid;
-	} while (reqid != start);
-	return 0;
-}
-
-static int
-parse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)
-{
-	struct net *net = xp_net(xp);
-	struct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;
-	int mode;
-
-	if (xp->xfrm_nr >= XFRM_MAX_DEPTH)
-		return -ELOOP;
-
-	if (rq->sadb_x_ipsecrequest_mode == 0)
-		return -EINVAL;
-
-	t->id.proto = rq->sadb_x_ipsecrequest_proto; /* XXX check proto */
-	if ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)
-		return -EINVAL;
-	t->mode = mode;
-	if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)
-		t->optional = 1;
-	else if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {
-		t->reqid = rq->sadb_x_ipsecrequest_reqid;
-		if (t->reqid > IPSEC_MANUAL_REQID_MAX)
-			t->reqid = 0;
-		if (!t->reqid && !(t->reqid = gen_reqid(net)))
-			return -ENOBUFS;
-	}
-
-	/* addresses present only in tunnel mode */
-	if (t->mode == XFRM_MODE_TUNNEL) {
-		u8 *sa = (u8 *) (rq + 1);
-		int family, socklen;
-
-		family = pfkey_sockaddr_extract((struct sockaddr *)sa,
-						&t->saddr);
-		if (!family)
-			return -EINVAL;
-
-		socklen = pfkey_sockaddr_len(family);
-		if (pfkey_sockaddr_extract((struct sockaddr *)(sa + socklen),
-					   &t->id.daddr) != family)
-			return -EINVAL;
-		t->encap_family = family;
-	} else
-		t->encap_family = xp->family;
-
-	/* No way to set this via kame pfkey */
-	t->allalgs = 1;
-	xp->xfrm_nr++;
-	return 0;
-}
-
-static int
-parse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol)
-{
-	int err;
-	int len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy);
-	struct sadb_x_ipsecrequest *rq = (void*)(pol+1);
-
-	if (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy))
-		return -EINVAL;
-
-	while (len >= sizeof(struct sadb_x_ipsecrequest)) {
-		if ((err = parse_ipsecrequest(xp, rq)) < 0)
-			return err;
-		len -= rq->sadb_x_ipsecrequest_len;
-		rq = (void*)((u8*)rq + rq->sadb_x_ipsecrequest_len);
-	}
-	return 0;
-}
-
-static inline int pfkey_xfrm_policy2sec_ctx_size(const struct xfrm_policy *xp)
-{
-  struct xfrm_sec_ctx *xfrm_ctx = xp->security;
-
-	if (xfrm_ctx) {
-		int len = sizeof(struct sadb_x_sec_ctx);
-		len += xfrm_ctx->ctx_len;
-		return PFKEY_ALIGN8(len);
-	}
-	return 0;
-}
-
-static int pfkey_xfrm_policy2msg_size(const struct xfrm_policy *xp)
-{
-	const struct xfrm_tmpl *t;
-	int sockaddr_size = pfkey_sockaddr_size(xp->family);
-	int socklen = 0;
-	int i;
-
-	for (i=0; i<xp->xfrm_nr; i++) {
-		t = xp->xfrm_vec + i;
-		socklen += pfkey_sockaddr_len(t->encap_family);
-	}
-
-	return sizeof(struct sadb_msg) +
-		(sizeof(struct sadb_lifetime) * 3) +
-		(sizeof(struct sadb_address) * 2) +
-		(sockaddr_size * 2) +
-		sizeof(struct sadb_x_policy) +
-		(xp->xfrm_nr * sizeof(struct sadb_x_ipsecrequest)) +
-		(socklen * 2) +
-		pfkey_xfrm_policy2sec_ctx_size(xp);
-}
-
-static struct sk_buff * pfkey_xfrm_policy2msg_prep(const struct xfrm_policy *xp)
-{
-	struct sk_buff *skb;
-	int size;
-
-	size = pfkey_xfrm_policy2msg_size(xp);
-
-	skb =  alloc_skb(size + 16, GFP_ATOMIC);
-	if (skb == NULL)
-		return ERR_PTR(-ENOBUFS);
-
-	return skb;
-}
-
-static int pfkey_xfrm_policy2msg(struct sk_buff *skb, const struct xfrm_policy *xp, int dir)
-{
-	struct sadb_msg *hdr;
-	struct sadb_address *addr;
-	struct sadb_lifetime *lifetime;
-	struct sadb_x_policy *pol;
-	struct sadb_x_sec_ctx *sec_ctx;
-	struct xfrm_sec_ctx *xfrm_ctx;
-	int i;
-	int size;
-	int sockaddr_size = pfkey_sockaddr_size(xp->family);
-	int socklen = pfkey_sockaddr_len(xp->family);
-
-	size = pfkey_xfrm_policy2msg_size(xp);
-
-	/* call should fill header later */
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	memset(hdr, 0, size);	/* XXX do we need this ? */
-
-	/* src address */
-	addr = (struct sadb_address*) skb_put(skb,
-					      sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
-	addr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);
-	addr->sadb_address_prefixlen = xp->selector.prefixlen_s;
-	addr->sadb_address_reserved = 0;
-	if (!pfkey_sockaddr_fill(&xp->selector.saddr,
-				 xp->selector.sport,
-				 (struct sockaddr *) (addr + 1),
-				 xp->family))
-		BUG();
-
-	/* dst address */
-	addr = (struct sadb_address*) skb_put(skb,
-					      sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
-	addr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);
-	addr->sadb_address_prefixlen = xp->selector.prefixlen_d;
-	addr->sadb_address_reserved = 0;
-
-	pfkey_sockaddr_fill(&xp->selector.daddr, xp->selector.dport,
-			    (struct sockaddr *) (addr + 1),
-			    xp->family);
-
-	/* hard time */
-	lifetime = (struct sadb_lifetime *)  skb_put(skb,
-						     sizeof(struct sadb_lifetime));
-	lifetime->sadb_lifetime_len =
-		sizeof(struct sadb_lifetime)/sizeof(uint64_t);
-	lifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
-	lifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.hard_packet_limit);
-	lifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.hard_byte_limit);
-	lifetime->sadb_lifetime_addtime = xp->lft.hard_add_expires_seconds;
-	lifetime->sadb_lifetime_usetime = xp->lft.hard_use_expires_seconds;
-	/* soft time */
-	lifetime = (struct sadb_lifetime *)  skb_put(skb,
-						     sizeof(struct sadb_lifetime));
-	lifetime->sadb_lifetime_len =
-		sizeof(struct sadb_lifetime)/sizeof(uint64_t);
-	lifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
-	lifetime->sadb_lifetime_allocations =  _X2KEY(xp->lft.soft_packet_limit);
-	lifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.soft_byte_limit);
-	lifetime->sadb_lifetime_addtime = xp->lft.soft_add_expires_seconds;
-	lifetime->sadb_lifetime_usetime = xp->lft.soft_use_expires_seconds;
-	/* current time */
-	lifetime = (struct sadb_lifetime *)  skb_put(skb,
-						     sizeof(struct sadb_lifetime));
-	lifetime->sadb_lifetime_len =
-		sizeof(struct sadb_lifetime)/sizeof(uint64_t);
-	lifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
-	lifetime->sadb_lifetime_allocations = xp->curlft.packets;
-	lifetime->sadb_lifetime_bytes = xp->curlft.bytes;
-	lifetime->sadb_lifetime_addtime = xp->curlft.add_time;
-	lifetime->sadb_lifetime_usetime = xp->curlft.use_time;
-
-	pol = (struct sadb_x_policy *)  skb_put(skb, sizeof(struct sadb_x_policy));
-	pol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);
-	pol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
-	pol->sadb_x_policy_type = IPSEC_POLICY_DISCARD;
-	if (xp->action == XFRM_POLICY_ALLOW) {
-		if (xp->xfrm_nr)
-			pol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;
-		else
-			pol->sadb_x_policy_type = IPSEC_POLICY_NONE;
-	}
-	pol->sadb_x_policy_dir = dir+1;
-	pol->sadb_x_policy_reserved = 0;
-	pol->sadb_x_policy_id = xp->index;
-	pol->sadb_x_policy_priority = xp->priority;
-
-	for (i=0; i<xp->xfrm_nr; i++) {
-		const struct xfrm_tmpl *t = xp->xfrm_vec + i;
-		struct sadb_x_ipsecrequest *rq;
-		int req_size;
-		int mode;
-
-		req_size = sizeof(struct sadb_x_ipsecrequest);
-		if (t->mode == XFRM_MODE_TUNNEL) {
-			socklen = pfkey_sockaddr_len(t->encap_family);
-			req_size += socklen * 2;
-		} else {
-			size -= 2*socklen;
-		}
-		rq = (void*)skb_put(skb, req_size);
-		pol->sadb_x_policy_len += req_size/8;
-		memset(rq, 0, sizeof(*rq));
-		rq->sadb_x_ipsecrequest_len = req_size;
-		rq->sadb_x_ipsecrequest_proto = t->id.proto;
-		if ((mode = pfkey_mode_from_xfrm(t->mode)) < 0)
-			return -EINVAL;
-		rq->sadb_x_ipsecrequest_mode = mode;
-		rq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;
-		if (t->reqid)
-			rq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE;
-		if (t->optional)
-			rq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE;
-		rq->sadb_x_ipsecrequest_reqid = t->reqid;
-
-		if (t->mode == XFRM_MODE_TUNNEL) {
-			u8 *sa = (void *)(rq + 1);
-			pfkey_sockaddr_fill(&t->saddr, 0,
-					    (struct sockaddr *)sa,
-					    t->encap_family);
-			pfkey_sockaddr_fill(&t->id.daddr, 0,
-					    (struct sockaddr *) (sa + socklen),
-					    t->encap_family);
-		}
-	}
-
-	/* security context */
-	if ((xfrm_ctx = xp->security)) {
-		int ctx_size = pfkey_xfrm_policy2sec_ctx_size(xp);
-
-		sec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb, ctx_size);
-		sec_ctx->sadb_x_sec_len = ctx_size / sizeof(uint64_t);
-		sec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;
-		sec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;
-		sec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;
-		sec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;
-		memcpy(sec_ctx + 1, xfrm_ctx->ctx_str,
-		       xfrm_ctx->ctx_len);
-	}
-
-	hdr->sadb_msg_len = size / sizeof(uint64_t);
-	hdr->sadb_msg_reserved = atomic_read(&xp->refcnt);
-
-	return 0;
-}
-
-static int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)
-{
-	struct sk_buff *out_skb;
-	struct sadb_msg *out_hdr;
-	int err;
-
-	out_skb = pfkey_xfrm_policy2msg_prep(xp);
-	if (IS_ERR(out_skb))
-		return PTR_ERR(out_skb);
-
-	err = pfkey_xfrm_policy2msg(out_skb, xp, dir);
-	if (err < 0)
-		return err;
-
-	out_hdr = (struct sadb_msg *) out_skb->data;
-	out_hdr->sadb_msg_version = PF_KEY_V2;
-
-	if (c->data.byid && c->event == XFRM_MSG_DELPOLICY)
-		out_hdr->sadb_msg_type = SADB_X_SPDDELETE2;
-	else
-		out_hdr->sadb_msg_type = event2poltype(c->event);
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_seq = c->seq;
-	out_hdr->sadb_msg_pid = c->portid;
-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));
-	return 0;
-
-}
-
-static int pfkey_spdadd(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	int err = 0;
-	struct sadb_lifetime *lifetime;
-	struct sadb_address *sa;
-	struct sadb_x_policy *pol;
-	struct xfrm_policy *xp;
-	struct km_event c;
-	struct sadb_x_sec_ctx *sec_ctx;
-
-	if (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||
-	    !ext_hdrs[SADB_X_EXT_POLICY-1])
-		return -EINVAL;
-
-	pol = ext_hdrs[SADB_X_EXT_POLICY-1];
-	if (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)
-		return -EINVAL;
-	if (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)
-		return -EINVAL;
-
-	xp = xfrm_policy_alloc(net, GFP_KERNEL);
-	if (xp == NULL)
-		return -ENOBUFS;
-
-	xp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?
-		      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);
-	xp->priority = pol->sadb_x_policy_priority;
-
-	sa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];
-	xp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);
-	xp->selector.family = xp->family;
-	xp->selector.prefixlen_s = sa->sadb_address_prefixlen;
-	xp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
-	xp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;
-	if (xp->selector.sport)
-		xp->selector.sport_mask = htons(0xffff);
-
-	sa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];
-	pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);
-	xp->selector.prefixlen_d = sa->sadb_address_prefixlen;
-
-	/* Amusing, we set this twice.  KAME apps appear to set same value
-	 * in both addresses.
-	 */
-	xp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
-
-	xp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;
-	if (xp->selector.dport)
-		xp->selector.dport_mask = htons(0xffff);
-
-	sec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];
-	if (sec_ctx != NULL) {
-		struct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);
-
-		if (!uctx) {
-			err = -ENOBUFS;
-			goto out;
-		}
-
-		err = security_xfrm_policy_alloc(&xp->security, uctx, GFP_KERNEL);
-		kfree(uctx);
-
-		if (err)
-			goto out;
-	}
-
-	xp->lft.soft_byte_limit = XFRM_INF;
-	xp->lft.hard_byte_limit = XFRM_INF;
-	xp->lft.soft_packet_limit = XFRM_INF;
-	xp->lft.hard_packet_limit = XFRM_INF;
-	if ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {
-		xp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);
-		xp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);
-		xp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;
-		xp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;
-	}
-	if ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {
-		xp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);
-		xp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);
-		xp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;
-		xp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;
-	}
-	xp->xfrm_nr = 0;
-	if (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&
-	    (err = parse_ipsecrequests(xp, pol)) < 0)
-		goto out;
-
-	err = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,
-				 hdr->sadb_msg_type != SADB_X_SPDUPDATE);
-
-	xfrm_audit_policy_add(xp, err ? 0 : 1, true);
-
-	if (err)
-		goto out;
-
-	if (hdr->sadb_msg_type == SADB_X_SPDUPDATE)
-		c.event = XFRM_MSG_UPDPOLICY;
-	else
-		c.event = XFRM_MSG_NEWPOLICY;
-
-	c.seq = hdr->sadb_msg_seq;
-	c.portid = hdr->sadb_msg_pid;
-
-	km_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);
-	xfrm_pol_put(xp);
-	return 0;
-
-out:
-	xp->walk.dead = 1;
-	xfrm_policy_destroy(xp);
-	return err;
-}
-
-static int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	int err;
-	struct sadb_address *sa;
-	struct sadb_x_policy *pol;
-	struct xfrm_policy *xp;
-	struct xfrm_selector sel;
-	struct km_event c;
-	struct sadb_x_sec_ctx *sec_ctx;
-	struct xfrm_sec_ctx *pol_ctx = NULL;
-
-	if (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST-1]) ||
-	    !ext_hdrs[SADB_X_EXT_POLICY-1])
-		return -EINVAL;
-
-	pol = ext_hdrs[SADB_X_EXT_POLICY-1];
-	if (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)
-		return -EINVAL;
-
-	memset(&sel, 0, sizeof(sel));
-
-	sa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];
-	sel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);
-	sel.prefixlen_s = sa->sadb_address_prefixlen;
-	sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
-	sel.sport = ((struct sockaddr_in *)(sa+1))->sin_port;
-	if (sel.sport)
-		sel.sport_mask = htons(0xffff);
-
-	sa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];
-	pfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);
-	sel.prefixlen_d = sa->sadb_address_prefixlen;
-	sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
-	sel.dport = ((struct sockaddr_in *)(sa+1))->sin_port;
-	if (sel.dport)
-		sel.dport_mask = htons(0xffff);
-
-	sec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];
-	if (sec_ctx != NULL) {
-		struct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);
-
-		if (!uctx)
-			return -ENOMEM;
-
-		err = security_xfrm_policy_alloc(&pol_ctx, uctx, GFP_KERNEL);
-		kfree(uctx);
-		if (err)
-			return err;
-	}
-
-	xp = xfrm_policy_bysel_ctx(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,
-				   pol->sadb_x_policy_dir - 1, &sel, pol_ctx,
-				   1, &err);
-	security_xfrm_policy_free(pol_ctx);
-	if (xp == NULL)
-		return -ENOENT;
-
-	xfrm_audit_policy_delete(xp, err ? 0 : 1, true);
-
-	if (err)
-		goto out;
-
-	c.seq = hdr->sadb_msg_seq;
-	c.portid = hdr->sadb_msg_pid;
-	c.data.byid = 0;
-	c.event = XFRM_MSG_DELPOLICY;
-	km_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);
-
-out:
-	xfrm_pol_put(xp);
-	if (err == 0)
-		xfrm_garbage_collect(net);
-	return err;
-}
-
-static int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struct sadb_msg *hdr, int dir)
-{
-	int err;
-	struct sk_buff *out_skb;
-	struct sadb_msg *out_hdr;
-	err = 0;
-
-	out_skb = pfkey_xfrm_policy2msg_prep(xp);
-	if (IS_ERR(out_skb)) {
-		err =  PTR_ERR(out_skb);
-		goto out;
-	}
-	err = pfkey_xfrm_policy2msg(out_skb, xp, dir);
-	if (err < 0)
-		goto out;
-
-	out_hdr = (struct sadb_msg *) out_skb->data;
-	out_hdr->sadb_msg_version = hdr->sadb_msg_version;
-	out_hdr->sadb_msg_type = hdr->sadb_msg_type;
-	out_hdr->sadb_msg_satype = 0;
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_seq = hdr->sadb_msg_seq;
-	out_hdr->sadb_msg_pid = hdr->sadb_msg_pid;
-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));
-	err = 0;
-
-out:
-	return err;
-}
-
-#ifdef CONFIG_NET_KEY_MIGRATE
-static int pfkey_sockaddr_pair_size(sa_family_t family)
-{
-	return PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);
-}
-
-static int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,
-			       xfrm_address_t *saddr, xfrm_address_t *daddr,
-			       u16 *family)
-{
-	int af, socklen;
-
-	if (ext_len < pfkey_sockaddr_pair_size(sa->sa_family))
-		return -EINVAL;
-
-	af = pfkey_sockaddr_extract(sa, saddr);
-	if (!af)
-		return -EINVAL;
-
-	socklen = pfkey_sockaddr_len(af);
-	if (pfkey_sockaddr_extract((struct sockaddr *) (((u8 *)sa) + socklen),
-				   daddr) != af)
-		return -EINVAL;
-
-	*family = af;
-	return 0;
-}
-
-static int ipsecrequests_to_migrate(struct sadb_x_ipsecrequest *rq1, int len,
-				    struct xfrm_migrate *m)
-{
-	int err;
-	struct sadb_x_ipsecrequest *rq2;
-	int mode;
-
-	if (len <= sizeof(struct sadb_x_ipsecrequest) ||
-	    len < rq1->sadb_x_ipsecrequest_len)
-		return -EINVAL;
-
-	/* old endoints */
-	err = parse_sockaddr_pair((struct sockaddr *)(rq1 + 1),
-				  rq1->sadb_x_ipsecrequest_len,
-				  &m->old_saddr, &m->old_daddr,
-				  &m->old_family);
-	if (err)
-		return err;
-
-	rq2 = (struct sadb_x_ipsecrequest *)((u8 *)rq1 + rq1->sadb_x_ipsecrequest_len);
-	len -= rq1->sadb_x_ipsecrequest_len;
-
-	if (len <= sizeof(struct sadb_x_ipsecrequest) ||
-	    len < rq2->sadb_x_ipsecrequest_len)
-		return -EINVAL;
-
-	/* new endpoints */
-	err = parse_sockaddr_pair((struct sockaddr *)(rq2 + 1),
-				  rq2->sadb_x_ipsecrequest_len,
-				  &m->new_saddr, &m->new_daddr,
-				  &m->new_family);
-	if (err)
-		return err;
-
-	if (rq1->sadb_x_ipsecrequest_proto != rq2->sadb_x_ipsecrequest_proto ||
-	    rq1->sadb_x_ipsecrequest_mode != rq2->sadb_x_ipsecrequest_mode ||
-	    rq1->sadb_x_ipsecrequest_reqid != rq2->sadb_x_ipsecrequest_reqid)
-		return -EINVAL;
-
-	m->proto = rq1->sadb_x_ipsecrequest_proto;
-	if ((mode = pfkey_mode_to_xfrm(rq1->sadb_x_ipsecrequest_mode)) < 0)
-		return -EINVAL;
-	m->mode = mode;
-	m->reqid = rq1->sadb_x_ipsecrequest_reqid;
-
-	return ((int)(rq1->sadb_x_ipsecrequest_len +
-		      rq2->sadb_x_ipsecrequest_len));
-}
-
-static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,
-			 const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	int i, len, ret, err = -EINVAL;
-	u8 dir;
-	struct sadb_address *sa;
-	struct sadb_x_kmaddress *kma;
-	struct sadb_x_policy *pol;
-	struct sadb_x_ipsecrequest *rq;
-	struct xfrm_selector sel;
-	struct xfrm_migrate m[XFRM_MAX_DEPTH];
-	struct xfrm_kmaddress k;
-	struct net *net = sock_net(sk);
-
-	if (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],
-				     ext_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||
-	    !ext_hdrs[SADB_X_EXT_POLICY - 1]) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	kma = ext_hdrs[SADB_X_EXT_KMADDRESS - 1];
-	pol = ext_hdrs[SADB_X_EXT_POLICY - 1];
-
-	if (pol->sadb_x_policy_dir >= IPSEC_DIR_MAX) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	if (kma) {
-		/* convert sadb_x_kmaddress to xfrm_kmaddress */
-		k.reserved = kma->sadb_x_kmaddress_reserved;
-		ret = parse_sockaddr_pair((struct sockaddr *)(kma + 1),
-					  8*(kma->sadb_x_kmaddress_len) - sizeof(*kma),
-					  &k.local, &k.remote, &k.family);
-		if (ret < 0) {
-			err = ret;
-			goto out;
-		}
-	}
-
-	dir = pol->sadb_x_policy_dir - 1;
-	memset(&sel, 0, sizeof(sel));
-
-	/* set source address info of selector */
-	sa = ext_hdrs[SADB_EXT_ADDRESS_SRC - 1];
-	sel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);
-	sel.prefixlen_s = sa->sadb_address_prefixlen;
-	sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
-	sel.sport = ((struct sockaddr_in *)(sa + 1))->sin_port;
-	if (sel.sport)
-		sel.sport_mask = htons(0xffff);
-
-	/* set destination address info of selector */
-	sa = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];
-	pfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);
-	sel.prefixlen_d = sa->sadb_address_prefixlen;
-	sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
-	sel.dport = ((struct sockaddr_in *)(sa + 1))->sin_port;
-	if (sel.dport)
-		sel.dport_mask = htons(0xffff);
-
-	rq = (struct sadb_x_ipsecrequest *)(pol + 1);
-
-	/* extract ipsecrequests */
-	i = 0;
-	len = pol->sadb_x_policy_len * 8 - sizeof(struct sadb_x_policy);
-
-	while (len > 0 && i < XFRM_MAX_DEPTH) {
-		ret = ipsecrequests_to_migrate(rq, len, &m[i]);
-		if (ret < 0) {
-			err = ret;
-			goto out;
-		} else {
-			rq = (struct sadb_x_ipsecrequest *)((u8 *)rq + ret);
-			len -= ret;
-			i++;
-		}
-	}
-
-	if (!i || len > 0) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	return xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,
-			    kma ? &k : NULL, net);
-
- out:
-	return err;
-}
-#else
-static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,
-			 const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	return -ENOPROTOOPT;
-}
-#endif
-
-
-static int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	unsigned int dir;
-	int err = 0, delete;
-	struct sadb_x_policy *pol;
-	struct xfrm_policy *xp;
-	struct km_event c;
-
-	if ((pol = ext_hdrs[SADB_X_EXT_POLICY-1]) == NULL)
-		return -EINVAL;
-
-	dir = xfrm_policy_id2dir(pol->sadb_x_policy_id);
-	if (dir >= XFRM_POLICY_MAX)
-		return -EINVAL;
-
-	delete = (hdr->sadb_msg_type == SADB_X_SPDDELETE2);
-	xp = xfrm_policy_byid(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,
-			      dir, pol->sadb_x_policy_id, delete, &err);
-	if (xp == NULL)
-		return -ENOENT;
-
-	if (delete) {
-		xfrm_audit_policy_delete(xp, err ? 0 : 1, true);
-
-		if (err)
-			goto out;
-		c.seq = hdr->sadb_msg_seq;
-		c.portid = hdr->sadb_msg_pid;
-		c.data.byid = 1;
-		c.event = XFRM_MSG_DELPOLICY;
-		km_policy_notify(xp, dir, &c);
-	} else {
-		err = key_pol_get_resp(sk, xp, hdr, dir);
-	}
-
-out:
-	xfrm_pol_put(xp);
-	if (delete && err == 0)
-		xfrm_garbage_collect(net);
-	return err;
-}
-
-static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)
-{
-	struct pfkey_sock *pfk = ptr;
-	struct sk_buff *out_skb;
-	struct sadb_msg *out_hdr;
-	int err;
-
-	if (!pfkey_can_dump(&pfk->sk))
-		return -ENOBUFS;
-
-	out_skb = pfkey_xfrm_policy2msg_prep(xp);
-	if (IS_ERR(out_skb))
-		return PTR_ERR(out_skb);
-
-	err = pfkey_xfrm_policy2msg(out_skb, xp, dir);
-	if (err < 0)
-		return err;
-
-	out_hdr = (struct sadb_msg *) out_skb->data;
-	out_hdr->sadb_msg_version = pfk->dump.msg_version;
-	out_hdr->sadb_msg_type = SADB_X_SPDDUMP;
-	out_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_seq = count + 1;
-	out_hdr->sadb_msg_pid = pfk->dump.msg_portid;
-
-	if (pfk->dump.skb)
-		pfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,
-				&pfk->sk, sock_net(&pfk->sk));
-	pfk->dump.skb = out_skb;
-
-	return 0;
-}
-
-static int pfkey_dump_sp(struct pfkey_sock *pfk)
-{
-	struct net *net = sock_net(&pfk->sk);
-	return xfrm_policy_walk(net, &pfk->dump.u.policy, dump_sp, (void *) pfk);
-}
-
-static void pfkey_dump_sp_done(struct pfkey_sock *pfk)
-{
-	struct net *net = sock_net((struct sock *)pfk);
-
-	xfrm_policy_walk_done(&pfk->dump.u.policy, net);
-}
-
-static int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct pfkey_sock *pfk = pfkey_sk(sk);
-
-	if (pfk->dump.dump != NULL)
-		return -EBUSY;
-
-	pfk->dump.msg_version = hdr->sadb_msg_version;
-	pfk->dump.msg_portid = hdr->sadb_msg_pid;
-	pfk->dump.dump = pfkey_dump_sp;
-	pfk->dump.done = pfkey_dump_sp_done;
-	xfrm_policy_walk_init(&pfk->dump.u.policy, XFRM_POLICY_TYPE_MAIN);
-
-	return pfkey_do_dump(pfk);
-}
-
-static int key_notify_policy_flush(const struct km_event *c)
-{
-	struct sk_buff *skb_out;
-	struct sadb_msg *hdr;
-
-	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
-	if (!skb_out)
-		return -ENOBUFS;
-	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
-	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
-	hdr->sadb_msg_seq = c->seq;
-	hdr->sadb_msg_pid = c->portid;
-	hdr->sadb_msg_version = PF_KEY_V2;
-	hdr->sadb_msg_errno = (uint8_t) 0;
-	hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;
-	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
-	hdr->sadb_msg_reserved = 0;
-	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
-	return 0;
-
-}
-
-static int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
-{
-	struct net *net = sock_net(sk);
-	struct km_event c;
-	int err, err2;
-
-	err = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, true);
-	err2 = unicast_flush_resp(sk, hdr);
-	if (err || err2) {
-		if (err == -ESRCH) /* empty table - old silent behavior */
-			return 0;
-		return err;
-	}
-
-	c.data.type = XFRM_POLICY_TYPE_MAIN;
-	c.event = XFRM_MSG_FLUSHPOLICY;
-	c.portid = hdr->sadb_msg_pid;
-	c.seq = hdr->sadb_msg_seq;
-	c.net = net;
-	km_policy_notify(NULL, 0, &c);
-
-	return 0;
-}
-
-typedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb,
-			     const struct sadb_msg *hdr, void * const *ext_hdrs);
-static const pfkey_handler pfkey_funcs[SADB_MAX + 1] = {
-	[SADB_RESERVED]		= pfkey_reserved,
-	[SADB_GETSPI]		= pfkey_getspi,
-	[SADB_UPDATE]		= pfkey_add,
-	[SADB_ADD]		= pfkey_add,
-	[SADB_DELETE]		= pfkey_delete,
-	[SADB_GET]		= pfkey_get,
-	[SADB_ACQUIRE]		= pfkey_acquire,
-	[SADB_REGISTER]		= pfkey_register,
-	[SADB_EXPIRE]		= NULL,
-	[SADB_FLUSH]		= pfkey_flush,
-	[SADB_DUMP]		= pfkey_dump,
-	[SADB_X_PROMISC]	= pfkey_promisc,
-	[SADB_X_PCHANGE]	= NULL,
-	[SADB_X_SPDUPDATE]	= pfkey_spdadd,
-	[SADB_X_SPDADD]		= pfkey_spdadd,
-	[SADB_X_SPDDELETE]	= pfkey_spddelete,
-	[SADB_X_SPDGET]		= pfkey_spdget,
-	[SADB_X_SPDACQUIRE]	= NULL,
-	[SADB_X_SPDDUMP]	= pfkey_spddump,
-	[SADB_X_SPDFLUSH]	= pfkey_spdflush,
-	[SADB_X_SPDSETIDX]	= pfkey_spdadd,
-	[SADB_X_SPDDELETE2]	= pfkey_spdget,
-	[SADB_X_MIGRATE]	= pfkey_migrate,
-};
-
-static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)
-{
-	void *ext_hdrs[SADB_EXT_MAX];
-	int err;
-
-	pfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,
-			BROADCAST_PROMISC_ONLY, NULL, sock_net(sk));
-
-	memset(ext_hdrs, 0, sizeof(ext_hdrs));
-	err = parse_exthdrs(skb, hdr, ext_hdrs);
-	if (!err) {
-		err = -EOPNOTSUPP;
-		if (pfkey_funcs[hdr->sadb_msg_type])
-			err = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);
-	}
-	return err;
-}
-
-static struct sadb_msg *pfkey_get_base_msg(struct sk_buff *skb, int *errp)
-{
-	struct sadb_msg *hdr = NULL;
-
-	if (skb->len < sizeof(*hdr)) {
-		*errp = -EMSGSIZE;
-	} else {
-		hdr = (struct sadb_msg *) skb->data;
-		if (hdr->sadb_msg_version != PF_KEY_V2 ||
-		    hdr->sadb_msg_reserved != 0 ||
-		    (hdr->sadb_msg_type <= SADB_RESERVED ||
-		     hdr->sadb_msg_type > SADB_MAX)) {
-			hdr = NULL;
-			*errp = -EINVAL;
-		} else if (hdr->sadb_msg_len != (skb->len /
-						 sizeof(uint64_t)) ||
-			   hdr->sadb_msg_len < (sizeof(struct sadb_msg) /
-						sizeof(uint64_t))) {
-			hdr = NULL;
-			*errp = -EMSGSIZE;
-		} else {
-			*errp = 0;
-		}
-	}
-	return hdr;
-}
-
-static inline int aalg_tmpl_set(const struct xfrm_tmpl *t,
-				const struct xfrm_algo_desc *d)
-{
-	unsigned int id = d->desc.sadb_alg_id;
-
-	if (id >= sizeof(t->aalgos) * 8)
-		return 0;
-
-	return (t->aalgos >> id) & 1;
-}
-
-static inline int ealg_tmpl_set(const struct xfrm_tmpl *t,
-				const struct xfrm_algo_desc *d)
-{
-	unsigned int id = d->desc.sadb_alg_id;
-
-	if (id >= sizeof(t->ealgos) * 8)
-		return 0;
-
-	return (t->ealgos >> id) & 1;
-}
-
-static int count_ah_combs(const struct xfrm_tmpl *t)
-{
-	int i, sz = 0;
-
-	for (i = 0; ; i++) {
-		const struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);
-		if (!aalg)
-			break;
-		if (!aalg->pfkey_supported)
-			continue;
-		if (aalg_tmpl_set(t, aalg) && aalg->available)
-			sz += sizeof(struct sadb_comb);
-	}
-	return sz + sizeof(struct sadb_prop);
-}
-
-static int count_esp_combs(const struct xfrm_tmpl *t)
-{
-	int i, k, sz = 0;
-
-	for (i = 0; ; i++) {
-		const struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);
-		if (!ealg)
-			break;
-
-		if (!ealg->pfkey_supported)
-			continue;
-
-		if (!(ealg_tmpl_set(t, ealg) && ealg->available))
-			continue;
-
-		for (k = 1; ; k++) {
-			const struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);
-			if (!aalg)
-				break;
-
-			if (!aalg->pfkey_supported)
-				continue;
-
-			if (aalg_tmpl_set(t, aalg) && aalg->available)
-				sz += sizeof(struct sadb_comb);
-		}
-	}
-	return sz + sizeof(struct sadb_prop);
-}
-
-static void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)
-{
-	struct sadb_prop *p;
-	int i;
-
-	p = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));
-	p->sadb_prop_len = sizeof(struct sadb_prop)/8;
-	p->sadb_prop_exttype = SADB_EXT_PROPOSAL;
-	p->sadb_prop_replay = 32;
-	memset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));
-
-	for (i = 0; ; i++) {
-		const struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);
-		if (!aalg)
-			break;
-
-		if (!aalg->pfkey_supported)
-			continue;
-
-		if (aalg_tmpl_set(t, aalg) && aalg->available) {
-			struct sadb_comb *c;
-			c = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));
-			memset(c, 0, sizeof(*c));
-			p->sadb_prop_len += sizeof(struct sadb_comb)/8;
-			c->sadb_comb_auth = aalg->desc.sadb_alg_id;
-			c->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;
-			c->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;
-			c->sadb_comb_hard_addtime = 24*60*60;
-			c->sadb_comb_soft_addtime = 20*60*60;
-			c->sadb_comb_hard_usetime = 8*60*60;
-			c->sadb_comb_soft_usetime = 7*60*60;
-		}
-	}
-}
-
-static void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)
-{
-	struct sadb_prop *p;
-	int i, k;
-
-	p = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));
-	p->sadb_prop_len = sizeof(struct sadb_prop)/8;
-	p->sadb_prop_exttype = SADB_EXT_PROPOSAL;
-	p->sadb_prop_replay = 32;
-	memset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));
-
-	for (i=0; ; i++) {
-		const struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);
-		if (!ealg)
-			break;
-
-		if (!ealg->pfkey_supported)
-			continue;
-
-		if (!(ealg_tmpl_set(t, ealg) && ealg->available))
-			continue;
-
-		for (k = 1; ; k++) {
-			struct sadb_comb *c;
-			const struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);
-			if (!aalg)
-				break;
-			if (!aalg->pfkey_supported)
-				continue;
-			if (!(aalg_tmpl_set(t, aalg) && aalg->available))
-				continue;
-			c = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));
-			memset(c, 0, sizeof(*c));
-			p->sadb_prop_len += sizeof(struct sadb_comb)/8;
-			c->sadb_comb_auth = aalg->desc.sadb_alg_id;
-			c->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;
-			c->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;
-			c->sadb_comb_encrypt = ealg->desc.sadb_alg_id;
-			c->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;
-			c->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;
-			c->sadb_comb_hard_addtime = 24*60*60;
-			c->sadb_comb_soft_addtime = 20*60*60;
-			c->sadb_comb_hard_usetime = 8*60*60;
-			c->sadb_comb_soft_usetime = 7*60*60;
-		}
-	}
-}
-
-static int key_notify_policy_expire(struct xfrm_policy *xp, const struct km_event *c)
-{
-	return 0;
-}
-
-static int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)
-{
-	struct sk_buff *out_skb;
-	struct sadb_msg *out_hdr;
-	int hard;
-	int hsc;
-
-	hard = c->data.hard;
-	if (hard)
-		hsc = 2;
-	else
-		hsc = 1;
-
-	out_skb = pfkey_xfrm_state2msg_expire(x, hsc);
-	if (IS_ERR(out_skb))
-		return PTR_ERR(out_skb);
-
-	out_hdr = (struct sadb_msg *) out_skb->data;
-	out_hdr->sadb_msg_version = PF_KEY_V2;
-	out_hdr->sadb_msg_type = SADB_EXPIRE;
-	out_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);
-	out_hdr->sadb_msg_errno = 0;
-	out_hdr->sadb_msg_reserved = 0;
-	out_hdr->sadb_msg_seq = 0;
-	out_hdr->sadb_msg_pid = 0;
-
-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));
-	return 0;
-}
-
-static int pfkey_send_notify(struct xfrm_state *x, const struct km_event *c)
-{
-	struct net *net = x ? xs_net(x) : c->net;
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-
-	if (atomic_read(&net_pfkey->socks_nr) == 0)
-		return 0;
-
-	switch (c->event) {
-	case XFRM_MSG_EXPIRE:
-		return key_notify_sa_expire(x, c);
-	case XFRM_MSG_DELSA:
-	case XFRM_MSG_NEWSA:
-	case XFRM_MSG_UPDSA:
-		return key_notify_sa(x, c);
-	case XFRM_MSG_FLUSHSA:
-		return key_notify_sa_flush(c);
-	case XFRM_MSG_NEWAE: /* not yet supported */
-		break;
-	default:
-		pr_err("pfkey: Unknown SA event %d\n", c->event);
-		break;
-	}
-
-	return 0;
-}
-
-static int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
-{
-	if (xp && xp->type != XFRM_POLICY_TYPE_MAIN)
-		return 0;
-
-	switch (c->event) {
-	case XFRM_MSG_POLEXPIRE:
-		return key_notify_policy_expire(xp, c);
-	case XFRM_MSG_DELPOLICY:
-	case XFRM_MSG_NEWPOLICY:
-	case XFRM_MSG_UPDPOLICY:
-		return key_notify_policy(xp, dir, c);
-	case XFRM_MSG_FLUSHPOLICY:
-		if (c->data.type != XFRM_POLICY_TYPE_MAIN)
-			break;
-		return key_notify_policy_flush(c);
-	default:
-		pr_err("pfkey: Unknown policy event %d\n", c->event);
-		break;
-	}
-
-	return 0;
-}
-
-static u32 get_acqseq(void)
-{
-	u32 res;
-	static atomic_t acqseq;
-
-	do {
-		res = atomic_inc_return(&acqseq);
-	} while (!res);
-	return res;
-}
-
-static bool pfkey_is_alive(const struct km_event *c)
-{
-	struct netns_pfkey *net_pfkey = net_generic(c->net, pfkey_net_id);
-	struct sock *sk;
-	bool is_alive = false;
-
-	rcu_read_lock();
-	sk_for_each_rcu(sk, &net_pfkey->table) {
-		if (pfkey_sk(sk)->registered) {
-			is_alive = true;
-			break;
-		}
-	}
-	rcu_read_unlock();
-
-	return is_alive;
-}
-
-static int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *xp)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-	struct sadb_address *addr;
-	struct sadb_x_policy *pol;
-	int sockaddr_size;
-	int size;
-	struct sadb_x_sec_ctx *sec_ctx;
-	struct xfrm_sec_ctx *xfrm_ctx;
-	int ctx_size = 0;
-
-	sockaddr_size = pfkey_sockaddr_size(x->props.family);
-	if (!sockaddr_size)
-		return -EINVAL;
-
-	size = sizeof(struct sadb_msg) +
-		(sizeof(struct sadb_address) * 2) +
-		(sockaddr_size * 2) +
-		sizeof(struct sadb_x_policy);
-
-	if (x->id.proto == IPPROTO_AH)
-		size += count_ah_combs(t);
-	else if (x->id.proto == IPPROTO_ESP)
-		size += count_esp_combs(t);
-
-	if ((xfrm_ctx = x->security)) {
-		ctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);
-		size +=  sizeof(struct sadb_x_sec_ctx) + ctx_size;
-	}
-
-	skb =  alloc_skb(size + 16, GFP_ATOMIC);
-	if (skb == NULL)
-		return -ENOMEM;
-
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	hdr->sadb_msg_version = PF_KEY_V2;
-	hdr->sadb_msg_type = SADB_ACQUIRE;
-	hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);
-	hdr->sadb_msg_len = size / sizeof(uint64_t);
-	hdr->sadb_msg_errno = 0;
-	hdr->sadb_msg_reserved = 0;
-	hdr->sadb_msg_seq = x->km.seq = get_acqseq();
-	hdr->sadb_msg_pid = 0;
-
-	/* src address */
-	addr = (struct sadb_address*) skb_put(skb,
-					      sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
-	addr->sadb_address_proto = 0;
-	addr->sadb_address_reserved = 0;
-	addr->sadb_address_prefixlen =
-		pfkey_sockaddr_fill(&x->props.saddr, 0,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	if (!addr->sadb_address_prefixlen)
-		BUG();
-
-	/* dst address */
-	addr = (struct sadb_address*) skb_put(skb,
-					      sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
-	addr->sadb_address_proto = 0;
-	addr->sadb_address_reserved = 0;
-	addr->sadb_address_prefixlen =
-		pfkey_sockaddr_fill(&x->id.daddr, 0,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	if (!addr->sadb_address_prefixlen)
-		BUG();
-
-	pol = (struct sadb_x_policy *)  skb_put(skb, sizeof(struct sadb_x_policy));
-	pol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);
-	pol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
-	pol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;
-	pol->sadb_x_policy_dir = XFRM_POLICY_OUT + 1;
-	pol->sadb_x_policy_reserved = 0;
-	pol->sadb_x_policy_id = xp->index;
-	pol->sadb_x_policy_priority = xp->priority;
-
-	/* Set sadb_comb's. */
-	if (x->id.proto == IPPROTO_AH)
-		dump_ah_combs(skb, t);
-	else if (x->id.proto == IPPROTO_ESP)
-		dump_esp_combs(skb, t);
-
-	/* security context */
-	if (xfrm_ctx) {
-		sec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,
-				sizeof(struct sadb_x_sec_ctx) + ctx_size);
-		sec_ctx->sadb_x_sec_len =
-		  (sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);
-		sec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;
-		sec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;
-		sec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;
-		sec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;
-		memcpy(sec_ctx + 1, xfrm_ctx->ctx_str,
-		       xfrm_ctx->ctx_len);
-	}
-
-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));
-}
-
-static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,
-						u8 *data, int len, int *dir)
-{
-	struct net *net = sock_net(sk);
-	struct xfrm_policy *xp;
-	struct sadb_x_policy *pol = (struct sadb_x_policy*)data;
-	struct sadb_x_sec_ctx *sec_ctx;
-
-	switch (sk->sk_family) {
-	case AF_INET:
-		if (opt != IP_IPSEC_POLICY) {
-			*dir = -EOPNOTSUPP;
-			return NULL;
-		}
-		break;
-#if IS_ENABLED(CONFIG_IPV6)
-	case AF_INET6:
-		if (opt != IPV6_IPSEC_POLICY) {
-			*dir = -EOPNOTSUPP;
-			return NULL;
-		}
-		break;
-#endif
-	default:
-		*dir = -EINVAL;
-		return NULL;
-	}
-
-	*dir = -EINVAL;
-
-	if (len < sizeof(struct sadb_x_policy) ||
-	    pol->sadb_x_policy_len*8 > len ||
-	    pol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||
-	    (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))
-		return NULL;
-
-	xp = xfrm_policy_alloc(net, GFP_ATOMIC);
-	if (xp == NULL) {
-		*dir = -ENOBUFS;
-		return NULL;
-	}
-
-	xp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?
-		      XFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);
-
-	xp->lft.soft_byte_limit = XFRM_INF;
-	xp->lft.hard_byte_limit = XFRM_INF;
-	xp->lft.soft_packet_limit = XFRM_INF;
-	xp->lft.hard_packet_limit = XFRM_INF;
-	xp->family = sk->sk_family;
-
-	xp->xfrm_nr = 0;
-	if (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&
-	    (*dir = parse_ipsecrequests(xp, pol)) < 0)
-		goto out;
-
-	/* security context too */
-	if (len >= (pol->sadb_x_policy_len*8 +
-	    sizeof(struct sadb_x_sec_ctx))) {
-		char *p = (char *)pol;
-		struct xfrm_user_sec_ctx *uctx;
-
-		p += pol->sadb_x_policy_len*8;
-		sec_ctx = (struct sadb_x_sec_ctx *)p;
-		if (len < pol->sadb_x_policy_len*8 +
-		    sec_ctx->sadb_x_sec_len) {
-			*dir = -EINVAL;
-			goto out;
-		}
-		if ((*dir = verify_sec_ctx_len(p)))
-			goto out;
-		uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_ATOMIC);
-		*dir = security_xfrm_policy_alloc(&xp->security, uctx, GFP_ATOMIC);
-		kfree(uctx);
-
-		if (*dir)
-			goto out;
-	}
-
-	*dir = pol->sadb_x_policy_dir-1;
-	return xp;
-
-out:
-	xp->walk.dead = 1;
-	xfrm_policy_destroy(xp);
-	return NULL;
-}
-
-static int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)
-{
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-	struct sadb_sa *sa;
-	struct sadb_address *addr;
-	struct sadb_x_nat_t_port *n_port;
-	int sockaddr_size;
-	int size;
-	__u8 satype = (x->id.proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0);
-	struct xfrm_encap_tmpl *natt = NULL;
-
-	sockaddr_size = pfkey_sockaddr_size(x->props.family);
-	if (!sockaddr_size)
-		return -EINVAL;
-
-	if (!satype)
-		return -EINVAL;
-
-	if (!x->encap)
-		return -EINVAL;
-
-	natt = x->encap;
-
-	/* Build an SADB_X_NAT_T_NEW_MAPPING message:
-	 *
-	 * HDR | SA | ADDRESS_SRC (old addr) | NAT_T_SPORT (old port) |
-	 * ADDRESS_DST (new addr) | NAT_T_DPORT (new port)
-	 */
-
-	size = sizeof(struct sadb_msg) +
-		sizeof(struct sadb_sa) +
-		(sizeof(struct sadb_address) * 2) +
-		(sockaddr_size * 2) +
-		(sizeof(struct sadb_x_nat_t_port) * 2);
-
-	skb =  alloc_skb(size + 16, GFP_ATOMIC);
-	if (skb == NULL)
-		return -ENOMEM;
-
-	hdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));
-	hdr->sadb_msg_version = PF_KEY_V2;
-	hdr->sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING;
-	hdr->sadb_msg_satype = satype;
-	hdr->sadb_msg_len = size / sizeof(uint64_t);
-	hdr->sadb_msg_errno = 0;
-	hdr->sadb_msg_reserved = 0;
-	hdr->sadb_msg_seq = x->km.seq = get_acqseq();
-	hdr->sadb_msg_pid = 0;
-
-	/* SA */
-	sa = (struct sadb_sa *) skb_put(skb, sizeof(struct sadb_sa));
-	sa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);
-	sa->sadb_sa_exttype = SADB_EXT_SA;
-	sa->sadb_sa_spi = x->id.spi;
-	sa->sadb_sa_replay = 0;
-	sa->sadb_sa_state = 0;
-	sa->sadb_sa_auth = 0;
-	sa->sadb_sa_encrypt = 0;
-	sa->sadb_sa_flags = 0;
-
-	/* ADDRESS_SRC (old addr) */
-	addr = (struct sadb_address*)
-		skb_put(skb, sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
-	addr->sadb_address_proto = 0;
-	addr->sadb_address_reserved = 0;
-	addr->sadb_address_prefixlen =
-		pfkey_sockaddr_fill(&x->props.saddr, 0,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	if (!addr->sadb_address_prefixlen)
-		BUG();
-
-	/* NAT_T_SPORT (old port) */
-	n_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));
-	n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
-	n_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;
-	n_port->sadb_x_nat_t_port_port = natt->encap_sport;
-	n_port->sadb_x_nat_t_port_reserved = 0;
-
-	/* ADDRESS_DST (new addr) */
-	addr = (struct sadb_address*)
-		skb_put(skb, sizeof(struct sadb_address)+sockaddr_size);
-	addr->sadb_address_len =
-		(sizeof(struct sadb_address)+sockaddr_size)/
-			sizeof(uint64_t);
-	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
-	addr->sadb_address_proto = 0;
-	addr->sadb_address_reserved = 0;
-	addr->sadb_address_prefixlen =
-		pfkey_sockaddr_fill(ipaddr, 0,
-				    (struct sockaddr *) (addr + 1),
-				    x->props.family);
-	if (!addr->sadb_address_prefixlen)
-		BUG();
-
-	/* NAT_T_DPORT (new port) */
-	n_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));
-	n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
-	n_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;
-	n_port->sadb_x_nat_t_port_port = sport;
-	n_port->sadb_x_nat_t_port_reserved = 0;
-
-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));
-}
-
-#ifdef CONFIG_NET_KEY_MIGRATE
-static int set_sadb_address(struct sk_buff *skb, int sasize, int type,
-			    const struct xfrm_selector *sel)
-{
-	struct sadb_address *addr;
-	addr = (struct sadb_address *)skb_put(skb, sizeof(struct sadb_address) + sasize);
-	addr->sadb_address_len = (sizeof(struct sadb_address) + sasize)/8;
-	addr->sadb_address_exttype = type;
-	addr->sadb_address_proto = sel->proto;
-	addr->sadb_address_reserved = 0;
-
-	switch (type) {
-	case SADB_EXT_ADDRESS_SRC:
-		addr->sadb_address_prefixlen = sel->prefixlen_s;
-		pfkey_sockaddr_fill(&sel->saddr, 0,
-				    (struct sockaddr *)(addr + 1),
-				    sel->family);
-		break;
-	case SADB_EXT_ADDRESS_DST:
-		addr->sadb_address_prefixlen = sel->prefixlen_d;
-		pfkey_sockaddr_fill(&sel->daddr, 0,
-				    (struct sockaddr *)(addr + 1),
-				    sel->family);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-
-static int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *k)
-{
-	struct sadb_x_kmaddress *kma;
-	u8 *sa;
-	int family = k->family;
-	int socklen = pfkey_sockaddr_len(family);
-	int size_req;
-
-	size_req = (sizeof(struct sadb_x_kmaddress) +
-		    pfkey_sockaddr_pair_size(family));
-
-	kma = (struct sadb_x_kmaddress *)skb_put(skb, size_req);
-	memset(kma, 0, size_req);
-	kma->sadb_x_kmaddress_len = size_req / 8;
-	kma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;
-	kma->sadb_x_kmaddress_reserved = k->reserved;
-
-	sa = (u8 *)(kma + 1);
-	if (!pfkey_sockaddr_fill(&k->local, 0, (struct sockaddr *)sa, family) ||
-	    !pfkey_sockaddr_fill(&k->remote, 0, (struct sockaddr *)(sa+socklen), family))
-		return -EINVAL;
-
-	return 0;
-}
-
-static int set_ipsecrequest(struct sk_buff *skb,
-			    uint8_t proto, uint8_t mode, int level,
-			    uint32_t reqid, uint8_t family,
-			    const xfrm_address_t *src, const xfrm_address_t *dst)
-{
-	struct sadb_x_ipsecrequest *rq;
-	u8 *sa;
-	int socklen = pfkey_sockaddr_len(family);
-	int size_req;
-
-	size_req = sizeof(struct sadb_x_ipsecrequest) +
-		   pfkey_sockaddr_pair_size(family);
-
-	rq = (struct sadb_x_ipsecrequest *)skb_put(skb, size_req);
-	memset(rq, 0, size_req);
-	rq->sadb_x_ipsecrequest_len = size_req;
-	rq->sadb_x_ipsecrequest_proto = proto;
-	rq->sadb_x_ipsecrequest_mode = mode;
-	rq->sadb_x_ipsecrequest_level = level;
-	rq->sadb_x_ipsecrequest_reqid = reqid;
-
-	sa = (u8 *) (rq + 1);
-	if (!pfkey_sockaddr_fill(src, 0, (struct sockaddr *)sa, family) ||
-	    !pfkey_sockaddr_fill(dst, 0, (struct sockaddr *)(sa + socklen), family))
-		return -EINVAL;
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_NET_KEY_MIGRATE
-static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
-			      const struct xfrm_migrate *m, int num_bundles,
-			      const struct xfrm_kmaddress *k)
-{
-	int i;
-	int sasize_sel;
-	int size = 0;
-	int size_pol = 0;
-	struct sk_buff *skb;
-	struct sadb_msg *hdr;
-	struct sadb_x_policy *pol;
-	const struct xfrm_migrate *mp;
-
-	if (type != XFRM_POLICY_TYPE_MAIN)
-		return 0;
-
-	if (num_bundles <= 0 || num_bundles > XFRM_MAX_DEPTH)
-		return -EINVAL;
-
-	if (k != NULL) {
-		/* addresses for KM */
-		size += PFKEY_ALIGN8(sizeof(struct sadb_x_kmaddress) +
-				     pfkey_sockaddr_pair_size(k->family));
-	}
-
-	/* selector */
-	sasize_sel = pfkey_sockaddr_size(sel->family);
-	if (!sasize_sel)
-		return -EINVAL;
-	size += (sizeof(struct sadb_address) + sasize_sel) * 2;
-
-	/* policy info */
-	size_pol += sizeof(struct sadb_x_policy);
-
-	/* ipsecrequests */
-	for (i = 0, mp = m; i < num_bundles; i++, mp++) {
-		/* old locator pair */
-		size_pol += sizeof(struct sadb_x_ipsecrequest) +
-			    pfkey_sockaddr_pair_size(mp->old_family);
-		/* new locator pair */
-		size_pol += sizeof(struct sadb_x_ipsecrequest) +
-			    pfkey_sockaddr_pair_size(mp->new_family);
-	}
-
-	size += sizeof(struct sadb_msg) + size_pol;
-
-	/* alloc buffer */
-	skb = alloc_skb(size, GFP_ATOMIC);
-	if (skb == NULL)
-		return -ENOMEM;
-
-	hdr = (struct sadb_msg *)skb_put(skb, sizeof(struct sadb_msg));
-	hdr->sadb_msg_version = PF_KEY_V2;
-	hdr->sadb_msg_type = SADB_X_MIGRATE;
-	hdr->sadb_msg_satype = pfkey_proto2satype(m->proto);
-	hdr->sadb_msg_len = size / 8;
-	hdr->sadb_msg_errno = 0;
-	hdr->sadb_msg_reserved = 0;
-	hdr->sadb_msg_seq = 0;
-	hdr->sadb_msg_pid = 0;
-
-	/* Addresses to be used by KM for negotiation, if ext is available */
-	if (k != NULL && (set_sadb_kmaddress(skb, k) < 0))
-		goto err;
-
-	/* selector src */
-	set_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_SRC, sel);
-
-	/* selector dst */
-	set_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_DST, sel);
-
-	/* policy information */
-	pol = (struct sadb_x_policy *)skb_put(skb, sizeof(struct sadb_x_policy));
-	pol->sadb_x_policy_len = size_pol / 8;
-	pol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
-	pol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;
-	pol->sadb_x_policy_dir = dir + 1;
-	pol->sadb_x_policy_reserved = 0;
-	pol->sadb_x_policy_id = 0;
-	pol->sadb_x_policy_priority = 0;
-
-	for (i = 0, mp = m; i < num_bundles; i++, mp++) {
-		/* old ipsecrequest */
-		int mode = pfkey_mode_from_xfrm(mp->mode);
-		if (mode < 0)
-			goto err;
-		if (set_ipsecrequest(skb, mp->proto, mode,
-				     (mp->reqid ?  IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),
-				     mp->reqid, mp->old_family,
-				     &mp->old_saddr, &mp->old_daddr) < 0)
-			goto err;
-
-		/* new ipsecrequest */
-		if (set_ipsecrequest(skb, mp->proto, mode,
-				     (mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),
-				     mp->reqid, mp->new_family,
-				     &mp->new_saddr, &mp->new_daddr) < 0)
-			goto err;
-	}
-
-	/* broadcast migrate message to sockets */
-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &init_net);
-
-	return 0;
-
-err:
-	kfree_skb(skb);
-	return -EINVAL;
-}
-#else
-static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
-			      const struct xfrm_migrate *m, int num_bundles,
-			      const struct xfrm_kmaddress *k)
-{
-	return -ENOPROTOOPT;
-}
-#endif
-
-static int pfkey_sendmsg(struct kiocb *kiocb,
-			 struct socket *sock, struct msghdr *msg, size_t len)
-{
-	struct sock *sk = sock->sk;
-	struct sk_buff *skb = NULL;
-	struct sadb_msg *hdr = NULL;
-	int err;
-	struct net *net = sock_net(sk);
-
-	err = -EOPNOTSUPP;
-	if (msg->msg_flags & MSG_OOB)
-		goto out;
-
-	err = -EMSGSIZE;
-	if ((unsigned int)len > sk->sk_sndbuf - 32)
-		goto out;
-
-	err = -ENOBUFS;
-	skb = alloc_skb(len, GFP_KERNEL);
-	if (skb == NULL)
-		goto out;
-
-	err = -EFAULT;
-	if (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len))
-		goto out;
-
-	hdr = pfkey_get_base_msg(skb, &err);
-	if (!hdr)
-		goto out;
-
-	mutex_lock(&net->xfrm.xfrm_cfg_mutex);
-	err = pfkey_process(sk, skb, hdr);
-	mutex_unlock(&net->xfrm.xfrm_cfg_mutex);
-
-out:
-	if (err && hdr && pfkey_error(hdr, err, sk) == 0)
-		err = 0;
-	kfree_skb(skb);
-
-	return err ? : len;
-}
-
-static int pfkey_recvmsg(struct kiocb *kiocb,
-			 struct socket *sock, struct msghdr *msg, size_t len,
-			 int flags)
-{
-	struct sock *sk = sock->sk;
-	struct pfkey_sock *pfk = pfkey_sk(sk);
-	struct sk_buff *skb;
-	int copied, err;
-
-	err = -EINVAL;
-	if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))
-		goto out;
-
-	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);
-	if (skb == NULL)
-		goto out;
-
-	copied = skb->len;
-	if (copied > len) {
-		msg->msg_flags |= MSG_TRUNC;
-		copied = len;
-	}
-
-	skb_reset_transport_header(skb);
-	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
-	if (err)
-		goto out_free;
-
-	sock_recv_ts_and_drops(msg, sk, skb);
-
-	err = (flags & MSG_TRUNC) ? skb->len : copied;
-
-	if (pfk->dump.dump != NULL &&
-	    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)
-		pfkey_do_dump(pfk);
-
-out_free:
-	skb_free_datagram(sk, skb);
-out:
-	return err;
-}
-
-static const struct proto_ops pfkey_ops = {
-	.family		=	PF_KEY,
-	.owner		=	THIS_MODULE,
-	/* Operations that make no sense on pfkey sockets. */
-	.bind		=	sock_no_bind,
-	.connect	=	sock_no_connect,
-	.socketpair	=	sock_no_socketpair,
-	.accept		=	sock_no_accept,
-	.getname	=	sock_no_getname,
-	.ioctl		=	sock_no_ioctl,
-	.listen		=	sock_no_listen,
-	.shutdown	=	sock_no_shutdown,
-	.setsockopt	=	sock_no_setsockopt,
-	.getsockopt	=	sock_no_getsockopt,
-	.mmap		=	sock_no_mmap,
-	.sendpage	=	sock_no_sendpage,
-
-	/* Now the operations that really occur. */
-	.release	=	pfkey_release,
-	.poll		=	datagram_poll,
-	.sendmsg	=	pfkey_sendmsg,
-	.recvmsg	=	pfkey_recvmsg,
-};
-
-static const struct net_proto_family pfkey_family_ops = {
-	.family	=	PF_KEY,
-	.create	=	pfkey_create,
-	.owner	=	THIS_MODULE,
-};
-
-#ifdef CONFIG_PROC_FS
-static int pfkey_seq_show(struct seq_file *f, void *v)
-{
-	struct sock *s = sk_entry(v);
-
-	if (v == SEQ_START_TOKEN)
-		seq_printf(f ,"sk       RefCnt Rmem   Wmem   User   Inode\n");
-	else
-		seq_printf(f, "%pK %-6d %-6u %-6u %-6u %-6lu\n",
-			       s,
-			       atomic_read(&s->sk_refcnt),
-			       sk_rmem_alloc_get(s),
-			       sk_wmem_alloc_get(s),
-			       from_kuid_munged(seq_user_ns(f), sock_i_uid(s)),
-			       sock_i_ino(s)
-			       );
-	return 0;
-}
-
-static void *pfkey_seq_start(struct seq_file *f, loff_t *ppos)
-	__acquires(rcu)
-{
-	struct net *net = seq_file_net(f);
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-
-	rcu_read_lock();
-	return seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);
-}
-
-static void *pfkey_seq_next(struct seq_file *f, void *v, loff_t *ppos)
-{
-	struct net *net = seq_file_net(f);
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-
-	return seq_hlist_next_rcu(v, &net_pfkey->table, ppos);
-}
-
-static void pfkey_seq_stop(struct seq_file *f, void *v)
-	__releases(rcu)
-{
-	rcu_read_unlock();
-}
-
-static const struct seq_operations pfkey_seq_ops = {
-	.start	= pfkey_seq_start,
-	.next	= pfkey_seq_next,
-	.stop	= pfkey_seq_stop,
-	.show	= pfkey_seq_show,
-};
-
-static int pfkey_seq_open(struct inode *inode, struct file *file)
-{
-	return seq_open_net(inode, file, &pfkey_seq_ops,
-			    sizeof(struct seq_net_private));
-}
-
-static const struct file_operations pfkey_proc_ops = {
-	.open	 = pfkey_seq_open,
-	.read	 = seq_read,
-	.llseek	 = seq_lseek,
-	.release = seq_release_net,
-};
-
-static int __net_init pfkey_init_proc(struct net *net)
-{
-	struct proc_dir_entry *e;
-
-	e = proc_create("pfkey", 0, net->proc_net, &pfkey_proc_ops);
-	if (e == NULL)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static void __net_exit pfkey_exit_proc(struct net *net)
-{
-	remove_proc_entry("pfkey", net->proc_net);
-}
-#else
-static inline int pfkey_init_proc(struct net *net)
-{
-	return 0;
-}
-
-static inline void pfkey_exit_proc(struct net *net)
-{
-}
-#endif
-
-static struct xfrm_mgr pfkeyv2_mgr =
-{
-	.id		= "pfkeyv2",
-	.notify		= pfkey_send_notify,
-	.acquire	= pfkey_send_acquire,
-	.compile_policy	= pfkey_compile_policy,
-	.new_mapping	= pfkey_send_new_mapping,
-	.notify_policy	= pfkey_send_policy_notify,
-	.migrate	= pfkey_send_migrate,
-	.is_alive	= pfkey_is_alive,
-};
-
-static int __net_init pfkey_net_init(struct net *net)
-{
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-	int rv;
-
-	INIT_HLIST_HEAD(&net_pfkey->table);
-	atomic_set(&net_pfkey->socks_nr, 0);
-
-	rv = pfkey_init_proc(net);
-
-	return rv;
-}
-
-static void __net_exit pfkey_net_exit(struct net *net)
-{
-	struct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);
-
-	pfkey_exit_proc(net);
-	BUG_ON(!hlist_empty(&net_pfkey->table));
-}
-
-static struct pernet_operations pfkey_net_ops = {
-	.init = pfkey_net_init,
-	.exit = pfkey_net_exit,
-	.id   = &pfkey_net_id,
-	.size = sizeof(struct netns_pfkey),
-};
-
-static void __exit ipsec_pfkey_exit(void)
-{
-	xfrm_unregister_km(&pfkeyv2_mgr);
-	sock_unregister(PF_KEY);
-	unregister_pernet_subsys(&pfkey_net_ops);
-	proto_unregister(&key_proto);
-}
-
-static int __init ipsec_pfkey_init(void)
-{
-	int err = proto_register(&key_proto, 0);
-
-	if (err != 0)
-		goto out;
-
-	err = register_pernet_subsys(&pfkey_net_ops);
-	if (err != 0)
-		goto out_unregister_key_proto;
-	err = sock_register(&pfkey_family_ops);
-	if (err != 0)
-		goto out_unregister_pernet;
-	err = xfrm_register_km(&pfkeyv2_mgr);
-	if (err != 0)
-		goto out_sock_unregister;
-out:
-	return err;
-
-out_sock_unregister:
-	sock_unregister(PF_KEY);
-out_unregister_pernet:
-	unregister_pernet_subsys(&pfkey_net_ops);
-out_unregister_key_proto:
-	proto_unregister(&key_proto);
-	goto out;
-}
-
-module_init(ipsec_pfkey_init);
-module_exit(ipsec_pfkey_exit);
-MODULE_LICENSE("GPL");
-MODULE_ALIAS_NETPROTO(PF_KEY);
diff -Naur a/net/nfc/Makefile b/net/nfc/Makefile
--- a/net/nfc/Makefile	2015-01-29 17:41:03.000000000 -0800
+++ b/net/nfc/Makefile	2015-02-11 08:27:14.000000000 -0800
@@ -11,3 +11,4 @@
 		llcp_sock.o
 
 nfc_digital-objs := digital_core.o digital_technology.o digital_dep.o
+
